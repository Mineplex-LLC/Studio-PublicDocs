---
title: Player Death Listener
description: Handles player deaths, teleporting to spectators, and ending the game based on player count.
---

In this tutorial, we will walk through the implementation of the `PlayerDeathListener`. This listener handles player deaths during the `STARTED` game state by:
- Teleporting players to the spectator spawnpoint.
- Changing player states to "eliminated".
- Handling damage events related to dragon wings.
- Announcing player deaths.
- Managing game state transitions based on player count.

<Note title="Cuboid class" type="success">
    The Cuboid class would take up a lot of space, check out our implementation here:
    
    ðŸ”— [Cuboid class source code](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/java/com/mineplex/studio/dragons/objects/Cuboid.java)

    You'll need to add this to continue, as it's required to create a border.
</Note>

### Tutorial

<Step>

    <StepItem title="Create the PlayerDeathListener Class">
    Begin by creating the `PlayerDeathListener` class. This listener will be triggered during the `STARTED` game state, allowing us to handle player deaths appropriately.

    Hereâ€™s the structure of the class:

    ```java
    @Slf4j
    public class PlayerDeathListener extends AbstractStateBasedListener {
        private final Cuboid border;
        private BukkitTask bukkitTask;

        public PlayerDeathListener(final DragonsGame game, final DragonsPlugin plugin) {
            super(plugin, game, BuiltInGameState.STARTED);
            this.border = new Cuboid(
                    game.getGameWorld().getDataPoints("BORDER").getFirst(),
                    game.getGameWorld().getDataPoints("BORDER").getLast());
        }
    }
    ```

    - The `PlayerDeathListener` class extends `AbstractStateBasedListener`, ensuring it listens to the `STARTED` game state.
    - The `border` is a `Cuboid` representing the playable area, preventing players from leaving the game world.

    ðŸ”— [PlayerDeathListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/death/PlayerDeathListener.java)
    </StepItem>

    <StepItem title="Add a method to get the spectator spawnpoint">
    In our `DragonsGame` class, we'll add a method to get the Spectator spawnpoint
    ```java
    public Location getSpectatorLocation() {
        return this.getGameWorld().getMinecraftWorld().getSpawnLocation();
    }
    ```
    </StepItem>

    <StepItem title="Handle Player Deaths">
    Back in PlayerDeathListener, we'll handle player deaths. When a player dies, their health is reset, and they are teleported to the spectator location. Additionally, the player's state is changed to "eliminated."

    Hereâ€™s the `handleDeathEvent` method:

    ```java
    @EventHandler
    public void handleDeathEvent(final PlayerDeathEvent deathEvent) {
        deathEvent.deathMessage(Component.empty()); // Hide default death message
        deathEvent.getPlayer().setHealth(20); // Reset health to full
        deathEvent.getPlayer().teleport(this.game.getSpectatorLocation()); // Teleport to spectator area
        if (this.game.getPlayerState(deathEvent.getPlayer()).isAlive()) {
            this.game.getPlayerStateTracker().setPlayerState(deathEvent.getPlayer(), BuiltInPlayerState.ELIMINATED);
            this.announceDeath(deathEvent.getPlayer(), deathEvent.getDamageSource().getDirectEntity());
        }
    }
    ```

    - The player's health is reset to 20, and the default death message is cleared.
    - The player is then teleported to the spectator area.
    - If the player was alive before dying, their state is changed to "ELIMINATED", and the death is announced.

    </StepItem>

    <StepItem title="Create a placements list">
    This placements list will help us determine who dies in what order when we come to implementing our win handler.

    In the `DragonsGame` class, add a placements field.
    ```java
    private final List<OfflinePlayer> placements = new ArrayList<>();
    ```

    </StepItem>

    <StepItem title="Handle death messages">
    Add logic to handle the death message and update placements within our PlayerDeathListener class:

    ```java
    @EventHandler
    public void handleDeathMessage(final PlayerStateChangeEvent changeEvent) {
        if (!changeEvent.getToState().isAlive() && changeEvent.getToState().isGameParticipant()) {
            this.game.getPlacements().add(changeEvent.getPlayer());
        }
    }
    ```

    - This event handler listens for state changes, and if a player is eliminated, they are added to the placements list for scoring.

    </StepItem>

    <StepItem title="Handle Dragon Wing Flap Damage">
    We also need to handle any damage caused by the dragon's wing flap. If the damage comes from an entity explosion (e.g., the dragon), we cancel it.

    ```java
    @EventHandler
    public void onPlayerDamageByDragonWingFlap(final EntityDamageEvent event) {
        if (event.getEntity() instanceof Player && event.getCause() == EntityDamageEvent.DamageCause.ENTITY_EXPLOSION) {
            event.setCancelled(true); // Cancel damage from dragon wing flap
        }
    }
    ```

    - This event cancels damage events caused by dragon-related explosions, preventing players from being eliminated by environmental damage.

    </StepItem>

    <StepItem title="Announce Deaths">
    To announce player deaths, we create a helper method that broadcasts the death message to the entire server.

    ```java
    private void announceDeath(final Player player, final Entity killer) {
        if (killer != null && killer.customName() == null) {
            return;
        }
        Bukkit.broadcast(Component.join(
                JoinConfiguration.spaces(),
                PrefixUtil.getPrefix("Death"),
                killer == null
                        ? Component.translatable(
                                "mineplex.dragons.module.death.message_generic",
                                player.displayName().color(NamedTextColor.YELLOW))
                        .color(NamedTextColor.GRAY)
                        : Component.translatable(
                                "mineplex.dragons.module.death.message",
                                player.displayName().color(NamedTextColor.YELLOW),
                                Objects.requireNonNull(killer.customName()))
                        .color(NamedTextColor.GRAY)));
    }
    ```

    - This method constructs a message based on whether the player was killed by another player or by something else. The message is then broadcast to all players.

    </StepItem>

    <StepItem title="Manage Game State Transitions">
    Finally, we need to check if the game should end based on the number of players. We do this by adding a scheduled task that checks the player count every 2 ticks.

    ```java
    @Override
    public void register() {
        super.register();
        this.bukkitTask = new BukkitRunnable() {
            @Override
            public void run() {
                // check if players are inside the border
                for (final Player player : Bukkit.getOnlinePlayers()) {
                    final PlayerState playerState = PlayerDeathListener.this.game.getPlayerState(player);

                    if (!playerState.isAlive() && !PlayerDeathListener.this.border.isIn(player)) {
                        player.teleport(PlayerDeathListener.this.game.getSpectatorLocation());
                        continue;
                    }

                    if (playerState.isAlive() && !PlayerDeathListener.this.border.isIn(player)) {
                        PlayerDeathListener.this
                                .game
                                .getPlayerStateTracker()
                                .setPlayerState(player, BuiltInPlayerState.ELIMINATED);
                        PlayerDeathListener.this.announceDeath(player, null);
                    }
                }

                // Check if only one player is left
                if (PlayerDeathListener.this.getAlivePlayers().size() == 1) {
                    PlayerDeathListener.this
                            .game
                            .getPlacements()
                            .add(PlayerDeathListener.this.getAlivePlayers().getFirst());
                    PlayerDeathListener.this.game.setGameState(BuiltInGameState.ENDED);
                    this.cancel();
                    return;
                }

                // If no players are left, end the game
                if (PlayerDeathListener.this.getAlivePlayers().isEmpty()) {
                    PlayerDeathListener.this.game.setGameState(BuiltInGameState.ENDED);
                }
            }
        }.runTaskTimer(this.plugin, 2, 2);
    }
    ```

    - This `BukkitRunnable` checks every 2 ticks if players are within the border and eliminates those who are outside.
    - If only one player remains, the game ends, and the winner is placed in the placements list.
    - If no players are left, the game also ends.

    </StepItem>

    <StepItem title="Register the Listener">
    Finally, we need to register the `PlayerDeathListener` in the `DragonsGame` class.

    Add the listener registration to the setup method in the `DragonsGame` class:

    ```java
    this.listeners.add(new PlayerDeathListener(this, this.dragonsPlugin));
    ```

    - This adds the `PlayerDeathListener` to the list of listeners in the game, ensuring it is active during the `STARTED` game state.

    </StepItem>

</Step>

### Testing and Final Steps
After following the above steps, test the listener by:
- Ensuring that players are teleported to the spectator area upon death.
- Verifying that players outside the border are eliminated and teleported to the spectator area.
- Checking that the game ends when only one player remains or when no players are left.