[
  {
    "slug": "/advanced/managed-databases",
    "title": "Managed Databases",
    "description": "How to create and manage industry-standard databases for Studio projects including MySQL, PostgreSQL, and MongoDB",
    "content": "# When to use Managed Databases\n\nManaged databases are a powerful way to store and query data for your Studio project. Unlike the built-in Data Storage Module, these are highly flexible and often include a robust open-source driver and ecosystem. However, they also have a separate pricing structure and carry addiitonal operational burden.\n\nGenerally speaking, it is best for new projects or Studio developers to start with the built-in Data Storage Module. However, if you are already familiar with a specific database technology, or have a specific use case that requires a more powerful database, you may want to consider using a managed database.\n\n# Creating a Managed Database\n\nManaged Databases can be created with `yaml` files (simliar to purchase definitions) in your project's `config/databases` directory. These files define the database type, and may in the future also allow for version changes and other configuration options.\n\n## Example `config/databases/my-database.yaml`\n\n```yaml\ndatabaseName: \"my-database\"\r\ntype: \"MYSQL\" # can be one of MYSQL, POSTGRES, or MONGO\n```\n\nIf you are using the Mineplex-provided GitHub Publisher action, adding this file to your repository on the default branch will cause a MySQL database named `my-database` to be created.\n\n# Using a Managed Database\n\nThe Mineplex SDK provides built-in functionality for retrieving a database driver client based on its unique name. This client can be used to perform any operations that the database driver supports. For MySQL and Postgres, the SDK provides a `JDBC` client, and for MongoDB, the SDK provides a `MongoClient` client.\n\nMore details on retrieving a managed database client instance will be added soon.\n"
  },
  {
    "slug": "/auxiliary/data-privacy",
    "title": "Data Privacy",
    "description": "Comprehensive guidelines for safeguarding data.",
    "content": "We are committed to ensuring that all user data is protected and secure. To achieve this, studios must take proactive steps to safeguard sensitive or potentially malicious data.\n\n## How We Represent Sensitive Data\n\nSensitive data that should not be shared with the general public is marked with the `@SensitiveData` annotation on the class, field, argument, or other appropriate location.\n\n### What Does This Mean?\n\n* **No Logging**: Sensitive data must not be logged into the console.\n* **No Public Display**: Sensitive data must not be displayed in Minecraft chat for all players to see.\n* **Controlled Access**: Access to sensitive data should be restricted to authorized personnel only.\n* **Regular Audits**: Conduct regular audits to ensure compliance with data protection policies.\n\nViolations of these rules will result in repercussions for your studio, as defined in our Studio End User License Agreement.\n\n## Best Practices for Data Protection\n\nTo further ensure data privacy, studios should adhere to the following best practices:\n\n* **Minimize Data Collection**: Only collect data that is necessary for your operations.\n* **Data Anonymization**: Anonymize data whenever possible to protect user identities.\n* **Secure Coding Practices**: Follow secure coding practices to prevent vulnerabilities.\n* **Regular Updates**: Keep all systems and software up to date with the latest security patches.\n* **Training**: Provide regular training for staff on data protection and privacy best practices.\n\n***\n\n## Reporting Data Mishandling\n\nIt is essential that any violation of our data privacy policies be reported to us immediately, whether by the studio responsible or by a player who notices the issue. Prompt reporting allows us to take corrective action, such as removing sensitive data from logs, and remedy the situation.\n\n### How to Report\n\n* **Email**: Contact us at `support@mineplex.com`.\n* **Discord**: Ping us in the Studio Partner Discord after sending an email if the matter is urgent.\n\nBy adhering to these guidelines and promptly reporting any mishandling, you help us maintain a secure environment for everyone.\n"
  },
  {
    "slug": "/auxiliary/faq",
    "title": "Frequently Asked Questions",
    "description": "A set of frequently asked questions and answers.",
    "content": "### Custom Lobbies and Hubs\n\nThe following guidance applies to custom lobbies and hubs that exist outside of your primary game mode and serve the primary purpose of hosting players and re-queueing them for other games:\n\n* This is discouraged. We want to flatten the queueing within the Studio as much as possible, such that players queue directly for your game from the Mineplex Hub. We are working on figuring out a way for your purchase offerings and different game modes to be embedded or exposed within our lobby.\n* Please consider the genuine need for a secondary lobby: you should only implement this if it's of significant importance to your game functionality, for example - a cosmetic system that cannot be represented in games, only a Lobby. We will not allow lobbies just for linking games together and letting people talk.\n* However, if you need a second lobby, you should implement two games behind the scenes. These should probably be in the same game namespace. For example, `CakeWars-Lobby` and `CakeWars-Game` in the `Mineplex` namespace. In most cases, the lobby should probably be a relatively empty project that uses `DYNAMIC` allocation.\n\n### Manual Game Maintenance\n\nThe following guidance applies for manual game support operations, such as restarting \"unhealthy\" games:\n\n* We will be adding a health check mechanism that you can implement inside the game code. We will call this regularly and initiate restart events if an unhealthy signal is returned. More details on this should be released soon.\n* If you have an additional need to restart a game, adjust server settings, or perform other manual operational interventions, please reach out to our support team.\n* If you will be using our provisioned databases (such as MySQL, managed by Mineplex), you need to follow best-practices for automatically running migrations on game startup (consider something like Flyway or Liquibase). Similarly, you need to ensure backwards compatibility with changes since we may run different versions of your game at the same time during update events.\n\n### Manually Transferring Players\n\nThe following guidance applies for questions around manually transferring players between server instances and games:\n\n* We will provide an API you can poll that returns a list of active games in a namespace. You can manually transfer players between these with a piece of code. This should be used sparingly and intentionally, as we expect most player transfers to occur via our matchmaking system.\n"
  },
  {
    "slug": "/auxiliary",
    "title": "Auxiliary Information",
    "description": "A set of information surrounding the Mineplex Studio system.",
    "content": "# Auxiliary Information\n\nThis page provides a basic overview and links to detailed information about the Mineplex Studio system, including data privacy, FAQs, moderation, publishing guidance, the review process, and security guidelines.\n\n* Understand our commitment to protecting user data and the steps you need to take to ensure data privacy. [Learn More](/docs/auxiliary/data-privacy)\n* Find answers to common questions about using Mineplex Studio. [Learn More](/docs/auxiliary/faq)\n* Learn about our moderation to maintain a positive community. [Learn More](/docs/auxiliary/moderation)\n"
  },
  {
    "slug": "/auxiliary/moderation",
    "title": "Moderation Information",
    "description": "Information about our moderation processes",
    "content": "## Player Transparency\n\nGuidelines to ensure clear communication and accessibility of rules for players.\r\nTo ensure fair play and maintain trust, the following guidelines must be followed:\n\n* **Clear Communication**: Players must always be informed of the reason for their punishment.\n* **Accessibility of Rules**: Your game rules must be published on your Discord server or website and be accessible in-game.\n* **Distinct Game Rules**: If you have multiple games with different rules, it must be clearly communicated to players at the start of each game.\n\n## Studio Responsibility\n\nSpecific responsibilities of studios in enforcing their game rules.\r\nStudios are responsible for enforcing their specific game rules. Here are some examples (optional to enforce) of rules you might include:\n\n* **No Teaming**: Ensuring that players do not form teams in solo game modes or where teaming is not allowed.\n* **No Ghosting**: Preventing players from using outside communication to gain an unfair advantage or providing information to living players after being eliminated.\n* **No Griefing**: Protecting players from actions that intentionally disrupt their gameplay experience, such as destroying another player's creations or resources.\n* **Exploits and Bugs**: Prohibiting the use of game exploits or bugs to gain an unfair advantage and requiring players to report such issues.\n\nThis is not an exhaustive list; you are welcome to create and enforce your own rules.\n\n## Mineplex Responsibility\n\n**Description:** Broader moderation issues managed by Mineplex to maintain server-wide integrity.\r\nMineplex is responsible for addressing broader moderation issues that affect the entire server. This includes:\n\n* **Hacking**: Detecting and taking action against players using unauthorized mods or hacks to gain unfair advantages.\n* **Chat Offenses**: Monitoring and moderating in-game chat to prevent and address inappropriate language, harassment, and other violations of chat rules.\n* **Skin/Name Issues**: Ensuring that player skins and usernames adhere to community guidelines and do not include offensive or inappropriate content.\n* **Account Security**: Taking measures to protect player accounts from unauthorized access or compromise.\n* **Cheating Reports**: Providing a streamlined process for players to report cheating or other rule violations.\n\n## Additional Best Practices\n\n**Description:** Recommended practices to enhance player experience and community engagement.\r\nTo enhance the overall player experience and maintain a positive community, consider implementing the following practices:\n\n* **Regular Updates**: Keep your rules and guidelines up to date with regular reviews and adjustments based on community feedback and emerging issues.\n* **Education and Awareness**: Provide resources and training for moderators and players about the importance of fair play and community guidelines.\n* **Community Engagement**: Foster a positive community environment by encouraging player participation in discussions, events, and feedback sessions.\n* **Transparency in Actions**: When taking action against players, provide clear explanations and evidence to maintain transparency and trust.\n* **Moderation Tools**: Utilize advanced moderation tools and technologies to efficiently detect and address rule violations.\n* **Reward Positive Behavior**: Implement systems to reward players who consistently demonstrate positive behavior and sportsmanship.\n\nBy adhering to these guidelines and continuously striving to improve your moderation processes, you help create a safe and enjoyable environment for all players.\n"
  },
  {
    "slug": "/auxiliary/publishing",
    "title": "Publishing Projects",
    "description": "Learn how to publish and monetize your Studio game",
    "content": "As a Studio developer, you have the ability to interact with three different Mineplex hosted environments which serve different purposes. These are:\n\n* Development, or `dev` (which is allocated for developers and gives an automatic, unique IP when running start)\n* Staging, or `stg` (which is allocated for developers and has the lobby IP of `mc-stg.mineplex.com`)\n* Production, or `prod` (which is allocated for the general public has the lobby IP of `mineplex.com`)\n\n## Deployment Stages\n\n<Step>\n  <StepItem title=\"Development\">\n    Development containers should be used to verify your game works as expected, with your team.\r\n    You can generate a development container using the `studio start` command.\n  </StepItem>\n\n  <StepItem title=\"Staging\">\n    When you're happy with your changes, pushing them to your github repository will\n\n    This environment generally functions identically to the Production environment, with several key differences:\n\n    * There is an in-game override for free Crowns which can be used for testing in-game purchases\n    * The underlying hardware has additional limitations including lower network bandwidth and smaller compute resources\n    * Crown purchases to game modes (whether they are made with free or paid Crowns) are not paid out to developers, but can be manually refunded at any time\n    * Staging is intended for game development and testing, and is monitored regularly for misuse\n\n    When you push code changes to your project's GitHub repository, the Studio GitHub Publisher action will automatically build your project into a TAR file, upload it to the Studio, and upload your purchase definition files and game configuration to Mineplex. You can then launch your game mode within the Studio Staging environment identically to the Production environment, with the restrictions listed above.\n  </StepItem>\n\n  <StepItem title=\"Review\">\n    Once your game is ready for publishing, you must initiate a Game Review. During a Game Review, we perform static analysis and gameplay testing on your code (through both manual and automated means) to ensure that your game complies with the Mineplex terms of service and Studio guidelines. Submissions are processed on a first-come, first-serve basis, and reviews may take up to one week. In the event that your game is rejected, you can make the necessary adjustments and re-submit as soon as you are ready for an additional review.\n\n    You can read more information about our review process on this handy [information page](/docs/auxiliary/review-process).\n  </StepItem>\n\n  <StepItem title=\"Production\">\n    After your project has passed the review process, it will be automatically published to Production. Players in the general public can then discover and play your game, as well as spend Crowns on it which will be paid out (per your profit-sharing agreement) monthly!\n  </StepItem>\n</Step>\n\n## GitHub Publishing Action\n"
  },
  {
    "slug": "/auxiliary/review-process",
    "title": "Review Process",
    "description": "Information on how we review games",
    "content": "<Note title=\"Coming Soon\" type=\"success\">\n  This page is currently under construction. More information will be available soon.\n</Note>\n"
  },
  {
    "slug": "/auxiliary/security-guidelines",
    "title": "Security Guidelines",
    "description": "Rules about what you can and cannot do with the Studio platform.",
    "content": "We’re excited by the opportunities the Studio provides for innovation. However, the security of our platform is an essential and top priority. Players trust us to keep them and their data safe, and we therefore have strict security guidelines that all Studio developers must adhere to.\n\n<Note type=\"danger\" title=\"Warning!\">\n  Violation of the Studio security guidelines may lead to disciplinary actions including, but not limited to, account suspension, Crown payout confiscation, and legal action.\n</Note>\n\n## Security Rules and Prohibited Implementations\n\nThe following actions are prohibited in all Studio projects without our express written permission:\n\n* **External Network Calls**: No calls to external networks are allowed.\n* **Network Eavesdropping**: Prohibited activities include packet listeners or DNS/IP scanning.\n* **API Fuzzing**: No fuzzing, DoS, DDoS attacks, or unapproved load tests against Mineplex services.\n* **Data Exfiltration**: No unauthorized transfer of data, plugins, or assets.\n* **Java Native Interface (JNI)**: Usage of JNI is prohibited.\n* **Process Runners**: No unauthorized execution of external processes.\n* **Network Device Manipulation**: Activities like IP table access, ARP cache manipulation, and similar are forbidden.\n* **Container Runtime Access**: No attempts to access, interact with, or manipulate the underlying container runtime or Studio agent process.\n\n## Best Practices for Security\n\nTo further enhance security, studios should adhere to the following best practices:\n\n* **Secure Coding**: Follow secure coding practices to minimize vulnerabilities.\n* **Regular Updates**: Keep your development environment and dependencies up-to-date.\n* **Access Control**: Implement strict access control measures to ensure only authorized personnel can access sensitive areas of your project.\n* **Code Reviews**: Conduct regular code reviews to identify and mitigate potential security issues.\n* **Threat Modeling**: Regularly perform threat modeling to anticipate and defend against potential security threats.\n* **Incident Response Plan**: Have a clear incident response plan in place to quickly address any security breaches.\n\n## Reporting Security Issues\n\nIt is crucial that any security vulnerabilities or violations are reported immediately to maintain the integrity of our platform.\n\n### How to Report\n\n* **Email**: Contact us at `support@mineplex.com`.\n* **Discord**: Notify us in the Studio Partner Discord after sending an email for urgent issues.\n\nBy following these guidelines and promptly reporting any security concerns, you help us ensure a safe and secure environment for everyone.\n\n## FAQ\n\n### What should I do if I'm unsure whether an action is prohibited?\n\nIf you are unsure whether a specific action is allowed, please contact us in the Studio Partner Discord for clarification before proceeding.\n\n### Can I request permission for a prohibited action?\n\nYes, you can request permission by contacting us at `support@mineplex.com`. Provide a detailed explanation of your request and the reasons for it.\n\n### What happens if I accidentally violate a security rule?\n\nAccidental violations should be reported immediately. We will investigate the incident and work with you to resolve the issue, taking into account the nature and impact of the violation.\n\nBy adhering to these security guidelines and best practices, you contribute to the overall safety and trust of our platform.\n"
  },
  {
    "slug": "/cli/commands",
    "title": "Command-Line Interface (CLI) Reference Guide",
    "description": "This page contains a reference guide to all commands in the Studio CLI.",
    "content": "## Commands\n\n### `studio check`\n\nThis command validates your local environment and ensures that you have all the necessary dependencies (such as the GitHub CLI) installed.\r\nYou can also view your current authentication status by running `studio check`.\n\n### `studio login`\n\nTo use the CLI, you must log in to your Mineplex Studio Partner account. This is separate from your in-game account, and should be created from our website at [studio.mineplex.com](https://studio.mineplex.com).\n\nThen, you can run a command like `studio login -u example@example.com -p testpassword` to log in to your account.\n\nAfter logging in, the Studio CLI stores a long-lived authentication token in your system home directory with the file name `.mineplex-studio-credentials`.\n\nYou should generally never need to access or manage this manually, and should use the `logout` command to log out and invalidate existing tokens rather than deleting this file directly.\n\n### `studio logout`\n\nTo log out of your account, run `studio logout`. This invalidates your token and any active sessions, and deletes the authentication token from your system home directory.\n\n### `studio create-project`\n\nYou can run this command to create a Studio project. This will also create a boilerplate project in your current directory, and a GitHub repository\r\nfor your project. By default, the repository that the Studio CLI creates will be private, and will include an Actions secret for Studio deployments.\r\nYou can run `studio help create-project` for more information on the command.\n\nThere are several required arguments for this command:\n\n* `--name`: The name of your project. This should typically be a case-insensitive name like `cake-wars`.\n* `--repository`: The name of the GitHub repository (which will be created in GitHub by the Studio CLI). This must include your GitHub username or GitHub organization name, separated by a slash. For example, `Mineplex-LLC/CakeWars`.\n\nIf you wish to further customize your project, you may also append the following optional arguments:\n\n* `--description`: A description of your project. This will be used in the Studio control plane and is visible to your collaborators from our web interface.\n* `--groupId`: The Gradle group ID for your project. This is conventionally a reverse domain name, such as `com.mineplex`.\n* `--artifactId`: The Gradle artifact ID for your project. This is conventionally the name of your project without any special characters, such as `cakewars`.\n\nA full example of this command is `studio create-project --name CakeWars --repository Mineplex-LLC/CakeWars --description \"A fun game!\" --groupId com.mineplex --artifactId cakewars`.\n\nAfter you run this command, the Studio CLI automatically:\n\n1. Creates a private GitHub repository in the `Mineplex-LLC` org with the name `CakeWars` and clones it to your current working directory.\n2. Creates a Studio project within the Mineplex control plane with the name `CakeWars` and description `\"A fun game!\"`.\n3. Creates a deployment token for the project with the Mineplex control plane, and uploads it to the `CakeWars` GitHub repository as a secret.\n4. Generates and downloads a boilerplate project from the Mineplex control plane, and places it in your local repo (but does not commit or push it).\n\n### `studio list-projects`\n\nThis command lists all of your Studio projects. It will display the name, repository, and description of each project.\n\n### `studio build`\n\nBuilds the project in the working directory into a plugin JAR using the default Studio CLI settings and Gradle integration.\n\n### `studio start`\n\nThis command starts a Development Container for your project on the Mineplex staging network. It will automatically build the project in the working directory into a plugin JAR and watches the file system to alert you when changes are ready for hotswap.\n\nUsing Development Containers allows you to test your code in a production-like environment. After running this command, note the IP address that it prints to the console. You can connect to this IP address from your Minecraft client to test your project.\n\nFor security, development containers always have a player allowlist based on account UUIDs. You can manage the allowlist after running `studio start` for the first time, and can also save it to disk to avoid manually re-entering after each restart.\n\nOptional flags:\n\n* `--no-jar-build`: skips the automatic JAR build step, which may be useful if you have already built the plugin file or if you don't want to use the CLI's default Gradle integration.\n* `--plugin-path`: the relative path to the built plugin JAR file for your project; defaults to the JAR built by the CLI (using Gradle).\n\nAfter you run `studio start`, the CLI will continue to listen for additional commands that control your Development Container. These commands are:\n\n* `r`: Re-upload project assets and restart the Minecraft game process\n* `r-hard`: Forcefully restart the entire container (equivalent to `studio stop && studio start`)\n* `l`: Retrieve game process logs\n* `s`: Shutdown the running container fully (equivalent to `studio stop`)\n* `allowlist [add/remove] [player UUID]`: Add or remove a player by UUID to the container allowlist\n* `allowlist list`: Print a list of all players currently on the container allowlist\n* `allowlist save`: Save the current allowlist locally (per-project); it will be automatically restored on container startup\n* `allowlist clear`: Remove all existing players from the container allowlist\n\nIf you kill the CLI process, the Development Container will stay alive in the background. By default, containers live for a two-hour time duration, after which they are automatically cleaned up. You can only have one container running at a given time per Studio account.\n\n### `studio stop`\n\nForcefully shut down a running container. This can be useful if your container enters an unexpected state and is unresponsive to other commands, but it is generally faster to use the `r` command on a running container to hotswap new code and assets during development.\n\n## Organization Management\n\nStudio Organizations are groups of accounts that share projects and subscriptions. They are generally used to represent groups of developers working on the same game. Members of an Organization can have one of three roles:\n\n* Member: can perform read-only actions and use Development Containers\n* Admin: all the permissions of a Member, plus user management rights\n* Owner: all the permissions of an Admin, and cannot be removed from the Organization or demoted\n\n### `studio list-orgs`\n\nList the Organizations your account is authorized to act on.\n\n### `studio create-org --name [MyOrganization]`\n\nCreate a Studio Organization with the specified name. Note that names are globally unique and cannot be changed after the organization is created.\n\n### `studio org-add-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAdd an existing Studio account to the specified organization.\n\n### `studio org-list-users --org [MyOrganization]`\n\nList all of the users who are in the specified organization.\n\n### `studio org-remove-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAs an Admin or Owner, remove the specified user from the organization.\n\n### `studio org-promote-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAs an Admin or Owner, promote the specified Member to an Admin.\n\n### `studio org-demote-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAs an Admin or Owner, demote the specified Admin to a Member.\n\n### `studio org-redeem-promo-code --org [MyOrganization] --code [MyPromoCode]`\n\nAs an Admin or Owner, redeem a Mineplex-provided promo code for beta functionality or free or discounted subscriptions.\n\n### `studio org-transfer-project --org [MyOrganization]`\n\nTransfer the project within the current working directory to be owned by the specified Organization.\n\n### `studio org-list-projects --org [MyOrganization]`\n\nList the projects owned by the specified Organization.\n"
  },
  {
    "slug": "/cli",
    "title": "Command-Line Interface (CLI) Overview",
    "description": "An introduction to the Mineplex Studio CLI.",
    "content": "![Banner](/images/cli.png \"Mineplex Studio CLI\")\n\nThe Studio CLI is a command-line interface for Windows, Mac, and Linux that allows you to create and develop content on Mineplex.\n\nWhile you can interact with our control plane API directly (and may wish to in custom build and deployment environments), the CLI provides a simple, intuitive mechanism for getting started with the Mineplex Studio platform. It wraps helpful functionality for both beginners and advanced users, including project scaffolding, hotswapping development builds, and more.\n"
  },
  {
    "slug": "/cli/installation",
    "title": "CLI Installation",
    "description": "Instructions to install the Studio CLI",
    "content": "The Mineplex Studio CLI is distributed as a pre-built binary file for Windows, Mac, and Linux.\n\nYou can download the Studio CLI for your platform:\n\n<CardGrid>\n  <Card title=\"Windows\" subtitle=\"Download\" variant=\"small\" href=\"https://public-mineplex-content.s3.amazonaws.com/studio-cli-win.exe\" external=\"true\" />\n\n  <Card title=\"Mac\" subtitle=\"Download\" variant=\"small\" href=\"https://public-mineplex-content.s3.amazonaws.com/studio-cli-macos\" external=\"true\" />\n\n  <Card title=\"Linux\" subtitle=\"Download\" variant=\"small\" href=\"https://public-mineplex-content.s3.amazonaws.com/studio-cli-linux\" external=\"true\" />\n</CardGrid>\n\nYou may wish to rename the Studio binary file and add it to your path or project directory. In our documentation, we use the `studio` command, which references a version of the binary file that has been added to the system path.\n\nOn a Windows system, you can add executables to the system path from the Environment Variables menu in the Control Panel. On a Mac or Linux system, you can add executables to the system path by editing the `~/.bashrc` or `~/.zshrc` file.\n\nNote that there are peer dependencies to the Studio CLI. Specifically, you must have the GitHub CLI installed (as well as Java to fully utilize optional CLI functions).\r\nTo validate your system setup, run the `studio check` command in your terminal.\n"
  },
  {
    "slug": "/configuration",
    "title": "Project Configuration",
    "description": "How to adjust your project configuration",
    "content": "## Adjusting Game Properties\n\nIn order to configure your project, we provide a file! This allows you to change your project's behaviour.\n\nAll Studio projects have an auto-generated file, see below for the file structure.\n\n<FileTree>\n  <Folder name=\"config\" label=\"config\">\n    <File name=\"game-properties.yaml\" label=\"game-properties.yaml\" />\n  </Folder>\n</FileTree>\n\n## Example Properties File\n\n```yaml\n# DO NOT EDIT: this project ID is unique to your repository and should not be changed\r\nprojectId: 6546c318242da444451434bd\r\n\r\n# This is a mandatory user-specified identifier that can be used to share products and data between games.\r\n# If you wish to share data (including player stats, purchases, leaderboard rankings, and more) between multiple Studio projects, \r\n# you should sync this attribute. This field is internal, and is not visible within your game. \r\nnamespaceId: MineplexStudio \r\n\r\ngame:\r\n  # a name given to your game\r\n  name: MicroBattles \r\n  # The visibility of your game. Options: HIDDEN, PLAYTEST, PUBLIC\r\n  visibility: PUBLIC \r\n  # A multiline description for your game\r\n  description: [\"§fBe the §eLast Team §fstanding\", \"§fThe §bGlass Barrier §fwill disappear after §c10 seconds\"] \r\n  # The item to be displayed in the game explorer\r\n  iconItem: \"minecraft:beacon\"\r\n  # A category for your game\r\n  category: \"PvP\"\r\n  # Any tags you'd like to add to your game\r\n  tags: [ \"Team\", \"Strategy\" ]\r\n  # The display name of your game in the lobby menu\r\n  displayName: \"Micro Battles\"\r\n  # players whitelisted to test your game on staging\r\n  playtestPlayerIds: [\"b2cc0572-9634-4210-baa6-803d7cb4f511\", \"0c6b231a-1f12-49b6-a1fc-1a9279de277c\"]\r\n  # an icon url to show on the bedrock compass\r\n  iconURL: \"https://fastly.picsum.photos/id/21/200/200.jpg?hmac=a2iQ6UhOjpU6jn7QSsCpk1CiiKTxmW1R4UivDsv-n8o\"\r\n  # supported Minecraft platforms\r\n  supportedPlatforms: [\"JAVA\", \"BEDROCK\"]\r\n\r\n# matchaker configuration\r\nmatchmaker:\r\n  # an allocation mode (See details below)\r\n  allocationMode: DYNAMIC \r\n  # Only can be set when allocationMode is STATIC\r\n  maxReplicas: 4 \r\n  # The minimum players for an instance (server) to start up\r\n  minPlayers: 2\r\n  # The maximum amount of players an instance of your game holds\r\n  maxPlayers: 16\r\n  # Determines if players should be allowed to join an instance of your game that is already running\r\n  allowPlayerBackfill: false\r\n\r\n# any mineplex provided dependencies you'd like to add - requires Organization account\r\ndependencies:\r\n  libraries:\r\n    - MYTHIC_MOBS\r\n    - MODEL_ENGINE\r\n    - MYTHIC_DUNGEONS\r\n    - MYTHIC_CRUCIBLE\n```\n\n## Matchmaking and Game Allocation\n\n### STATIC mode:\n\n* Your game will be allocated as a set of stateful containers. You can specify an additional property for the maximum number of containers (maxInstanceCount) and we will automatically provision additional servers based on the actual player load over time, up to that maximum count.\n* In a static mode, players can queue for a specific instance of your game. For example, Clans-1, Clans-2, and so on.\r\n  Your code should not make any assumptions about the actual number of servers at any given time. If there are no players on Clans-2, we may deallocate that instance until someone re-queues for Clans-2, at which point the server will be re-allocated (with its state restored).\n* We reserve the right to restart containers as needed, but will fire off an event to your game before doing so. For example, if we need to restart Clans-2 to apply a code update that you published, our orchestration server will give your game a grace period to shut down before it is automatically restarted. This will be very similar to a SIGTERM and SIGKILL lifecycle in a process -- the game gets a warning first, giving it a chance to gracefully handle a shutdown, and then it is forcefully shut down at some point in the future. Our systems will make a best-effort attempt to avoid restarting instances with active players, and we will work on exposing the grace period as a parameter to you. We are still figuring out the best way to handle this case, but want for you to plan in advance for it.\n\n### DYNAMIC mode:\n\n* Your game will be allocated on-demand in response to matchmaking and queuing events. For example, if your game requires four players to begin, and eight players enter the queue, two instances of the game will be created automatically by our matchmaking and orchestration systems behind the scenes. These players are also transferred automatically once your game enters a healthy state as per our SDK lifecycle management.\n* In a dynamic mode, players queue for your game mode itself, and are allocated to game instances as they become available. For example, players may queue for SSM and end up being assigned to any number of different servers, as per our orchestration logic.\n* Your game must interact with our lifecycle SDK to indicate when it is safe or unsafe to shut down the game. This is usually between minigame iterations. Our systems make a best-effort attempt to keep the container alive, and may add more players during this time (it's like a game lobby window). However, in some cases (such as if insufficient players are in the game mode), the container may be shut down. Once again, we will deliver a shutdown event and a grace period in case you want to re-queue players for another mode or lobby before the container is killed. Otherwise, players are sent back to the Mineplex hub.\n\n## Dependencies\n\n<Note type=\"note\">\n  This feature requires an Organization subscription, individual subscriptions cannot use this feature!.\n</Note>\n\nMineplex has partnered with a number of leading plugin authors to support unique and innovative game experiences within the Studio. These plugins can be enabled using the `dependencies.libraries` configuration property within the `game-properties.yaml` file.\n\nSome of the values that are currently supported are:\n\n* `MYTHIC_MOBS`: This plugin allows you to create custom mobs with unique abilities and behaviors.\n* `MODEL_ENGINE`: This plugin allows you to create custom models for mobs, items, and blocks.\n* `MYTHIC_DUNGEONS`: This plugin allows you to create custom dungeons with unique mobs, loot, and mechanics.\n* `MYTHIC_CRUCIBLE`: This plugin allows you to create custom PvP arenas with unique mechanics and objectives.\n\n## Game Explorer Configuration\n\nPlayers can find your game from the Mineplex Lobby using the compass icon and navigation menu. In the game explorer menu, they are able to see a list of attributes that describe your game which can be configured in the `game-properties.yaml` file. These attributes include:\n\n* `game.displayName`: (string) the name of your game as shown to players in the game explorer menu. Unlike the project name (in `game.name`, which is used internally), this name can contain spaces and special characters.\n* `game.visibility`: (`HIDDEN`, `PLAYTEST`, or `PUBLIC`) determines if your game is visible to players in the staging game explorer menu. Most games that are actively being developed and iteratively released (they are not in an initial draft stage) should be set to `PLAYTEST`. This setting only impacts the staging environment, as all approved and published games are visible in production.\n* `game.description`: (string\\[]) a brief description of your game, separated into lines.\n* `game.iconItem`: (string) the item that represents your game in the game explorer menu. This should be a valid Minecraft item ID, such as `minecraft:diamond_sword`.\n* `game.iconURL`: (string) a URL to an image that represents your game in the game explorer menu. This is only visible in Bedrock clients.\n* `game.category`: (string) the category that your game falls under in the game explorer menu. Examples include `Survival`, `PvP`, and `Parkour`.\n* `game.tags`: (string\\[]) a list of tags that describe your game. These can describe categories, but can also describe attributes of the game such as `Team`, `Sandbox`, and so on.\n* `game.playtestPlayerIds`: (string\\[]) a list of player UUIDs that are allowed to playtest your game on the staging network. This is useful for sharing your game with a select group of players before it is published to the Mineplex network.\n\n## Advanced Configuration and Overrides\n\nThere are a set of internal overrides that can be applied to your project by the Mineplex team. These unlock advanced or non-standard functionality, which is generally available, but not exposed in the `game-properties.yaml` file. We currently support:\n\n* **Persistent volumes**\n  * When this setting is enabled, a persistent network file system will be attached to each of your game servers. It will be consistent based on the game identifier (for example, `Game-1` and `Game-2` will have unique file stores, but the file system within each is persistent across server restarts).\n  * The file system is always mounted at the `/data` directory.\n  * This feature is only supported for games that use the `STATIC` allocation mode.\n* **Health check modifications**\n  * Changing the default health check wait time after server initialization. This may be useful if your games take a long time to start up, and you want to avoid the health check failing prematurely.\n  * Changing the default health check interval. This may be useful if your game may be expected to ignore the Health SDK or not respond to it in a timely manner.\n\nIf you are interested in enabling these features, please reach out to us via a support request.\n"
  },
  {
    "slug": "/getting-started/example-project",
    "title": "Example Project",
    "description": "An example project to demonstrate how to implement features using Mineplex Studio.",
    "content": "To help you get started with Mineplex Studio, we have provided an example project. This project showcases how to implement our features and can serve as a reference for your own projects.\n\n## Project Overview\n\n* **Project Name**: Survival Games\n* **Description**: A basic working example of a survival games game mode.\n* **Repository**: [Mineplex Studio Example Project](https://github.com/Mineplex-LLC/StudioExample-SurvivalGames)\n\n## Key Features\n\n* **Game Mechanics**: Essential game mechanics are already implemented for you.\n* **Configuration**: The configuration is set up to demonstrate how to use our features effectively.\n\n## Need Help?\n\nIf you have any further questions or need assistance, please reach out in our Studio Partner Discord\n\nThis example project is designed to provide you with a practical starting point and to illustrate best practices for working with Mineplex Studio.\n"
  },
  {
    "slug": "/getting-started",
    "title": "Quick Start Guide",
    "description": "How to get started with the Mineplex Studio.",
    "content": "## Ready to get started with the Mineplex Studio?\n\nThese are the basic steps to get started!\n\n<Step>\n  <StepItem title=\"Prerequisites\">\n    Before you can get started with the Mineplex Studio, you'll need to install the [Studio CLI](/docs/cli/installation) and [GitHub CLI](https://cli.github.com/). You'll also need a GitHub account.\r\n    Next, head to the [Mineplex Studio](https://studio.mineplex.com) and create a Studio developer account. You can also create and manage organizations from this site to share access across organizations. As part of the account creation process, you'll need to verify your email address and subscribe to one of our plans (this helps cover the cost of running development containers and hosting the rest of your infrastructure for free!).\n  </StepItem>\n\n  <StepItem title=\"Creating a Project\">\n    Once you've installed the Studio CLI and created a Studio Partner account, you're ready to create your first project. To do so, use the `studio login` and `studio create-project` commands. For details, see the [CLI documentation](/docs/cli/commands).\n  </StepItem>\n\n  <StepItem title=\"Editing Your Project\">\n    When you open the project that the Studio CLI created, you'll see a few files and folders. The most important of these is the `src` folder, which contains the source code for your project. You can edit this code to customize your project. For example, you can add new abilities to your game, or change the behavior of existing abilities. While you have full access to the Spigot APIs from your project, we also provide a set of abstractions that make it easier to build games. For more information, see the [Game API documentation](/docs/sdk-game).\r\n    The CLI also adds a few `.yaml` files automatically that hold your game configuration. You can define things player count constraints, matchmaking rules, product offerings for players, and more in these files. For more information, see the [configuration documentation](/docs/configuration).\n  </StepItem>\n\n  <StepItem title=\"Testing Your Project\">\n    Once you've made some changes to your project, you can test them in the Studio staging environment with the CLI hotswap command. This will build your project continuously based on file system changes and allow you to connect to a remote container IP and test your game. For more information, see the [CLI documentation](/docs/cli/commands).\n  </StepItem>\n\n  <StepItem title=\"Deploying Your Project\">\n    Once you're happy with your changes, you can deploy them to Mineplex. By default, the Studio CLI creates a deployment action that runs via GitHub Actions\r\n    in your repository whenever you push to the `main` branch. This action will build your project and deploy it to Mineplex. Additional features (such as publishing channels, change management, and more) are coming soon!\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/getting-started/namespaces",
    "title": "Project Namespaces",
    "description": "How to use the Project Namespaces on the Mineplex Studio.",
    "content": "Projects on the Mineplex Studio can optionally be grouped together inside Namespaces. Grouping Projects together within a Namespace allows you to share resources such as purchases, player stats, player data, and more.\n\nBy default, a Project is created inside its own independent Namespace. You can view and update a Project's Namespace from the `config/game-properties.yaml` file. You should exercise caution when changing a Namespace, since updates can be destructive and may cause your Project to lose access to existing resources inside its previous Namespace.\n\nCurrently, the following resources are shared by all Projects inside a Namespace:\n\n* [Namespace Bans](/docs/sdk/features/moderation)\n* [Data Collections](/docs/sdk/features/data)\n* [Purchaseable Products and Subscriptions](/docs/sdk/features/purchase)\n* [Player Stats](/docs/sdk/features/stats)\n* [Leaderboards](/docs/sdk/features/leaderboard)\n* [Persistent World Buckets](/docs/sdk/features/world)\n"
  },
  {
    "slug": "/introduction",
    "title": "Introduction",
    "description": "This section provides an overview of how to get started with the Mineplex Studio.",
    "content": "![Banner](/images/banner.png \"Mineplex Studio\")\n\n## Mineplex Studio Overview\n\nWelcome to **The Mineplex Studio**, The Studio empowered developers worldwide to create their own minigames and game networks within Minecraft, with cross-platform support, monetization, and infrastructure hosting built-in. The Studio platform massively lowered the barrier to entry for game development in Minecraft and is now publicly available.\n\nInspired by innovations in the gaming space from titles like Roblox and Fortnite, we\r\ninvented the Studio to empower our players to develop games surpassing those they previously\r\nplayed on Mineplex servers and in other titles.\r\nAfter the 2023 shutdown and restructure of the company, we received many requests to\r\nrelaunch both the Java and Bedrock servers, alongside an overwhelming interest in game\r\ndeveloper positions. While considering the skills and interests of the community, along with\r\nMineplex’s long-term goals of inspiring and empowering creators, we decided to create the\r\nStudio to revolutionize the gaming infrastructure space.\n\n<CardGrid>\n  <Card subtitle=\"Getting Started\" title=\"Command Line Interface\" description=\"Get started with our CLI (command line interface). The portal to interact with your Studio Project.\" href=\"/docs/cli\" />\n\n  <Card subtitle=\"Getting Started\" title=\"Project Configuration\" description=\"Some basics around configuring your game, to allow us to understand how your game is to run.\" href=\"/docs/configuration\" />\n\n  <Card subtitle=\"Getting Started\" title=\"Studio Development Kit\" description=\"Our Java studio development kit enables you to interact with our infrastructure within your code, at runtime.\" href=\"/docs/sdk\" />\n</CardGrid>\n\n## Why Mineplex Studio?\n\nThe Mineplex Studio is a groundbreaking platform that redefines the way developers create games within Minecraft. By providing a comprehensive ecosystem of tools and services, it eliminates traditional barriers to entry and empowers creators of all skill levels to bring their visions to life. With cross-platform support, built-in monetization options, and reliable infrastructure hosting, The Studio streamlines the game development process, allowing developers to focus on creativity while we handle the technical complexities. Whether you’re an experienced developer or just starting out, The Studio offers everything you need to design, publish, and sustain your games.\n\nInspired by platforms like Roblox and Fortnite, The Mineplex Studio was built to encourage innovation and surpass expectations. It enables developers to create games that rival or exceed those previously seen on Mineplex servers or other popular titles. More than a development tool, it’s a platform designed to foster creativity and collaboration, making it ideal for building new experiences that captivate players. By prioritizing community feedback and aligning with Mineplex’s mission to inspire creators, The Studio combines cutting-edge technology with the vision of a thriving developer community.\n\n## Key Features\n\nHere are some of the features that make us ideal for building your game:\n\n| Feature                              | Description                                                                                                      |\r\n|--------------------------------------|------------------------------------------------------------------------------------------------------------------|\r\n| **Matchmaking** | Provides advanced matchmaking algorithms to ensure players are grouped together based on skill level, preferences, and game type, creating balanced and enjoyable gameplay experiences. |\r\n| **Infrastructure** | Delivers scalable, high-performance hosting solutions to ensure your games run smoothly with minimal downtime, regardless of player traffic or complexity. |\r\n| **Databases** | Offers robust and secure database integration for storing player data, game progress, and other critical information, enabling developers to focus on creating experiences rather than managing data. |\r\n| **Moderation** | Includes built-in moderation tools for managing player behavior, enforcing community guidelines, and ensuring a safe and enjoyable environment for all users. |\r\n| **Model Engine** | Provides a powerful engine for creating and implementing custom 3D models, animations, and assets directly within Minecraft, giving developers unlimited creative potential. |\r\n| **Cross Play Support** | Ensures seamless compatibility across multiple platforms, allowing players to join and enjoy your games regardless of their device, be it PC, console, or mobile. |\n\n## Join our Community\n\nIf you have questions about anything related to the Mineplex Studio, you're always welcome to ask our community on [Discord](https://discord.gg/khutqUK6Ts).\n"
  },
  {
    "slug": "/sdk/custom",
    "title": "Custom Modules",
    "description": "How to create custom Mineplex Studio Modules.",
    "content": "Creating your own custom `MineplexModule`s is almost effortless! Simply create a class that implements the `MineplexModule` interface, then register it as a `MineplexModule` when your project starts up using the `registerModule(T)` method in the `MineplexModuleManager`. Once your `MineplexModule` is registered, it is able to function as a `Listener`, and/or perform any custom behavior you decide to implement, either independently or in concert with other `MineplexModule`s.\n\n## MineplexModule Interface\n\n### `setup()` and `teardown()` Methods\n\nThese methods are responsible for creating and configuring any additional resources needed by your custom `MineplexModule`, and for destroying and cleaning up these resources, respectively. **NOTE: You do NOT need to register/unregister your `MineplexModule` as a `Listener` in these methods!**\n\n# Example\n\n## Creating a `MineplexModule`\n\nLet's build a very basic custom module that registers an additional `Listener` with itself.\n\n```java\n@MineplexModuleImplementation(MyCustomModule.class)\r\npublic class MyCustomModule implements MineplexModule {\r\n    private final JavaPlugin myProjectPlugin;\r\n    private MySignListener mySignListener;\r\n\r\n    public MyCustomModule(final JavaPlugin myProjectPlugin) {\r\n        this.myProjectPlugin = myProjectPlugin;\r\n    }\r\n\r\n    @Override\r\n    public void setup() {\r\n        mySignListener = new MySignListener();\r\n        Bukkit.getPluginManager().registerEvents(mySignListener, myProjectPlugin);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        HandlerList.unregisterAll(mySignListener);\r\n        mySignListener = null;\r\n    }\r\n}\n```\n\n## Registering your `MineplexModule`\n\nNow that we've created our module, we need to register it from our project class.\n\n```java\npublic class MyProject extends JavaPlugin {\r\n    @Override\r\n    public void onEnable() {\r\n        MineplexModuleManager.getInstance().registerModule(new MyCustomModule(this));\r\n    }\r\n\r\n    @Override\r\n    public void onDisable() {\r\n        MineplexModuleManager.getInstance().destroyModule(MyCustomModule.class);\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/chat",
    "title": "Chat Module",
    "description": "How to use the Mineplex Studio Chat Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.chat.ChatModule\" />\n\nThe Chat Module is one of the built-in Studio Modules that controls player chat. Through the Chat Module, player chat can be enabled or disabled in each channel, chat rendering formats can be set, and chat audiences can be controlled. The Chat Module additionally allows you to use our chat filter for aspects of your game that take in user input.\n\n## Chat Channels\n\nChat Channels allow for the division of player chat into specific sections, each with their own configurable audience and rendering format. You can access some of our built in chat channels using the BuiltInChatChannel enum, or create your own by adding new classes or enums that implement the ChatChannel interface. Each chat channel must have an internal identifier that can be used by our chat reporting system.\n\n### Chat Channel Audience\n\nChat Channels can be configured with different Audiences based on the player sending a message using the Chat Module's `setAudienceFunction(ChatChannel, Function<Player, Set<Audience>>)` method. This function is evaluated each time a message is sent by a player in the channel and used to generate the set of Audiences of the message. The `Audience` class is provided by the third party [Adventure API](https://docs.advntr.dev/index.html). More details can be found on their wiki as to how this works.\n\n### Chat Channel Rendering Format\n\nChat Channel formatting is configurable in the Chat Module using the `setChatRenderer(ChatChannel, ChatRenderer)` method. The `ChatRenderer` class is provided by the third party [Adventure API](https://docs.advntr.dev/index.html). More details can be found on their wiki as to how this works.\n\n### Player Chat Channels\n\nThere are two primary ways for you to manage player interaction via chat channels. Your first option is to use the `setChatChannel(Player, ChatChannel)` method, which sets the active chat channel that a player is currently chatting in. With this set, all the messages a player subsequently sends will be directed to that channel. Alternatively, you can use the `sendToChatChannel(ChatChannel, Player, Component)` method, which will manually send a message from a given player to the target chat channel, just as if the player had sent it themselves.\n\n### Chat Channel Silence\n\nThrough the Chat Module methods `isChatSilenced(ChatChannel)` and `setChatSilence(ChatChannel, boolean)`, you can check if chat is enabled in a given chat channel, as well as enable or disable chatting in a given chat channel.\n\n## Chat Filter\n\nAll Studio projects are required to run any user-provided text that will be displayed to other players through our chat filter. The Chat Module provides the method `isFiltered(String)`, which returns true if the String text is determined to be blocked by our chat filter. There is also a method `isFilteredAsync(String)` which can be used to query the chat filter asynchronously. When filtering text from the main thread, the asynchronous approach should always be used.\n\n# Examples\n\n## Chat Filtering\n\nLet's imagine that players are allowed to freely build in our game. In Minecraft, players are able to write text on signs that they place in the world. If players can place down signs, we have to make sure to run the sign text through the chat filter. This can be done in an event `Listener`.\n\n```java\n@EventHandler\r\npublic void onSignEdit(final SignChangeEvent event) {\r\n    // Since a sign is essentially one message, we want to filter all its lines together.\r\n    final StringBuilder messageBuilder = new StringBuilder();\r\n    for (final Component line : event.lines()) {\r\n        // Since Signs can have component lines, we have to serialize each line into plain text to filter it.\r\n        messageBuilder.append(' ').append(PlainTextComponentSerializer.plainText().serialize(line));\r\n    }\r\n    // Since the SignChangeEvent is fired on the main thread, we have to check the filter asynchronously.\r\n    chatModule.isFilteredAsync(messageBuilder.toString())\r\n            .thenAccept(filtered -> {\r\n                // If the line wasn't filtered, we don't need to do anything\r\n                if (filtered) {\r\n                    Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n                        // Update the sign to clear its lines\r\n                        if (event.getBlock().getState() instanceof final Sign sign) {\r\n                            SignSide side = sign.getSide(event.getSide());\r\n                            final Component cleared = Component.text(\"\");\r\n                            // Minecraft signs have only 4 lines\r\n                            for (int i = 0; i < 4; i++) {\r\n                                side.line(i, cleared);\r\n                            }\r\n                            // We want to update the sign without triggering a game physics update\r\n                            sign.update(false, false);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n}\n```\n\n## Chat Channels\n\n### Custom Channel\n\nFor the next few examples, let's imagine we're creating a Factions game and we need a chat channel for allied Factions to talk to one another in private.\n\n```java\npublic class AllyChatChannel implements ChatChannel {\r\n    @Override\r\n    public String getInternalIdentifier() {\r\n        return \"mygame.allychat\";\r\n    }\r\n}\n```\n\n### Audience\n\nSince we only want allies of the sender's Faction to see messages in Ally chat, we have to configure a custom audience for the channel.\n\n```java\npublic void setupChannelAudiences() {\r\n    chatModule.setAudienceFunction(allyChatChannel, sender -> {\r\n        // Determine what Faction the sender is in\r\n        final Optional<Faction> senderFaction = getFaction(sender);\r\n        // If the sender has no Faction, there are no allies to see their chat\r\n        if (senderFaction.isEmpty()) {\r\n            return Set.of(Audience.audience(sender));\r\n        }\r\n        final Set<Audience> audiences = new HashSet<>();\r\n        // All the members of the sender's own Faction should be considered allies\r\n        audiences.add(Audience.audience(senderFaction.get().getMembers()));\r\n        // Create an audience for each allied Faction\r\n        for (final Faction allyFaction : senderFaction.get().getAllies()) {\r\n            audiences.add(Audience.audience(allyFaction.getMembers()));\r\n        }\r\n        return audiences;\r\n    });\r\n}\n```\n\n### Rendering\n\nWe also want to give our custom chat channel a distinct format and style so the allies know who is chatting.\n\n```java\nprivate static final String CHAT_FORMAT = \"<dark_green>[<faction>]</dark_green><display_name><green>: </green><message>\";\r\n\r\npublic void setupChannelRenderers() {\r\n    chatModule.setChatRenderer(allyChatChannel, (source, sourceDisplayName, message, viewer) -> {\r\n        final String factionName = getFaction(source).map(Faction::getName).orElse(\"\");\r\n        // Renders chat in the format [Faction Name] Player Name: Message\r\n        return MiniMessage.miniMessage()\r\n                .deserialize(\r\n                        CHAT_FORMAT,\r\n                        Placeholder.parsed(\"faction\", factionName),\r\n                        Placeholder.component(\"display_name\", sourceDisplayName),\r\n                        Placeholder.component(\"message\", message));\r\n    });\r\n}\n```\n\n### Player Channels\n\nFinally, we need a way for players to use the ally chat. Let's imagine we've created a `/allychat` command that can either include a message, or switch your chat to ally chat.\n\n```java\n@Override\r\npublic boolean onCommand(@NotNull final CommandSender sender, @NotNull final Command command,\r\n                         @NotNull final String label, @NotNull final String[] args) {\r\n    if (sender instanceof final Player player) {\r\n        // If there are no command args, just set the active player chat channel to ally chat\r\n        if (args.length == 0) {\r\n            chatModule.setChatChannel(player, allyChatChannel);\r\n        } else {\r\n            // Concatenate all command args into one message\r\n            final StringBuilder messageBuilder = new StringBuilder(args[0]);\r\n            for (int i = 1; i < args.length; i++) {\r\n                messageBuilder.append(args[i]);\r\n            }\r\n            // Send the full message in ally chat without updating the player's active channel\r\n            chatModule.sendToChatChannel(allyChatChannel, player, Component.text(messageBuilder.toString()));\r\n        }\r\n    }\r\n    return true;\r\n}\n```\n\n### Silencing\n\nLet's imagine we are building a Hide and Seek game, and we don't want Hiders revealing each other's position to the Seekers. When a round starts, we can silence the global chat, so that Hiders and Seekers can't talk to one another.\n\n```java\nprotected void startRound() {\r\n    chatModule.setChatSilence(BuiltInChatChannel.GLOBAL, true);\r\n}\n```\n\nThen, when the round ends, we want to allow the two teams to communicate with each other again, so we unsilence the global chat.\n\n```java\nprotected void endRound() {\r\n    chatModule.setChatSilence(BuiltInChatChannel.GLOBAL, false);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/command",
    "title": "Command Module",
    "description": "How to use the Mineplex Studio Command Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.command.CommandModule\" />\n\nThe Command Module is one of the built-in Studio Modules that allows you to dynamically register and\r\nunregister commands from the Bukkit CommandMap.\n\n# Examples\n\n## Registering Command\n\nLet's say we want to register our new command!\n\n```java\npublic void register() {\r\n   Command command = new MyCommand();\r\n   commandModule.register(\"fallbackPrefix\", command);\r\n}\n```\n\n## Unregistering Command\n\nLets unregister our command!\n\n```java\npublic void cleanup(final Player player) {\r\n   // Pass the command instance we have created earlier.\r\n   commandModule.unregister(command);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/data",
    "title": "Data Storage Module",
    "description": "How to use the Mineplex Studio Data Storage Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.data.DataStorageModule\" />\n\nThe Data Storage Module is one of the built-in Studio Modules that allows you to dynamically store and load structured objects and binary data objects in your project. The built-in Data Storage Module is a simple way to get started with key-value storage, has no additional cost, and scales globally with the rest of the Studio platform. For advanced use cases, it is also possible to allocate dedicated databases at an additional cost via the Managed Databases system.\n\n## Data Objects\n\nEach data object, whether structured or binary, consists of two components: the key of the data, which is a `String` field in the class annotated withthe `@DataKey` annotation and should be **unique** within the `DataCollection` represented by the class, and the body of the data. The data body isdynamic, allowing you to create objects that are as simple or as complicated as you need. Any data object class needs to implement either the`StorableBinaryData` interface or the `StorableStructuredData` interface, and must be annotated with the `@DataCollection` annotation. This classannotation should include a `name` argument containing the **unique** name of the data collection within your project namespace for all objects of thattype to be stored within.\n\n## Structured Data\n\nStructured data objects should be comprised of individual fields and represent fixed-format data, such as player faction membership data or objectives completed. As previously mentioned, one `String` field of the class should be a unique key for that specific object, and must be annotated with the `@DataKey` annotation.\n\n## Binary Data\n\nBinary data objects are representations of more complex and non-standardized data, such as player worlds or world slices, or block changes on top of a template. There should be one specific `String` field serving as a unique key annotated with the `@DataKey` annotation. The remainder of the class is up to you, but the interface requires that the class can be serialized to/from a ByteArrayInputStream via overriding the `open()` and `load(ByteArrayInputStream)` methods, respectively.\n\n## CRUD\n\nThe CRUD methods provided in the Data Storage Module are as follows:\n\n* `store` - Store a data object in the remote storage system\n* `load` - Load a stored data object by key from the remote storage system\n* `exists` - Check whether a given key is associated with a data object in the remote storage system\n* `delete` - Deletes the data object associated with a given key in the remote storage system\n\nEach CRUD method has both a structured data and binary data version. Additionally, each of the CRUD methods has an asynchronous version, which should always be used when calling from the main thread. With the exception of the `store` method, all CRUD methods take the data class and the object key as parameters. The `store` method takes the data object itself as a parameter.\n\n# Examples\n\n## Creating a Structured Data Object\n\nLet's say we want to create a record object to reflect player access to a specific \"Island\" in our game.\n\n```java\n@Data\r\n@Builder\r\n@DataCollection(name = \"PlayerIslandAccess\")\r\npublic class PlayerIslandAccess implements StorableStructuredData {\r\n    // Player id should never be null\r\n    // This data is keyed by the player's id\r\n    @DataKey\r\n    @NonNull\r\n    String playerId;\r\n    // Island id should never be null\r\n    @NonNull\r\n    String islandId;\r\n}\n```\n\n## Creating a Binary Data Object\n\nNow, let's say we want to create a binary object that represents the chunk the \"Island\" is contained within, so that we can spawn it into our world.\n\n```java\n@Data\r\n@Builder\r\n@DataCollection(name = \"IslandChunk\")\r\npublic class IslandChunk implements StorableBinaryData {\r\n    // Island id should never be null\r\n    // This data is keyed by the island's id\r\n    @DataKey\r\n    @NonNull\r\n    String islandId;\r\n    // The island chunk should never be null\r\n    @NonNull\r\n    Chunk chunk;\r\n    private byte[] serializeChunkToBytes(final Chunk chunk) {\r\n        // Implement chunk serialization here\r\n    }\r\n    private Chunk createChunkFromBytes(final byte[] bytes) {\r\n        // Implement chunk deserialization here\r\n    }\r\n    @Override\r\n    public ByteArrayInputStream open() {\r\n        return new ByteArrayInputStream(serializeChunkToBytes(chunk));\r\n    }\r\n    @Override\r\n    public void load(final ByteArrayInputStream binary) {\r\n        chunk = createChunkFromBytes(binary.readAllBytes());\r\n    }\r\n}\n```\n\n## Using our Structured and Binary Data Objects\n\nNow that we have our structured and binary data objects, we can implement per-chunk persistence in our game.\n\n```java\npublic CompletableFuture<IslandChunk> loadIslandChunk(final Player player) {\r\n    final CompletableFuture<IslandChunk> islandChunkCompletableFuture = new CompletableFuture<>();\r\n    dataStorageModule.structuredDataExistsAsync(PlayerIslandAccess.class, player.getUniqueId().toString())\r\n            .thenAccept(exists -> {\r\n                if (exists) {\r\n                    // We know the object exists\r\n                    final PlayerIslandAccess islandAccess = dataStorageModule.loadStructuredData(\r\n                        PlayerIslandAccess.class, player.getUniqueId().toString())\r\n                            .orElseThrow();\r\n                    // If somehow the island is not there, remake it\r\n                    if (!dataStorageModule.binaryDataExists(\r\n                        IslandChunk.class, islandAccess.getIslandId())) {\r\n                        // Run chunk generation on the main thread\r\n                        Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n                            // Create a new island\r\n                            final IslandChunk islandChunk = generateNewIslandChunk();\r\n                            // Create access to the new island\r\n                            islandAccess.setIslandId(islandChunk.getIslandId());\r\n                            // Store the new island\r\n                            dataStorageModule.storeBinaryDataAsync(islandChunk).thenAccept(v -> {\r\n                                // Store the access to the created island\r\n                                dataStorageModule.storeStructuredData(islandAccess);\r\n                                // Return the new island\r\n                                islandChunkCompletableFuture.complete(islandChunk);\r\n                            });\r\n                        });\r\n                    } else {\r\n                        // We know the object exists\r\n                        final IslandChunk islandChunk = dataStorageModule.loadBinaryData(\r\n                            IslandChunk.class, islandAccess.getIslandId())\r\n                                .orElseThrow();\r\n                        islandChunkCompletableFuture.complete(islandChunk);\r\n                    }\r\n                } else {\r\n                    // Run chunk generation on the main thread\r\n                    Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n                        // Create a new island\r\n                        final IslandChunk islandChunk = generateNewIslandChunk();\r\n                        // Create access to the new island\r\n                        final PlayerIslandAccess islandAccess = PlayerIslandAccess.builder()\r\n                                .playerId(player.getUniqueId().toString())\r\n                                .islandId(islandChunk.getIslandId())\r\n                                .build();\r\n                        // Store the new island\r\n                        dataStorageModule.storeBinaryDataAsync(islandChunk).thenAccept(v -> {\r\n                            // Store the access to the created island\r\n                            dataStorageModule.storeStructuredData(islandAccess);\r\n                            // Return the new island\r\n                            islandChunkCompletableFuture.complete(islandChunk);\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n    return islandChunkCompletableFuture;\r\n}\r\npublic void deletePlayerIsland(final Player player) {\r\n    dataStorageModule.structuredDataExistsAsync(PlayerIslandAccess.class, player.getUniqueId().toString())\r\n            .thenAccept(exists -> {\r\n                if (exists) {\r\n                    // We know the object exists\r\n                    final PlayerIslandAccess islandAccess = dataStorageModule.loadStructuredData(\r\n                        PlayerIslandAccess.class, player.getUniqueId().toString())\r\n                            .orElseThrow();\r\n                    dataStorageModule.deleteBinaryData(IslandChunk.class, islandAccess.getIslandId());\r\n                    dataStorageModule.deleteStructuredData(PlayerIslandAccess.class,\r\n                        player.getUniqueId().toString());\r\n                }\r\n            });\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game",
    "title": "Game Engine Module",
    "description": "How to use the Mineplex Studio Game Engine Module.",
    "content": "The Game Engine Module is one of the built-in Studio Modules that allows you to create immersive and dynamic gameplay\r\nexperiences within Minecraft. Studio games are designed to be modular, allowing you to make amazing gameplay mechanics\r\nthat you can take with you from game to game, or even sell to other developers on our asset marketplace.\n\n## Game Cycle\n\nIf you want to create a project where multiple games play one after another, you should create your own\r\ncustom `GameCycle`. To do so, you need to create a class that implements the `GameCycle` interface. You'll need to\r\ndetermine how the `hasNextGame()` and `createNextGame()` methods should function. In some cases, you may want to cycle\r\nthrough a specific number of games, while in others you may want the cycle to go on forever. Either way, you can control\r\nit via your implementation of `hasNextGame()`. Your implementation of `createNextGame()` will determine what game is up\r\nnext, and will need to handle constructing the next game up. You can also have `getLobbyWorld()` return an\r\nactual `MineplexWorld` if you want the players to be teleported to a lobby world in between games. By default, there is\r\nno `GameCycle`, and a new game will not be created when the previous game ends.\n\n## Game State\n\nThe state of a `MineplexGame` indicates what phase in the game lifecycle it is currently in. The `GameState` of\r\na `MineplexGame` can be retrieved using the `getGameState()` method, and set using the `setGameState(GameState)` method.\n\nBuilt in options are:\n\n* `PREPARING` - When the `MineplexGame` is first being setup after construction\n* `PRE_START` - When the `MineplexGame` is preparing to start after all start conditions are met. This can be used for\r\n  things like countdowns or other starting behaviors. This is the default state in which the Matchmaker will flag your\r\n  game server as available for players\n* `STARTED` - When the `MineplexGame` has officially started\n* `ENDED` - When the `MineplexGame` is completed after the end condition is met. This can be used for things like win\r\n  rooms or other end game behavior\n\n## MineplexGame Interface\n\nThe `MineplexGame` interface is the primary interface for any game playable on the Studio. To make your own game, you'll\r\nneed to create a class for it that implements the `MineplexGame` interface. This class will define the core\r\nfunctionality and gameplay, and is where you will pull in all the `GameMechanic`s that you want to incorporate. To\r\nproperly implement the `MineplexGame` interface, you will need to provide implementations for several methods. You will\r\nneed to implement the `getName()` method, which should be the `String` name for your game. You also need to implement\r\nthe `getGameModule()` method. You'll need to supply some way for your game to return the `MineplexGameModule` within\r\nthis method, either by passing the module in the game's constructor, or another way of your choosing. Next, you'll need\r\nto implement the `getGameState()` and `setGameState(GameState)` methods. These can either actually modify your game's\r\nstate, or simply return `STARTED` for games that do not intend to support a full game lifecycle. Inside\r\nthe `setGameState` method, you should additionally fire the `MineplexGameStateChangeEvent` and propagate that new state\r\nto each of the `GameMechanic`s your game is using via the `GameMechanic` method `onStateChange(GameState, GameState)`\r\nprior to actually changing the `GameState` if you intend to do so. You will need to manage the conditions that trigger\r\ngame lifecycle changes yourself as well. Finally, you must implement the `setup()` and `teardown()` methods, to handle\r\nallocating and deallocating assets for the game. This is where you should create, configure, and destroy any of\r\nthe `GameMechanic`s you want to use.\n\nYou will need to handle registering and unregistering of your `MineplexGame` as a `Listener` yourself as well, based on\r\nyour own conditions.\n\nThere is a sub-interface, `SingleWorldMineplexGame`, that you may also choose to implement rather than just\r\nthe `MineplexGame` interface. This requires all the same implementations as a standard `MineplexGame`, with the\r\nadditional required method implementation of `getGameWorld()`, which should return the `MineplexWorld` serving as the\r\nsingle world that game will take place within.\n\n## Game Mechanics\n\n`GameMechanic`s are discrete elements of gameplay that create a full game when all operating together. These mechanics\r\ncan be tightly coupled to a specific `MineplexGame`, or left generic to support a wide variety of games. We provide\r\nseveral built-in `GameMechanic`s with the Studio SDK, but you can also make your own mechanics to customize your game\r\nprojects. You can even create unique `GameMechanic`s and sell them to other developers on our asset\r\nmarketplace! `GameMechanic`s should register and unregister themselves as `Listener`s in their setup and teardown\r\nmethods, which should be called manually when an owning `MineplexGame` initializes and cleans them up.\n\n### Game Mechanic Factory\n\nA `GameMechanicFactory` provides for the dynamic construction of instances of a specific `GameMechanic`.\r\nTo function, the factory needs to be registered in the `MineplexGameMechanicFactory`\r\nusing the `<M extends GameMechanic<?>> register(Class<M> gameMechanic, Supplier<M> mechanicSupplier)` method.\r\nOnce the factory has been registered, you can use the `MineplexGameMechanicFactory`\r\nto construct instances of the `GameMechanic` using the `construct(Class<M extends GameMechanic<?>>)` method.\r\nAll built-in `GameMechanic`s that we provide have their factories pre-registered in the `MineplexGameMechanicFactory`,\r\nso all you have to do is construct an instance when you want to use them.\r\nYou do not need to create a `GameMechanicFactory` for your own custom `GameMechanic`s, but you can if you'd like to.\r\nYou will need\r\nto implement your own `GameMechanicFactory` if you plan to sell source-unavailable `GameMechanic`s to other developers\r\non our asset marketplace.\n\n### Game World Selector Mechanic\n\nThe `GameWorldSelectorMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic will\r\nrandomly select a map from the game map templates included in your project, load the `MineplexWorld` from the template,\r\nand then provide it to the `MineplexGame` using the mechanic. Once the `MineplexGame` cleans itself up,\r\nthe `GameWorldSelectorMechanic` will unload the `MineplexWorld` and clean it up as well.\n\n### Custom Game Mechanics\n\nImplementing your own custom `GameMechanic`s is easy to do: just create a new class that implements the `GameMechanic`\r\ninterface, and determine if you want a mechanic that is coupled to a game, for example `BossMechanic<BossGame>`, or a\r\nmore generic mechanic, such as `SpectatorMechanic<MineplexGame>`. In your custom class, you will need to implement\r\nthe `setup(Game)`, `teardown()`, and `onStateChange(GameState, GameState)` methods to define the custom behavior of your\r\nmechanic for each of those cases.\n\n## Game Structure\n\nSince this is a game that takes place in one game world, let's base it on the `SingleWorldMineplexGame`.\n\n```java\npublic class HungerGames implements SingleWorldMineplexGame {\r\n    private final JavaPlugin myProjectPlugin;\r\n    private final MineplexGameModule gameModule;\r\n    private GameState gameState;\r\n    @Getter\r\n    private final List<LivingEntity> players = new ArrayList<>();\r\n\r\n    public HungerGames(final JavaPlugin myProjectPlugin, final MineplexGameModule gameModule) {\r\n        this.myProjectPlugin = myProjectPlugin;\r\n        this.gameModule = gameModule;\r\n        this.gameState = GameState.PREPARING;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Hunger Games\";\r\n    }\r\n\r\n    @Override\r\n    public MineplexGameModule getGameModule() {\r\n        return gameModule;\r\n    }\r\n\r\n    @Override\r\n    public GameState getGameState() {\r\n        return gameState;\r\n    }\r\n\r\n    @Override\r\n    public void setGameState(GameState gameState) {\r\n        Bukkit.getPluginManager().callEvent(new MineplexGameStateChangeEvent(this,\r\n                this.gameState, gameState));\r\n        this.gameState = gameState;\r\n\r\n        // When the game starts, teleport every player to a random spawn point\r\n        if (this.gameState == GameState.STARTED) {\r\n            final List<Location> spawns = getGameWorld().getDataPoints(\"SPAWN\");\r\n            players.forEach(player -> {\r\n                final Location spawn = spawns.get(ThreadLocalRandom.current().nextInt(spawns.size()));\r\n                player.teleport(spawn);\r\n            });\r\n        } else if (this.gameState == GameState.ENDED) {\r\n            setGameState(GameState.CLEANING_UP);\r\n        } else if (this.gameState == GameState.CLEANING_UP) {\r\n            teardown();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setup() {\r\n        Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        HandlerList.unregisterAll(this);\r\n        players.clear();\r\n        gameModule.setCurrentGame(null);\r\n    }\r\n\r\n    @Override\r\n    public MineplexWorld getGameWorld() {\r\n        return null;\r\n    }\r\n\r\n    @EventHandler\r\n    public void onDeath(final PlayerDeathEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the dead player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put dead players in spectator mode\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onJoin(final PlayerJoinEvent event) {\r\n        // Automatically add new players to the game\r\n        if (gameState == GameState.PRE_START) {\r\n            players.add(event.getPlayer());\r\n            // If 5 or more players are playing, start the game\r\n            if (players.size() >= 5) {\r\n                setGameState(GameState.STARTED);\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onQuit(final PlayerQuitEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the exiting player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put exiting players in spectator mode\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n```\n\nNext, let's enable and configure the mechanics we want!\n\n## Game Mechanics\n\nFor a very basic hunger games, we'll want\r\nthe `KitMechanic`, `AbilityMechanic`, `GameWorldSelectorMechanic`, `LootChestMechanic`, and `TeamMechanic` with\r\na `SingleTeamAssigner`. Let's take a look at how our `HungerGames` class changes to do this.\n\n```java\n public class HungerGames implements SingleWorldMineplexGame {\r\n    private final JavaPlugin myProjectPlugin;\r\n    private final MineplexGameModule gameModule;\r\n    private final MineplexGameMechanicFactory gameMechanicFactory;\r\n    private GameState gameState;\r\n\r\n    @Getter\r\n    private final List<LivingEntity> players = new ArrayList<>();\r\n\r\n    private AbilityMechanic abilityMechanic;\r\n    private KitMechanic kitMechanic;\r\n    private GameWorldSelectorMechanic gameWorldSelectorMechanic;\r\n    private LootChestMechanic lootChestMechanic;\r\n    private TeamMechanic teamMechanic;\r\n\r\n    public HungerGames(final JavaPlugin myProjectPlugin, final MineplexGameModule gameModule, final MineplexGameMechanicFactory gameMechanicFactory) {\r\n        this.myProjectPlugin = myProjectPlugin;\r\n        this.gameModule = gameModule;\r\n        this.gameMechanicFactory = gameMechanicFactory;\r\n        this.gameState = GameState.PREPARING;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Hunger Games\";\r\n    }\r\n\r\n    @Override\r\n    public MineplexGameModule getGameModule() {\r\n        return gameModule;\r\n    }\r\n\r\n    @Override\r\n    default MineplexGameMechanicFactory getGameMechanicFactory() {\r\n        return gameMechanicFactory;\r\n    }\r\n\r\n    @Override\r\n    public GameState getGameState() {\r\n        return gameState;\r\n    }\r\n\r\n    @Override\r\n    public void setGameState(GameState gameState) {\r\n        Bukkit.getPluginManager().callEvent(new MineplexGameStateChangeEvent(this,\r\n                this.gameState,\r\n                gameState));\r\n        abilityMechanic.onStateChange(this.gameState, gameState);\r\n        kitMechanic.onStateChange(this.gameState, gameState);\r\n        gameWorldSelectorMechanic.onStateChange(this.gameState, gameState);\r\n        lootChestMechanic.onStateChange(this.gameState, gameState);\r\n        teamMechanic.onStateChange(this.gameState, gameState);\r\n        this.gameState = gameState;\r\n\r\n        // When the game starts, teleport every player to a random spawn point, assign teams, and give them the kit\r\n        if (this.gameState == GameState.STARTED) {\r\n            final List<Location> spawns = getGameWorld().getDataPoints(\"SPAWN\");\r\n            players.forEach(player -> {\r\n                final Location spawn = spawns.get(ThreadLocalRandom.current().nextInt(spawns.size()));\r\n                player.teleport(spawn);\r\n\r\n                kitMechanic.grantKit(player, PlayerKit.class);\r\n            });\r\n            teamMechanic.assignTeams(players, teamMechanic.constructTeamAssigner(SingleTeamAssigner.class)\r\n                    .get());\r\n        } else if (this.gameState == GameState.ENDED) {\r\n            setGameState(GameState.CLEANING_UP);\r\n        } else if (this.gameState == GameState.CLEANING_UP) {\r\n            teardown();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setup() {\r\n        gameWorldSelectorMechanic = gameMechanicFactory.construct(GameWorldSelectorMechanic.class);\r\n        kitMechanic = gameMechanicFactory.construct(KitMechanic.class);\r\n        abilityMechanic = gameMechanicFactory.construct(AbilityMechanic.class);\r\n        lootChestMechanic = gameMechanicFactory.construct(LootChestMechanic.class);\r\n        teamMechanic = gameMechanicFactory.construct(TeamMechanic.class);\r\n\r\n        gameWorldSelectorMechanic.setup(this);\r\n        kitMechanic.setup(this);\r\n        abilityMechanic.setup(this);\r\n\r\n        // 60 seconds * 20 ticks per second\r\n        lootChestMechanic.setChestRefillDelay(60 * 20L);\r\n        lootChestMechanic.setChestDataPointKey(\"CHEST\");\r\n        // Loot pool, with a minimum of 3 items per chest and a max of 9\r\n        lootChestMechanic.setChestLootPool(List.of(\r\n                new ItemStack(Material.IRON_SWORD),\r\n                new ItemStack(Material.DIAMOND_CHESTPLATE),\r\n                new ItemStack(Material.WOODEN_SWORD),\r\n                new ItemStack(Material.GOLDEN_APPLE),\r\n                new ItemStack(Material.CHAINMAIL_HELMET),\r\n                new ItemStack(Material.BREAD, 5),\r\n                new ItemStack(Material.EGG, 16),\r\n                new ItemStack(Material.SNOWBALL, 10),\r\n                new ItemStack(Material.DIAMOND_AXE)), 3, 9);\r\n        lootChestMechanic.setup(this);\r\n\r\n        teamMechanic.setup(this);\r\n        teamMechanic.registerTeam(\"Players\", Component.text(\"Players\"));\r\n\r\n        // Register our kit\r\n        kitMechanic.registerKit(PlayerKit.class, new PlayerKit(kitMechanic, abilityMechanic, this));\r\n\r\n        Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        HandlerList.unregisterAll(this);\r\n\r\n        kitMechanic.teardown();\r\n        abilityMechanic.teardown();\r\n        teamMechanic.teardown();\r\n        lootChestMechanic.teardown();\r\n        gameWorldSelectorMechanic.teardown();\r\n\r\n        players.clear();\r\n        gameModule.setCurrentGame(null);\r\n    }\r\n\r\n    @Override\r\n    public MineplexWorld getGameWorld() {\r\n        return gameWorldSelectorMechanic.getSelectedGameWorld();\r\n    }\r\n\r\n    @EventHandler\r\n    public void onDeath(final PlayerDeathEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the dead player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put dead players in spectator mode and remove their kit\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onJoin(final PlayerJoinEvent event) {\r\n        // Automatically add new players to the game\r\n        if (gameState == GameState.PRE_START) {\r\n            players.add(event.getPlayer());\r\n\r\n            // If 5 or more players are playing, start the game\r\n            if (players.size() >= 5) {\r\n                setGameState(GameState.STARTED);\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onQuit(final PlayerQuitEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the exiting player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put exiting players in spectator mode and remove their kit\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n```\n\nLet's try making a custom `GameMechanic` that makes players glow for a moment when they get hit.\n\n```java\n\r\n@AllArgsConstructor\r\npublic class DamageGlowMechanic implements GameMechanic<HungerGames> {\r\n   private final HungerGames game;\r\n   private final JavaPlugin myProjectPlugin;\r\n\r\n   @Override\r\n   public void setup(final HungerGames game) {\r\n       Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n   }\r\n\r\n   @Override\r\n   public void teardown() {\r\n       HandlerList.unregisterAll(this);\r\n   }\r\n\r\n   @Override\r\n   public void onStateChange(final GameState fromState, final GameState toState) {\r\n       // Nothing needs to be cleaned up on state change\r\n   }\r\n\r\n   // On damage, make players glow\r\n   @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\r\n   public void onDamage(final EntityDamageEvent event) {\r\n       if (event.getEntity() instanceof Player player) {\r\n           // If the game is ongoing\r\n           if (game.getGameState() == GameState.STARTED) {\r\n               // If the player taking damage is in the game\r\n               if (game.getPlayers().contains(player)) {\r\n                   // Make them glow for a bit\r\n                   player.addPotionEffect(new PotionEffect(PotionEffectType.GLOWING,\r\n                           // 5 seconds * 20 ticks per second\r\n                           5 * 20,\r\n                           // No need for a higher level of glowing\r\n                           0,\r\n                           // Not an ambient effect\r\n                           false,\r\n                           // No need for particles\r\n                           false,\r\n                           // No need for the potion effect icon\r\n                           false));\r\n               }\r\n           }\r\n       }\r\n   }\r\n}\n```\n\nNow let's see what we have to do in our `HungerGames` class to use this mechanic.\n\n```java\npublic class HungerGames implements SingleWorldMineplexGame {\r\n   private final JavaPlugin myProjectPlugin;\r\n   private final MineplexGameModule gameModule;\r\n   private GameState gameState;\r\n\r\n   @Getter\r\n   private final List<LivingEntity> players = new ArrayList<>();\r\n\r\n   private AbilityMechanic abilityMechanic;\r\n   private KitMechanic kitMechanic;\r\n   private GameWorldSelectorMechanic gameWorldSelectorMechanic;\r\n   private LootChestMechanic lootChestMechanic;\r\n   private TeamMechanic teamMechanic;\r\n   private DamageGlowMechanic damageGlowMechanic;\r\n\r\n   public HungerGames(final JavaPlugin myProjectPlugin, final MineplexGameModule gameModule) {\r\n       this.myProjectPlugin = myProjectPlugin;\r\n       this.gameModule = gameModule;\r\n       this.gameState = GameState.PREPARING;\r\n   }\r\n\r\n   @Override\r\n   public String getName() {\r\n       return \"Hunger Games\";\r\n   }\r\n\r\n   @Override\r\n   public MineplexGameModule getGameModule() {\r\n       return gameModule;\r\n   }\r\n\r\n   @Override\r\n   public GameState getGameState() {\r\n       return gameState;\r\n   }\r\n\r\n   @Override\r\n   public void setGameState(GameState gameState) {\r\n       Bukkit.getPluginManager().callEvent(new MineplexGameStateChangeEvent(this,\r\n               this.gameState,\r\n               gameState));\r\n       abilityMechanic.onStateChange(this.gameState, gameState);\r\n       kitMechanic.onStateChange(this.gameState, gameState);\r\n       gameWorldSelectorMechanic.onStateChange(this.gameState, gameState);\r\n       lootChestMechanic.onStateChange(this.gameState, gameState);\r\n       teamMechanic.onStateChange(this.gameState, gameState);\r\n       damageGlowMechanic.onStateChange(this.gameState, gameState);\r\n       this.gameState = gameState;\r\n\r\n       // When the game starts, teleport every player to a random spawn point, assign teams, and give them the kit\r\n       if (this.gameState == GameState.STARTED) {\r\n           final List<Location> spawns = getGameWorld().getDataPoints(\"SPAWN\");\r\n           players.forEach(player -> {\r\n               final Location spawn = spawns.get(ThreadLocalRandom.current().nextInt(spawns.size()));\r\n               player.teleport(spawn);\r\n\r\n               kitMechanic.grantKit(player, PlayerKit.class);\r\n           });\r\n           teamMechanic.assignTeams(players, teamMechanic.constructTeamAssigner(SingleTeamAssigner.class)\r\n                   .get());\r\n       } else if (this.gameState == GameState.ENDED) {\r\n           setGameState(GameState.CLEANING_UP);\r\n       } else if (this.gameState == GameState.CLEANING_UP) {\r\n           teardown();\r\n       }\r\n   }\r\n\r\n   @Override\r\n   public void setup() {\r\n       gameWorldSelectorMechanic = gameMechanicFactory.construct(GameWorldSelectorMechanic.class);\r\n       kitMechanic = gameMechanicFactory.construct(KitMechanic.class);\r\n       abilityMechanic = gameMechanicFactory.construct(AbilityMechanic.class);\r\n       lootChestMechanic = gameMechanicFactory.construct(LootChestMechanic.class);\r\n       teamMechanic = gameMechanicFactory.construct(TeamMechanic.class);\r\n       damageGlowMechanic = new DamageGlowMechanic(this, myProjectPlugin);\r\n\r\n       gameWorldSelectorMechanic.setup(this);\r\n       kitMechanic.setup(this);\r\n       abilityMechanic.setup(this);\r\n\r\n       // 60 seconds * 20 ticks per second\r\n       lootChestMechanic.setChestRefillDelay(60 * 20L);\r\n       lootChestMechanic.setChestDataPointKey(\"CHEST\");\r\n       // Loot pool, with a minimum of 3 items per chest and a max of 9\r\n       lootChestMechanic.setChestLootPool(List.of(\r\n               new ItemStack(Material.IRON_SWORD),\r\n               new ItemStack(Material.DIAMOND_CHESTPLATE),\r\n               new ItemStack(Material.WOODEN_SWORD),\r\n               new ItemStack(Material.GOLDEN_APPLE),\r\n               new ItemStack(Material.CHAINMAIL_HELMET),\r\n               new ItemStack(Material.BREAD, 5),\r\n               new ItemStack(Material.EGG, 16),\r\n               new ItemStack(Material.SNOWBALL, 10),\r\n               new ItemStack(Material.DIAMOND_AXE)), 3, 9);\r\n       lootChestMechanic.setup(this);\r\n\r\n       teamMechanic.setup(this);\r\n       teamMechanic.registerTeam(\"Players\", Component.text(\"Players\"));\r\n\r\n       // Register our kit\r\n       kitMechanic.registerKit(PlayerKit.class, new PlayerKit(kitMechanic, abilityMechanic, this));\r\n\r\n       damageGlowMechanic.setup(this);\r\n\r\n       Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n   }\r\n\r\n   @Override\r\n   public void teardown() {\r\n       HandlerList.unregisterAll(this);\r\n\r\n       damageGlowMechanic.teardown();\r\n       kitMechanic.teardown();\r\n       abilityMechanic.teardown();\r\n       teamMechanic.teardown();\r\n       lootChestMechanic.teardown();\r\n       gameWorldSelectorMechanic.teardown();\r\n\r\n       players.clear();\r\n       gameModule.setCurrentGame(null);\r\n   }\r\n\r\n   @Override\r\n   public MineplexWorld getGameWorld() {\r\n       return gameWorldSelectorMechanic.getSelectedGameWorld();\r\n   }\r\n\r\n   @EventHandler\r\n   public void onDeath(final PlayerDeathEvent event) {\r\n       // If the game is currently ongoing\r\n       if (gameState == GameState.STARTED) {\r\n           // If the dead player was playing this game\r\n           if (players.remove(event.getPlayer())) {\r\n               // Put dead players in spectator mode and remove their kit\r\n               event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n               kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n               // If there is one player or less, end the game\r\n               if (players.size() <= 1) {\r\n                   setGameState(GameState.ENDED);\r\n               }\r\n           }\r\n       }\r\n   }\r\n\r\n   @EventHandler\r\n   public void onJoin(final PlayerJoinEvent event) {\r\n       // Automatically add new players to the game\r\n       if (gameState == GameState.PRE_START) {\r\n           players.add(event.getPlayer());\r\n\r\n           // If 5 or more players are playing, start the game\r\n           if (players.size() >= 5) {\r\n               setGameState(GameState.STARTED);\r\n           }\r\n       }\r\n   }\r\n\r\n   @EventHandler\r\n   public void onQuit(final PlayerQuitEvent event) {\r\n       // If the game is currently ongoing\r\n       if (gameState == GameState.STARTED) {\r\n           // If the exiting player was playing this game\r\n           if (players.remove(event.getPlayer())) {\r\n               // Put exiting players in spectator mode and remove their kit\r\n               event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n               kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n               // If there is one player or less, end the game\r\n               if (players.size() <= 1) {\r\n                   setGameState(GameState.ENDED);\r\n               }\r\n           }\r\n       }\r\n   }\r\n}\n```\n\nFinally, let's look at how our game gets started!\n\n## Project Plugin Class\n\n```java\npublic class MyProject extends JavaPlugin {\r\n   private HungerGames game;\r\n\r\n   @Override\r\n   public void onEnable() {\r\n       final MineplexGameModule gameModule = MineplexModuleManager.getRegisteredModule(\r\n               MineplexGameModule.class);\r\n       game = new HungerGames(this, gameModule);\r\n       gameModule.setCurrentGame(game);\r\n       game.setGameState(GameState.PRE_START);\r\n   }\r\n\r\n   @Override\r\n   public void onDisable() {\r\n       game.teardown();\r\n   }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics/ability",
    "title": "Ability Game Mechanic",
    "description": "How to use the Ability Game Mechanic.",
    "content": "### Mechanic\n\nThe `AbilityMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic allows you to\r\ncreate `Ability`s and grant/remove them to/from `LivingEntity`s. `Ability`s can be tightly coupled to a\r\nspecific `MineplexGame`, or left generic to support a wide variety of games.\n\n#### Interface\n\nThe base `Ability` interface defines a few methods that must be implemented by any specific `Ability`. These include\r\nmethods like getting the name of the `Ability`, setup and teardown methods for the `Ability` instance, and start and\r\nstop methods for when the `Ability` is granted to/removed from a specific `LivingEntity`.\r\nIn addition to the base `Ability` interface, there are two specific types of `Ability`: `PassiveAbility`, an interface\r\nthat defines an `Ability` which is constantly running as long as a `LivingEntity` possesses it, which may grant\r\nthe `LivingEntity` passive bonuses like fall damage reduction or regeneration, and `ActiveAbility`, which performs some\r\nspecific action when triggered. The specific `Ability` is required to implement the passive granted by\r\nthe `PassiveAbility`, as well as listening for the trigger of an `ActiveAbility` and implementing the activation and\r\ndeactivation behavior. All registered `Ability`s function as `Listener`s, and do not have to be explicitly\r\nregistered/unregistered with Bukkit by you.\n\n#### Factory\n\nAn `AbilityFactory` provides for the dynamic construction of instances of a specific `Ability`. To function, the factory\r\nneeds to be registered in the `AbilityMechanic` using\r\nthe `registerAbilityFactory(Class<A extends Ability<G extends MineplexGame>>, AbilityFactory<G, A>)` method. Once the\r\nfactory has been registered, you can use the `AbilityMechanic` to construct instances of the `Ability` using\r\nthe `constructAbility(Class<A extends Ability<G extends MineplexGame>>, G)` method. All built-in `Ability`s that we\r\nprovide have their factories pre-registered in the `AbilityMechanic`, so all you have to do is construct an instance\r\nwhen you want to use them. You do not need to create an `AbilityFactory` for your own custom `Ability`s, but you can if\r\nyou'd like to. You will need to implement your own `AbilityFactory` if you plan to sell source-unavailable `Ability`s to\r\nother developers on our asset marketplace.\n\n# Examples\n\n## Passive Ability\n\nLet's make a custom passive ability that makes players take no fall damage.\n\n```java\n// Since this ability doesn't need to do anything specific to Hunger Games, we can make it generic,\r\n// so we can reuse it!\r\n@AllArgsConstructor\r\npublic class WeightlessAbility implements PassiveAbility<MineplexGame> {\r\n    private final AbilityMechanic abilityMechanic;\r\n    private final MineplexGame game;\r\n\r\n    @Override\r\n    public AbilityMechanic getAbilityMechanic() {\r\n        return abilityMechanic;\r\n    }\r\n\r\n    @Override\r\n    public MineplexGame getGame() {\r\n        return game;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Weightless\";\r\n    }\r\n\r\n    @Override\r\n    public void setup(final MineplexGame game) {\r\n        // This ability doesn't need to allocate any additional resources\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        // This ability has no additionally allocated resources to clean up\r\n    }\r\n\r\n    @Override\r\n    public void start(final LivingEntity livingEntity) {\r\n        // This ability doesn't do anything to the host when it starts\r\n    }\r\n\r\n    @Override\r\n    public void stop(final LivingEntity livingEntity) {\r\n        // This ability doesn't do anything to the host that needs to be removed\r\n    }\r\n\r\n    @Override\r\n    public void tick(LivingEntity livingEntity) {\r\n        // This ability doesn't do anything on every tick\r\n    }\r\n\r\n    // Stop fall damage\r\n    @EventHandler\r\n    public void onFallDamage(final EntityDamageEvent event) {\r\n        // If the entity taking damage has this ability\r\n        if (event.getEntity() instanceof LivingEntity livingEntity && hasAbility(livingEntity)) {\r\n            // Only cancel fall damage\r\n            if (event.getCause() == EntityDamageEvent.DamageCause.FALL) {\r\n                event.setCancelled(true);\r\n            }\r\n        }\r\n    }\r\n}\n```\n\n```java\n// Since this ability doesn't need to do anything specific to Hunger Games, we can make it generic,\r\n// so we can reuse it!\r\n@AllArgsConstructor\r\npublic class SneakyAbility implements ActiveAbility<MineplexGame> {\r\n    private final AbilityMechanic abilityMechanic;\r\n    private final MineplexGame game;\r\n\r\n    @Override\r\n    public AbilityMechanic getAbilityMechanic() {\r\n        return abilityMechanic;\r\n    }\r\n\r\n    @Override\r\n    public MineplexGame getGame() {\r\n        return game;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Sneaky\";\r\n    }\r\n\r\n    @Override\r\n    public void setup(final MineplexGame game) {\r\n        // This ability doesn't need to allocate any additional resources\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        // This ability has no additionally allocated resources to clean up\r\n    }\r\n\r\n    @Override\r\n    public void start(final LivingEntity livingEntity) {\r\n        // This ability doesn't do anything to the host when it starts\r\n    }\r\n\r\n    @Override\r\n    public void stop(final LivingEntity livingEntity) {\r\n        livingEntity.removePotionEffect(PotionEffectType.INVISIBILITY);\r\n    }\r\n\r\n    @Override\r\n    public void activate(final LivingEntity livingEntity) {\r\n        // Grant 10 seconds of invisibility\r\n        livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.INVISIBILITY,\r\n                // 10 seconds * 20 ticks per second\r\n                10 * 20,\r\n                // Invisibility level 1, no need for an amplifier\r\n                0,\r\n                // This is not an ambient effect\r\n                false,\r\n                // We don't want to give away the player with potion particles\r\n                false,\r\n                // We do want the potion effect icon to show up on the player's screen\r\n                true));\r\n    }\r\n\r\n    @Override\r\n    public void deactivate(final LivingEntity livingEntity) {\r\n        livingEntity.removePotionEffect(PotionEffectType.INVISIBILITY);\r\n    }\r\n\r\n    // Listen for crouching\r\n    @EventHandler\r\n    public void onCrouch(final PlayerToggleSneakEvent event) {\r\n        // If the player has this ability\r\n        if (hasAbility(event.getPlayer()) && event.isSneaking()) {\r\n            // If they are crouching, activate, otherwise, deactivate\r\n            if (event.isSneaking()) {\r\n                activate(event.getPlayer());\r\n            } else {\r\n                deactivate(event.getPlayer());\r\n            }\r\n        }\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics",
    "title": "Built-In Game Mechanics",
    "description": "How to use the built-in Mineplex Studio Game MEchanics.",
    "content": "The Studio SDK comes with extensive built-in Game Mechanics that provide foundational functionality for all Studio\r\nprojects. These built-in Game Mechanics are automatically registered, and can be accessed via\r\nthe `MineplexGameMechanicFactory` method `construct(Class<T extends GameMechanic<? extends MineplexGame>)`\n\n## Pricing\n\nBuilt-in mechanics are provided free-of-charge!\n\n# Example\n\nLet's say we want to use the `Ability` mechanic in our project. As a very first step, we need to get\r\na new instance of it.\n\n```java\npublic class ExampleGame implements MineplexGame {\r\n    private final MineplexGameMechanicFactory gameMechanicFactory =\r\n            MineplexModuleManager.getRegisteredModule(MineplexGameMechanicFactory.class);\r\n\r\n    private AbilityMechanic abilityMechanic;\r\n    \r\n    @Override\r\n    public void setup() {\r\n        this.abilityMechanic = this.gameMechanicFactory.construct(AbilityMechanic.class);\r\n        this.abilityMechanic.setup(this);\r\n        \r\n        // TODO: Register your own abilities here\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        this.abilityMechanic.teardown();\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics/kit",
    "title": "Kit Game Mechanic",
    "description": "How to use the Kit Game Mechanic.",
    "content": "### Mechanic\n\nThe `KitMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic allows you to\r\ncreate `Kit`s and grant/remove them to/from `LivingEntity`s. `Kit`s can be tightly coupled to a specific `MineplexGame`,\r\nor left generic to support a wide variety of games.\n\n#### Interface\n\nThe `Kit` interface defines a few methods that must be implemented by any specific `Kit`. These include methods like\r\ngetting the name of the `Kit`, setup and teardown methods for the `Kit` instance, and a `giveKit(LivingEntity)` method\r\ncalled whenever your game wishes to give the kit to a specific `LivingEntity` that has the kit (such as on game start,\r\nor respawns). The interface also has a `removeKit(LivingEntity)` method called when the kit is removed from\r\na `LivingEntity`. All registered `Kit`s function as `Listener`s, and do not have to be explicitly\r\nregistered/unregistered with Bukkit by you.\n\n#### Factory\n\nA `KitFactory` provides for the dynamic construction of instances of a specific `Kit`. To function, the factory needs to\r\nbe registered in the `KitMechanic` using\r\nthe `registerKitFactory(Class<K extends Kit<G extends MineplexGame>>, KitFactory<G, K>)` method. Once the factory has\r\nbeen registered, you can use the `KitMechanic` to construct instances of the `Kit` using\r\nthe `constructKit(Class<K extends Kit<G extends MineplexGame>>, G)` method. All built-in `Kit`s that we provide have\r\ntheir factories pre-registered in the `KitMechanic`, so all you have to do is construct an instance when you want to use\r\nthem. You do not need to create a `KitFactory` for your own custom `Kit`s, but you can if you'd like to. You will need\r\nto implement your own `KitFactory` if you plan to sell source-unavailable `Kit`s to other developers on our asset\r\nmarketplace.\n\n# Examples\n\n## Player Kit\n\nLet's give each player some leather armor and a stone sword when they start, as well as our two abilities.\n\n```java\n// Since this kit doesn't need to do anything specific to Hunger Games,\r\n// we can make it generic, so we can reuse it!\r\npublic class PlayerKit implements Kit<MineplexGame> {\r\n    // We want to give our two abilities to anyone with this kit\r\n    private final WeightlessAbility weightlessAbility;\r\n    private final SneakyAbility sneakyAbility;\r\n    private final AbilityMechanic abilityMechanic;\r\n    private final KitMechanic kitMechanic;\r\n    private final MineplexGame game;\r\n\r\n    public PlayerKit(final KitMechanic kitMechanic,\r\n                     final AbilityMechanic abilityMechanic,\r\n                     final MineplexGame game) {\r\n        weightlessAbility = new WeightlessAbility(abilityMechanic, game);\r\n        sneakyAbility = new SneakyAbility(abilityMechanic, game);\r\n        this.abilityMechanic = abilityMechanic;\r\n        this.kitMechanic = kitMechanic;\r\n        this.game = game;\r\n    }\r\n\r\n    @Override\r\n    public KitMechanic getKitMechanic() {\r\n        return kitMechanic;\r\n    }\r\n\r\n    @Override\r\n    public MineplexGame getGame() {\r\n        return game;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Player\";\r\n    }\r\n\r\n    @Override\r\n    public void setup(final MineplexGame game) {\r\n        abilityMechanic.registerAbility(WeightlessAbility.class, weightlessAbility);\r\n        abilityMechanic.registerAbility(SneakyAbility.class, sneakyAbility);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        abilityMechanic.destroyAbility(WeightlessAbility.class);\r\n        abilityMechanic.destroyAbility(SneakyAbility.class);\r\n    }\r\n\r\n    @Override\r\n    public void giveKit(final LivingEntity livingEntity) {\r\n        if (!abilityMechanic.hasAbility(livingEntity, WeightlessAbility.class)) {\r\n            abilityMechanic.grantAbility(livingEntity, WeightlessAbility.class);\r\n        }\r\n\r\n        if (!abilityMechanic.hasAbility(livingEntity, SneakyAbility.class)) {\r\n            abilityMechanic.grantAbility(livingEntity, SneakyAbility.class);\r\n        }\r\n\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        equipment.setHelmet(new ItemStack(Material.LEATHER_HELMET));\r\n        equipment.setChestplate(new ItemStack(Material.LEATHER_CHESTPLATE));\r\n        equipment.setLeggings(new ItemStack(Material.LEATHER_LEGGINGS));\r\n        equipment.setBoots(new ItemStack(Material.LEATHER_BOOTS));\r\n        equipment.setItemInMainHand(new ItemStack(Material.STONE_SWORD));\r\n    }\r\n\r\n    @Override\r\n    public void removeKit(final LivingEntity livingEntity) {\r\n        if (abilityMechanic.hasAbility(livingEntity, WeightlessAbility.class)) {\r\n            abilityMechanic.removeAbility(livingEntity, WeightlessAbility.class);\r\n        }\r\n\r\n        if (abilityMechanic.hasAbility(livingEntity, SneakyAbility.class)) {\r\n            abilityMechanic.removeAbility(livingEntity, SneakyAbility.class);\r\n        }\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics/team",
    "title": "Team Game Mechanic",
    "description": "",
    "content": "### Team Mechanic\n\nThe `TeamMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic allows you to\r\ncreate `GameTeam`s, assign them names, and have `LivingEntity`s join the created teams. Additionally, `TeamAssigner`s\r\nallow for the assignment of groups to available teams based on predefined behavior using\r\nthe `assignTeams(Collection<LivingEntity>, TeamAssigner)` method.\n\n#### Team Assigner Factory\n\nA `TeamAssignerFactory` provides for the dynamic construction of instances of a specific `TeamAssigner`. To function,\r\nthe factory needs to be registered in the `TeamMechanic` using\r\nthe `registerTeamAssignerFactory(Class<T extends TeamAssigner>, TeamAssignerFactory<T>)` method. Once the factory has\r\nbeen registered, you can use the `TeamMechanic` to construct instances of the `TeamAssigner` using\r\nthe `constructTeamAssigner(Class<T extends TeamAssigner>)` method. All built-in `TeamAssigner`s that we provide have\r\ntheir factories pre-registered in the `TeamMechanic`, so all you have to do is construct an instance when you want to\r\nuse them. You do not need to create a `TeamAssignerFactory` for your own custom `TeamAssigner`s, but you can if you'd\r\nlike to. You will need to implement your own `TeamAssignerFactory` if you plan to sell source-unavailable `TeamAssigner`\r\ns to other developers on our asset marketplace. We currently provide two built-in `TeamAssigner`s:\n\n* `SingleTeamAssigner` - groups all `LivingEntity`s into the single team in the `TeamMechanic`\n* `EvenTeamsAssigner` - assigns all `LivingEntity`s to teams in the most even way possible. Can be configured\r\n  with `setShouldGroupParties(boolean)` to attempt to put parties on the same team if they fit\n"
  },
  {
    "slug": "/sdk/features",
    "title": "Built-In Modules",
    "description": "How to use the built-in Mineplex Studio Modules.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.MineplexModule\" />\n\nThe Studio SDK comes with extensive built-in Modules that provide foundational functionality for all Studio projects. These built-in Modules are automatically registered and enabled on startup, and can be accessed via the `MineplexModuleManager` method `getRegisteredModule(Class<T extends MineplexModule>)`. You should **never** manually destroy or disable these Modules.\n\n## Pricing (usually free!)\n\nBuilt-in modules are provided free-of-charge, with some restrictions, for developers that use a profit-sharing payout model (this probably applies to you!).\n\nWe also offer a metered pricing tier to select game publishers, with minimum revenue and support model requirements. Built-in Modules are generally significantly cheaper than hosting other services or using equivalent functionalities provided outside the Studio.\n\n# Example\n\nLet's say we want to create a new `MineplexWorld` in our project. As a very first step, we need to get the `MineplexWorldModule`.\n\n```java\npublic void createWorlds() {\r\n    final MineplexWorldModule worldModule = MineplexModuleManager.getRegisteredModule(MineplexWorldModule.class);\r\n\r\n    // Now create worlds...\r\n}\n```\n\nNow that we have the module, we can proceed with world creation.\n"
  },
  {
    "slug": "/sdk/features/leaderboard",
    "title": "Leaderboard Module",
    "description": "How to use the Mineplex Studio Leaderboard Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.leaderboard.LeaderboardModule\" />\n\nThe Leaderboard Module is one of the built-in Studio Modules that allows you to create dynamic leaderboards based on whatever metric you want. Leaderboards can rank players, teams, or any other entity of your choosing, and are updated in real time. As soon as a leaderboard is changed, it is retrievable with the freshest data.\n\n## Leaderboard Retrieval\n\nYou can choose to retrieve a leaderboard by the top N players using the `getLeaderboard(String, int)` method, or query for the exact leaderboard position of a specific player/team/entity/etc using the `getLeaderboardEntry(String, String)` method.\n\n## Leaderboard Updates\n\nYou can also wipe a specific entry off a leaderboard using the `clearLeaderboardScore(String, String)` method, or clear the whole board at once with the `clearLeaderboard(String)` method. Leaderboards can be updated by either directly setting an entry score with the `updateLeaderboardScore(String, String, double)` method, or by incrementing by a specified amount using the `incrementLeaderboardScore(String, String, double)` method.\n\n## Alternative Methods\n\nAll leaderboard methods can be run synchronously or asynchronously to ensure you avoid blocking the main thread. Additionally, all the leaderboard update and entry query methods will directly accept a Player instead of an entry ID.\n\n# Examples\n\n## Getting the Top 10 Kills Leaderboard\n\nLet's say our game tracks player kills on a leaderboard. We can retrieve the top 10 players on this leaderboard at any time.\n\n```java\npublic CompletableFuture<List<LeaderboardEntry>> getTopKills() {\r\n    return leaderboardModule.getLeaderboardAsync(\"Kills\", 10);\r\n}\n```\n\n## Incrementing the Kills Leaderboard\n\nEvery time a player gets a kill, we want to update the leaderboard with their new score.\n\n```java\npublic void onKill(final Player killer, final Player victim) {\r\n    leaderboardModule.incrementLeaderboardScore(\"Kills\", killer, 1);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/messaging",
    "title": "Messaging Module",
    "description": "How to use the Mineplex Studio Messaging Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.messaging.MessagingdModule\" />\n\nThe Messaging Module enables communication between containers in the same namespace by sending and receiving messages. Messages can be targeted to specific containers based on various criteria.\n\n## Key Concepts\n\n* **Namespace-Specific Messaging**: Messages can only be sent to and received from containers within the same namespace.\n* **Event-Driven Architecture**: Messages trigger events, enabling responsive and asynchronous communication.\n* **Targeted Delivery:** Messages can be directed to specific containers, projects, or namespaces.\n\n## Use Cases\n\n* **Inter-Container Communication:** Facilitate communication between different containers within the same namespace for coordinated actions.\n* **Event Handling:** Use event-driven architecture to respond to specific messages with appropriate handlers.\n* **Targeted Messaging:** Send messages to specific containers based on predefined criteria for targeted communication.\n\n## Primary Functionalities\n\n### Registering a Listener\n\nYou can register a listener to receive messages associated with a specific key. When a message with the registered key is received, an AsyncMineplexMessageReceivedEvent is triggered.\n\n```java\nvoid registerKey(@NonNull String key);\n```\n\n#### Parameters:\n\n* key: The key for the messages you want to listen for.\n\n### Sending a Message to a Single Target\n\nSend a message to a specific target with a designated key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessage(\r\n    @NonNull String key, \r\n    @NonNull Object message, \r\n    @NonNull MineplexMessageTarget target\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* message: The message content.\n* target: The target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n### Sending a Message to Multiple Targets\n\nSend a message to multiple specified targets with a designated key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessage(\r\n    @NonNull String key, \r\n    @NonNull Object message, \r\n    @NonNull Collection<@NonNull MineplexMessageTarget> targets\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* message: The message content.\n* targets: Collection of target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n### Sending Multiple Messages to a Single Target\n\nSend multiple messages to a single target with the same key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessages(\r\n    @NonNull String key, \r\n    @NonNull Collection<@NonNull Object> messages, \r\n    @NonNull MineplexMessageTarget target\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* messages: Collection of messages to be sent.\n* target: The target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n## MineplexMessageTarget\n\n### Matching Namespace\n\nCreate a message target by targeting any container in a given namespace.\n\n```java\npublic static MineplexMessageTarget matchingNamespace(@NonNull final String namespaceIdentifier);\n```\n\n### Matching Project\n\nCreate a message target by targeting any container in a given project.\n\n```java\npublic static MineplexMessageTarget matchingProject(@NonNull final String projectIdentifier);\n```\n\n### Matching Pod\n\nCreate a message target by targeting a specific container.\n\n```java\npublic static MineplexMessageTarget matchingPod(@NonNull final String podIdentifier);\n```\n\n## Example\n\nTo assist in using this module, here is an example which sends and receives messages.\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport com.mineplex.studio.sdk.modules.messaging.MessagingModule;\r\nimport com.mineplex.studio.sdk.modules.MineplexModuleManager;\r\nimport com.mineplex.studio.sdk.modules.messaging.target.MineplexMessageTarget;\r\nimport org.bukkit.plugin.java.JavaPlugin;\r\n\r\npublic class MyGame extends JavaPlugin {\r\n\r\n    private MessagingModule messagingModule;\r\n\r\n    @Override\r\n    public void onEnable() {\r\n        // Initialize the messaging module\r\n        this.messagingModule = MineplexModuleManager.getRegisteredModule(MessagingModule.class);\r\n\r\n        // setup the messaging module\r\n        this.messagingModule.setup();\r\n\r\n        // Register a listener for incoming messages\r\n        // This is only required if you'd like to also listen to the incoming message on this key\r\n        messagingModule.registerKey(\"exampleKey\");\r\n\r\n        // Send a test message\r\n        sendMessage();\r\n    }\r\n\r\n    private void sendMessage() {\r\n        final String key = \"exampleKey\";\r\n        final String message = \"Hello from MessagingPlugin!\";\r\n\r\n        // namespace ID can be found in your configuration file\r\n        final MineplexMessageTarget target = MineplexMessageTarget.matchingNamespace(\"exampleNamespace\");\r\n\r\n        messagingModule\r\n          .sendMessage(key, message, target)\r\n          .thenAccept(voidResult -> {\r\n                getLogger().info(\"Message sent successfully.\");\r\n            }).exceptionally(ex -> {\r\n                getLogger().severe(\"Failed to send message: \" + ex.getMessage());\r\n                return null;\r\n            }\r\n        );\r\n    }\r\n}\n```\n\nAnd then to listen to the messaging that will come in:\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport com.mineplex.studio.sdk.modules.messaging.event.AsyncMineplexMessageReceivedEvent;\r\nimport org.bukkit.event.EventHandler;\r\nimport org.bukkit.event.Listener;\r\nimport org.bukkit.plugin.java.JavaPlugin;\r\n\r\npublic class MessageListener implements Listener {\r\n\r\n    private final JavaPlugin plugin;\r\n\r\n    public MessageListener(final JavaPlugin plugin) {\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    @EventHandler\r\n    public void onMessageReceived(final AsyncMineplexMessageReceivedEvent event) {\r\n        if (\"exampleKey\".equals(event.getKey())) {\r\n            final String message = (String) event.getMessage();\r\n            plugin.getLogger().info(\"Received message: \" + message);\r\n        }\r\n    }\r\n}\n```\n\nAnd don't forget to register the listener in your main class!\n\n```java\ngetServer().getPluginManager().registerEvents(new MessageListener(this), this);\n```\n"
  },
  {
    "slug": "/sdk/features/moderation/command",
    "title": "Default Punishment Command",
    "description": "How to use the default punishment command",
    "content": "<Note title=\"This can be disabled\" type=\"note\">\n  If you'd like to make your own command, use the Moderation Module's `disableDefaultPunishmentCommand()` method.\n</Note>\n\n## Permissions\n\n### General Permissions\n\n* **`mineplex.moderation.*`**\\\n  Grants access to all moderation features.\n\n### Command\n\n* **`mineplex.moderation.command.punish`**\\\n  Grants access to the punishment command.\n\n#### View Punishments\n\n* **`mineplex.moderation.command.punish.view`**\\\n  Grants permission to view all punishments.\n* **`mineplex.moderation.command.punish.view.history`**\\\n  Grants permission to view punishment histories.\n\n#### View Details\n\n* **`mineplex.moderation.command.punish.view.details.*`**\\\n  Grants permission to view all punishment details.\n* **`mineplex.moderation.command.punish.view.details.notes`**\\\n  Allows viewing punishment notes.\n* **`mineplex.moderation.command.punish.view.details.issuer`**\\\n  Allows viewing who added the punishment.\n  * **`mineplex.moderation.command.punish.view.details.issuer.self`**\\\n    Allows viewing punishments added by themselves.\n  * **`mineplex.moderation.command.punish.view.details.issuer.other`**\\\n    Allows viewing punishments added by others.\n* **`mineplex.moderation.command.punish.view.details.remover.*`**\\\n  Grants permission to view who removed punishments.\n  * **`mineplex.moderation.command.punish.view.details.remover.self`**\\\n    Allows viewing punishments removed by themselves.\n  * **`mineplex.moderation.command.punish.view.details.remover.other`**\\\n    Allows viewing punishments removed by others.\n\n#### Remove Punishments\n\n* **`mineplex.moderation.command.punish.remove.*`**\\\n  Grants permission to remove all punishments.\n* **`mineplex.moderation.command.punish.remove.self`**\\\n  Allows removal of punishments applied by themselves.\n* **`mineplex.moderation.command.punish.remove.other`**\\\n  Allows removal of punishments applied by other moderators.\n\n#### Create Punishments\n\n* **`mineplex.moderation.command.create`**\\\n  Grants access to create punishments.\n* **`mineplex.moderation.command.create.reason.*`**\\\n  Allows creating punishments for all reasons.\n* **`mineplex.moderation.command.create.reason.[reason_identifier]`**\\\n  Allows creating punishments for specific reasons (`[reason_identifier]`).\n"
  },
  {
    "slug": "/sdk/features/moderation",
    "title": "Moderation Module",
    "description": "How to use the Mineplex Studio Moderation Module to enforce rules on your projects.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.moderation.ModerationModule\" />\n\nThe Moderation Module is one of the built-in Studio Modules that allows you to manage and enforce player behavior within your projects. With this module, you can punish specific players through various means such as bans, mutes, or other restrictions. These punishments can be managed by your project's moderation team and tailored to fit the needs of your community.\n\n<Note title=\"Important Note\" type=\"danger\">\n  If you'd like to make your own punishment system, all punishments must go through this Module, this helps us track punishments, handle appeals and ensure accountability. Please do not create your own Punishment table / Punishment database, this will result in your project being rejected. You can create your own user interface / systems.\n</Note>\n\n## How everything connects\n\nThe Moderation Module integrates seamlessly with your project, ensuring a consistent approach to managing player behavior. By utilizing the provided methods, you can automate and customize moderation tasks to create a fair and enjoyable experience for all users.\n\nThe `Punishment` Object:\r\nThe Punishment object is central to the Moderation Module and contains the following fields:\n\n* **Identifier:** Unique ID for the punishment.\n* **Player Identifier:** UUID of the punished player.\n* **Moderator Identifier:** UUID of the moderator who applied the punishment.\n* **Start Timestamp:** When the punishment started.\n* **Applicable Projects:** Set of projects where the punishment applies.\n* **[Reason](#reasons):** Pre-defined reason for the punishment.\n* **Notes:** Additional information about the punishment.\n* **Removal Information:** Details about the removal of the punishment, if applicable.\n\nFor a full breakdown of the punishment object, see [the punishment object documentation](/docs/sdk/features/moderation/model)\n\n### Reasons\n\nInstead of allowing arbitrary text, the module uses a pre-defined list of reasons for consistency and clarity.\n\nThe `PunishmentReason` object includes:\n\n* **Punishment type:** Specifies the type of punishment (e.g., mute, ban).\n* **Display reason:** User-friendly explanation of the reason.\n* **Priority:** Importance level of the reason (important if they have multiple at once).\n* **Identifier:** Unique ID for the reason.\n* **Duration:** Length of time the punishment lasts.\n\nFor a full breakdown of the reasons and some defaults we've added for you, check out [the punishment reason documentation](/docs/sdk/features/moderation/reasons)\n\n## Method overview\n\nBelow is an overview of the key methods available in the Moderation Module:\n\n### listActivePunishments\n\n```java\n@NonNull CompletableFuture<@NonNull List<@NonNull Punishment>> listActivePunishments(\r\n            @NonNull UUID playerUUID, boolean includeGlobal);\n```\n\nRetrieves a list of active punishments for a specific player. You can include global punishments by setting includeGlobal to true.\n\n#### Example Usage:\n\n```java\nfinal UUID playerUUID = UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\");\r\nmoderationModule.listActivePunishments(playerUUID, true).thenAccept(punishments -> {\r\n    punishments.forEach(punishment -> {\r\n        System.out.println(\"Active Punishment: \" + punishment);\r\n    });\r\n});\n```\n\n### listAllPunishments\n\n```java\n@NonNull CompletableFuture<@NonNull List<@NonNull Punishment>> listAllPunishments(@NonNull UUID playerUUID, boolean includeGlobal);\n```\n\nRetrieves a complete list of punishments for a player, both active and inactive. Use includeGlobal to fetch global punishments.\n\n### applyPunishment\n\n```java\n@NonNull CompletableFuture<Punishment> applyPunishment(@NonNull Punishment punishment);\n```\n\nApplies a new punishment to a player. Returns the created punishment object.\n\n#### Example Usage:\n\n```java\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(BuiltInReason.HACKING_ESCALATION)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\r\n\r\nmoderationModule.applyPunishment(punishment).thenAccept(appliedPunishment -> {\r\n    System.out.println(\"Punishment applied: \" + appliedPunishment);\r\n});\n```\n\n### updatePunishment\n\n```java\n@NonNull CompletableFuture<Punishment> updatePunishment(@NonNull Punishment punishment);\n```\n\nUpdates an existing punishment with new information, such as adding notes or updating the removal information.\n\n### isMuted\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> isMuted(@NonNull UUID playerUUID);\n```\n\nChecks if a player is currently muted.\n\n#### Example Usage:\n\n```java\nmoderationModule.isMuted(playerUUID).thenAccept(isMuted -> {\r\n    if (isMuted) {\r\n        System.out.println(\"Player is muted.\");\r\n    } else {\r\n        System.out.println(\"Player is not muted.\");\r\n    }\r\n});\n```\n\n### isBanned\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> isBanned(@NonNull UUID playerUUID);\n```\n\nChecks if a player is currently banned.\n\n### hasActivePunishment\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> hasActivePunishment(@NonNull UUID playerUUID);\n```\n\nDetermines whether a player has any active punishment.\n\n### disableDefaultPunishmentCommand\n\n```java\nvoid disableDefaultPunishmentCommand();\n```\n\nDisables the default punishment command, allowing you to implement custom commands tailored to your project. See more information in the [punishment command guide](/docs/sdk/features/moderation/command)\n\n## Examples\n\n### Applying a Temporary Ban\n\n```java\nfinal PunishmentReasonImpl banReason = PunishmentReasonImpl.builder()\r\n    .type(PunishmentType.TEMP_BAN)\r\n    .displayReason(\"Excessive Toxicity\")\r\n    .priority(1)\r\n    .reasonIdentifier(\"toxicity\")\r\n    .duration(Duration.ofSeconds(3600 * 24));\r\n\r\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(banReason)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\r\n\r\nmoderationModule.applyPunishment(punishment).thenAccept(appliedPunishment -> {\r\n    System.out.println(\"Ban applied: \" + appliedPunishment);\r\n});\n```\n\n### Checking and Removing a Punishment\n\n```java\nfinal ModerationModule moderationModule = MineplexModuleManager.getRegisteredModule(ModerationModule.class);\r\nmoderationModule.listActivePunishments(playerUUID, false).thenAccept(punishments -> {\r\n    if (!punishments.isEmpty()) {\r\n        Punishment punishment = punishments.get(0);\r\n\r\n        final PunishmentRemovalImpl removalInformation = PunishmentRemovalImpl.builder()\r\n            .removeFromHistory(false)\r\n            .removalReason(\"Forgiven\")\r\n            .removalTimestamp(Instant.now())\r\n            .removalModerator(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n\r\n        punishment.setRemovalInformation(removalInformation);\r\n        moderationModule.updatePunishment(punishment).thenAccept(updated -> {\r\n            System.out.println(\"Punishment updated: \" + updated);\r\n        });\r\n    } else {\r\n        System.out.println(\"No active punishments found.\");\r\n    }\r\n});\n```\n"
  },
  {
    "slug": "/sdk/features/moderation/model",
    "title": "Punishment Object",
    "description": "Punishment object and how to use it",
    "content": "<JavadocLink artifactId=\"bom-public\" groupId=\"com.mineplex.studio\" classpath=\"com.mineplex.studio.dataplane.common.punishment.model.Punishment\" />\n\nThe Punishment interface defines the structure and behavior of a punishment entity. It includes methods to access punishment details, check conditions, and compute properties such as its remaining duration or global applicability.\n\n## Default Implementation: PunishmentImpl\n\nThe `PunishmentImpl` class provides a concrete implementation of the Punishment interface. It represents a punishment applied to an offline player and includes details about the player, moderator, reason, and scope of the punishment.\n\n### Key Features\n\n* Builder Pattern: Uses Lombok's @Builder annotation for convenient instantiation.\n* Immutable Data: Defined with Lombok's @Value for immutabilsity.\n* Default Values: Provides default values for fields like startTimestamp, removalInformation, and notes.\n\n### Fields\n\n* playerId (UUID): The UUID of the punished player.\n* moderatorId (UUID): The UUID of the moderator who issued the punishment.\n* startTimestamp (Instant): The timestamp when the punishment was applied (default: current time).\n* applicableProjects (`Set<String>`): The set of projects the punishment applies to.\n* punishmentReason (PunishmentReason): The reason for the punishment.\n* removalInformation (PunishmentRemoval): Information about the removal of the punishment (default: null).\n* identifier (UUID): The unique identifier of the punishment (default: null).\n* notes (String): Additional notes or comments about the punishment (default: null).\n\n### Usage Example:\n\n```java\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(BuiltInReason.HACKING_ESCALATION)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\n```\n\n## Method Overview\n\n### Identification Methods\n\n#### `hasIdentifier()`\n\n* Checks if the punishment has a unique identifier.\n* Returns: `true` if the identifier exists, otherwise `false`.\n\n#### `getIdentifier()`\n\n* Retrieves the unique identifier for the punishment.\n* Returns: `Optional<UUID>` containing the identifier if available.\n\n### Player and Moderator Information\n\n#### `getPlayerId()`\n\n* Retrieves the UUID of the punished player.\n* Returns: UUID of the player.\n\n#### `hasModeratorId()`\n\n* Checks if the punishment has a moderator ID.\n* Returns: true if a moderator ID exists, otherwise false.\n\n#### `getModeratorId()`\n\n* Retrieves the UUID of the moderator who issued the punishment.\n* Returns: `Optional<UUID>` containing the moderator ID if available.\n\n### Timing Information\n\n#### `getStartTimestamp()`\n\n* Retrieves the timestamp when the punishment was issued or should begin.\n* Returns: Instant representing the start time.\n\n#### `getRemainingDuration()`\n\n* Computes the remaining duration of the punishment.\n* Returns: Duration of the remaining time.\n\n<Note title=\"Important Note\" type=\"danger\">\n  If a punishment is permanent, you will receive `Duration.ZERO` in return from this method\n</Note>\n\n### Applicability and Scope\n\n#### `getApplicableProjects()`\n\n* Retrieves the set of project IDs where the punishment applies.\n* Returns: `Set<String>` containing applicable project IDs.\n\n#### `appliesTo(String projectIdentifier)`\n\nChecks if the punishment applies to a specific project.\n\n**Parameters:**\n\n* projectIdentifier: The project ID to check.\n\n* Returns: true if applicable, otherwise false.\n\n#### `isGlobal()`\n\n* Determines if the punishment is global (applicable to all projects).\n* Returns: true if global, otherwise false.\n\n### Punishment Reason\n\n#### `getPunishmentReason()`\n\n* Retrieves the reason for the punishment.\n* Returns: PunishmentReason containing the reason details.\n\n### Notes and Additional Information\n\n#### `hasNotes()`\n\n* Checks if the punishment has associated notes.\n* Returns: true if notes exist, otherwise false.\n\n#### `getNotes()`\n\n* Retrieves notes or comments about the punishment.\n* Returns: `Optional<String>` containing the notes if available.\n\n### Removal Information\n\n#### `hasRemovalInformation()`\n\n* Checks if the punishment has been removed.\n* Returns: true if removal information exists, otherwise false.\n\n#### `getRemovalInformation()`\n\n* Retrieves removal details if the punishment has been removed.\n* Returns: `Optional<PunishmentRemoval>` containing the removal information.\n\n#### `isRemoved()`\n\n* Checks if the punishment has been removed.\n* Returns: true if removed, otherwise false.\n"
  },
  {
    "slug": "/sdk/features/moderation/reasons",
    "title": "Punishment Reasons",
    "description": "Details about how the punishment reason system works",
    "content": "<JavadocLink artifactId=\"bom-public\" groupId=\"com.mineplex.studio\" classpath=\"com.mineplex.studio.dataplane.common.punishment.model.PunishmentReason\" />\n\nThe Punishment Reasons System is designed to provide a comprehensive framework for moderating projects efficiently. It includes built-in reasons to address common violations and enables consistent handling of infractions without requiring additional development work.\n\n## Built-In Reasons\n\nThe following reasons are pre-configured as part of the system. Each reason is associated with a specific type of punishment, a description, severity level, unique identifier, and duration.\n\nThe built-in reasons are located in the following class: `com.mineplex.studio.sdk.modules.moderation.BuiltInReason`\n\n### List of Built-In Reasons\n\n#### 1. Teaming\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Teaming with other users\n* Severity Level: 1\n* Identifier: teaming\n* Duration: 24 hours\n\n#### 2. Exploiting\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Exploiting game mechanics\n* Severity Level: 2\n* Identifier: exploiting\n* Duration: 48 hours\n\n#### 3. Griefing\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Griefing or destroying others' builds\n* Severity Level: 2\n* Identifier: griefing\n* Duration: 7 days\n\n#### 4. Unauthorized Use\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Using unauthorized tools or scripts\n* Severity Level: 2\n* Identifier: unauthorized\\_use\n* Duration: 48 hours\n\n#### 5. Team Killing\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Killing teammates or sabotaging team efforts\n* Severity Level: 2\n* Identifier: team\\_killing\n* Duration: 24 hours\n\n#### 6. Exploitation\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Exploiting bugs or glitches\n* Severity Level: 2\n* Identifier: exploitation\n* Duration: 48 hours\n\n#### 7. AFK Grinding\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Using automated systems for AFK grinding\n* Severity Level: 2\n* Identifier: afk\\_grinding\n* Duration: 7 days\n\n#### 8. Chat Escalation\n\n* Punishment Type: Temporary Mute (TEMP\\_MUTE)\n* Description: Escalation to Mineplex staff\n* Severity Level: 1\n* Identifier: chat\\_escalation\n* Duration: 7 days\n\n#### 9. Hacking Escalation\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Escalation to Mineplex staff\n* Severity Level: 1\n* Identifier: hacking\\_escalation\n* Duration: 7 days\n\n## Creating Custom Reasons\n\nThis guide provides two approaches to creating custom reasons for punishments: using the `PunishmentReasonImpl` builder or creating an enum that extends `PunishmentReason`.\n\n### Which Option to Choose?\n\n* Option 1: Use if you need to dynamically create reasons at runtime.\n* Option 2: Use if you have a fixed set of reasons and want to avoid duplication.\n\n### Option 1: Creating instance of PunishmentReasonImpl\n\nTo create a custom punishment reason with `PunishmentReasonImpl`, use its builder pattern. This allows you to define specific details such as type, display reason, priority, identifier, and duration.\n\n```java\nfinal PunishmentReasonImpl banReason = PunishmentReasonImpl.builder()\r\n    .type(PunishmentType.TEMP_BAN)\r\n    .displayReason(\"Excessive Toxicity\")\r\n    .priority(1)\r\n    .reasonIdentifier(\"toxicity\")\r\n    .duration(Duration.ofSeconds(3600 * 24));\n```\n\n### Option 2: Enum that extends PunishmentReason\n\nFor a more structured approach, define an enum that implements the PunishmentReason interface. This is useful when you need a predefined, reusable set of custom reasons.\n\n```java\n@RequiredArgsConstructor\r\n@Getter\r\npublic enum CustomReason implements PunishmentReason {\r\n    MY_REASON(PunishmentType.TEMP_BAN, \"My custom reason\", 1, \"custom_reason\", Duration.ofHours(24));\r\n\r\n    /**\r\n     * The {@link PunishmentType} associated with this reason.\r\n     */\r\n    private final @NonNull PunishmentType type;\r\n\r\n    /**\r\n     * A user-friendly display string for this reason.\r\n     */\r\n    private final @NonNull String displayReason;\r\n\r\n    /**\r\n     * The priority level of this reason, which may be used to determine the severity or importance.\r\n     */\r\n    private final int priority;\r\n\r\n    /**\r\n     * A unique identifier for this reason (unique within your namespace).\r\n     */\r\n    private final @NonNull String reasonIdentifier;\r\n\r\n    /**\r\n     * The duration for which the punishment should last.\r\n     * A duration of {@link Duration#ZERO} indicates a permanent punishment.\r\n     */\r\n    private final @NonNull Duration duration;\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/moderation/types",
    "title": "Punishment Types",
    "description": "Information about the types of punishments",
    "content": "<JavadocLink artifactId=\"bom-public\" groupId=\"com.mineplex.studio\" classpath=\"com.mineplex.studio.dataplane.common.punishment.model.PunishmentType\" />\n\n## Punishment Types\n\nWe currently support a handful of punishment types, these represent the type of punishment associated with a specific punishment reason.\n\n### TEMP\\_MUTE\n\nA temporary mute punishment. Users will be temporarily muted, and this punishment will expire after a set duration.\n\n### TEMP\\_BAN\n\nA temporary ban punishment. Users will be temporarily banned, and this punishment will expire after a set duration.\n\n### MUTE\n\nA mute punishment. Users will be muted indefinitely until the punishment is lifted. This type is permanent.\n\n### BAN\n\nA ban punishment. Users will be banned indefinitely until the punishment is lifted. This type is permanent.\n\n### WARNING\n\nA warning punishment. Used to inform a user that what they are doing is wrong.\n"
  },
  {
    "slug": "/sdk/features/party",
    "title": "Party Module",
    "description": "How to use the Mineplex Studio Party Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.party.PartyModule\" />\n\n# Party Module\n\nThe Party Module is one of the built-in Studio Modules that allows you to query whether players in your game are in a party, and determine who is in the party with them. These methods are solely for you to integrate our parties into your games. All party functionality is handled internally by the SDK and requires no further implementation on your end. To fetch a party using its ID, use the Party Module method `getPartyById(String)`. To fetch the party of a given player if one exists, use the Party Module method `getPartyOfPlayer(String)`.\n\n## Party Data\n\nOnce you've retrieved a party, you can access its ID, its leader, and all online players in the party.\n\n# Example\n\nLet's say we are making an open-world game where players can use the Party system to team up. We don't want to allow players in the same Party to hurt one another, so we integrate with the Party module.\n\n```java\npublic boolean canDamage(final Player damager, final Player victim) {\r\n    final Optional<Party> damagerParty = partyModule.getPartyOfPlayer(damager);\r\n    final Optional<Party> victimParty = partyModule.getPartyOfPlayer(victim);\r\n\r\n    // If neither player is in a party, they can't be in the same party\r\n    if (damagerParty.isEmpty() || victimParty.isEmpty()) {\r\n        return true;\r\n    }\r\n\r\n    // If the players are in one party, they can't hurt one another\r\n    return !damagerParty.get().getPlayers().contains(victim);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/player-ignore",
    "title": "Player Ignore Module",
    "description": "How to use the Mineplex Studio Player Ignore Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.ignore.PlayerIgnoreModule\" />\n\nThe Player Ignore Module is one of the built-in Studio Modules that allows you to check which players are ignoring each other.\r\nThis can be useful for creating custom chat filters, or for creating custom moderation tools.\n\n## Module Retrieval\n\nYou can retrieve the module by using the `MineplexModuleManager` via\n\n```java\nimport com.mineplex.studio.sdk.modules.MineplexModuleManager;\r\nPlayerIgnoreModule ignoreModule = MineplexModuleManager.getRegisteredModule(PlayerIgnoreModule.class);\n```\n\n## Checking if a Player is Ignoring Another\n\nYou can check if a player is ignoring another player by using the `isIgnoring(OfflinePlayer, OfflinePlayer)` or `isIgnoring(UUID, UUID)` method.\r\nIn this example we are checking if `player` is ignoring `toCheck`. This will also return `true` if the data for `player` is not loaded.\r\nYou can use `isLoaded(OfflinePlayer)` and `isLoaded(UUUID)` to check if the data is loaded.\n\n```java\npublic boolean isIgnoring(Player player, Player toCheck) {\r\n    return ignoreModule.isIgnoring(player, target);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/purchase",
    "title": "Purchase Module",
    "description": "How to use the Mineplex Studio Purchase Module",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.purchase.PurchaseModule\" />\n\nThe purchases module allows game developers on the Mineplex Studio to monetize their work by creating digital products available for single and repeatable sale formats as well as digital subscriptions that support reccurring payments.\n\n## High Level Purchase Flow\n\nPurchases within the Mineplex Studio are based on our in-game digital currency, called Crowns. Players use their local currency (such as US Dollars or Euros) to purchase Crowns from our website or in-game flows, and can then redeem these crowns for products and subscriptions listed by developers like you. At the end of the month, we pay out a profit-share based on the crowns spent within a given game mode to the developers.\n\n## Purchase Acknowledgements and Technical Flow\n\nThe purchase flow works as follows:\n\n<Step>\n  <StepItem title=\"Player Prompts Purchase\">\n    A player takes an in-game action that triggers the `promptPurchase` method in the Mineplex Purchases SDK module\n  </StepItem>\n\n  <StepItem title=\"Crowns Debited\">\n    The Mineplex payments service attempts to debit the player Crown balance\n  </StepItem>\n\n  <StepItem title=\"Event Received\">\n    An event is sent back to your game code based on the `callbackDelivery` mode defined in the purchaseable defintion file (see below). Events will only be delivered to one server at a time (your code generally does not need to handle event delivery atomically or in a concurrency-safe mode)\n  </StepItem>\n\n  <StepItem title=\"You Reward Player\">\n    If the purchase was successful, your code must grant the player the entitlement (such as an item or XP boost) and acknowledge the flow completion with the Mineplex payments service. You should acknowledge purchase events immediately after granting entitlements to avoid duplicate delivery\n  </StepItem>\n</Step>\n\n<Note type=\"note\">\n  * Events that are not acknowledged will be retried several times after a brief delay (currently up to three times with five-second delays, subject to change)\n  * Events that are not acknowledged within a sufficient time period or after the maximum retry count will be cancelled, and the crown transaction will be automatically refunded\n</Note>\n\n## Creating and Maintaining Products\n\nTo initiate the payment creation process, you can construct YAML files containing your product parameters, each including the following mandatory details. All parameters must be completed and must not be left empty or assigned a null value. Place these YAML files into the `config/purchases/` repository directory, with any file name. We uniquely identify your purchases within the project namespace based on the `productId` that you provide (so you should avoid changing this value).\n\n**productId** *String* - An unique product identifier assigned by the creator. This identifier is utilized for retrieving and deleting your product object after its creation.\n\n**productName** *String* - The name of the product being offered for sale. This is the primary name that users will see when looking to purchase a product.\n\n**productDescription** *String* - A description of the product being offered. This description is available to customers when reviewing the product offering prior to purchasing.\n\n**price** *Long* - The price of the digital asset for sale. This value is represented by Mineplex's digital currency: Crowns.\n\n**callbackDelivery** *enum* - Defines the parameters for the delivery of the product to the purchasers' player account. The available inputs are: `ONLY_WHEN_PLAYER_ONLINE` and `ALLOW_OFFLINE_DELIVERY`.\n\n**Product File Definition Structure**\n\n```yaml\nproductId: \"power-up-1\"\r\nproductName: \"Power Up\"\r\nproductDescription: \"This power up allows you to be more powerful!\"\r\nprice: 100\r\ncallbackDelivery: \"ONLY_WHEN_PLAYER_ONLINE\"\r\nrepeatablePurchase: false\n```\n\n## Creating and Maintaining Subscriptions\n\nThe subscription creation process is very similar to that of single sale digital products. You can construct YAML files containing your product parameters, each including the following mandatory details. All parameters must be completed and must not be left empty or assigned a null value. Place these YAML files into the `config/subscriptions/` repository directory, with any file name. We uniquely identify your subscriptions within the project namespace based on the `subscriptionId` that you provide (so you should avoid changing this value).\n\n**subscriptionId** *String* - An unique subscription identifier assigned by the creator. This identifier is utilized for retrieving and deleting your subscription object after its creation.\n\n**subscriptionName** *String* - The name of the subscription being offered for sale. This is the primary name that users will see when looking to subscribe to a subscription.\n\n**subscriptionDescription** *String* - A layout of the offerings of the subscription. This description is available to customers when reviewing the subscription offering prior to purchasing.\n\n**price** *Long* - The reoccurring price of the subscription. This value is represented by Mineplex's digital currency: Crowns.\n\n**subscriptionBasis** *enum* - This defines the reoccurring billing cycle of the subscription. The available inputs are: 'MONTHLY' | 'QUARTERLY' | 'SEMI\\_YEARLY' | YEARLY'\n\n**callbackDelivery** *enum* - Defines the parameters for the delivery of the product to the purchasers' player account. The available inputs are: `ONLY_WHEN_PLAYER_ONLINE` and `ALLOW_OFFLINE_DELIVERY`.\n\n**Subscription File Definition Structure**\n\n```yaml\nsubscriptionId: \"power-up-subscription-1\"\r\nsubscriptionName: \"Monthly Power-Up\"\r\nsubscriptionDescription: \"Get a bonus power-up every month by purchasing this subscription!\"\r\nprice: 100\r\nsubscriptionBasis: \"MONTHLY\"\r\ncallbackDelivery: \"ONLY_WHEN_PLAYER_ONLINE\"\n```\n\n## Discounts and Promotions\n\nDeveloper-defined discounts and promotions are not yet supported, but are coming soon! If you have a special requirement to offer limited-time pricing, please contact us.\n\n## Restrictions for Updating and Deleting Purchaseables\n\nTo avoid accidental deletion, the Mineplex GitHub Action that publishes your project will never delete old subscriptions or products, even if you remove their respective definition files. If you wish to delete a product or subscription, you must do so manually from the Studio Web Console.\n\nTo ensure a player-friendly experience, we also enforce certain restrictions.\n\nFor product listing updates, you cannot currently change:\n\n* The repeatable purchase status\n\nFor subscription listing updates, you cannot currently change:\n\n* A subscription's basis, or duration\n* The price of a subscription\n\n## Listening for Purchases\n\nDevelopers must listen to bukkit events emitted by the internal purchase module.\r\nThere are four types of purchase events that you can listen for inside your plugin.\n\n`AsyncProductPurchaseSuccessEvent** *<Product PendingTransaction<Product>>`\n\n* Fires when a product purchase is successful. Developers must grant the product and acknowledge the pending transaction.\n\n`AsyncProductPurchaseFailureEvent** *<Product FailedTransaction<Product>>`\n\n* Fires when a product purchase fails.\n\n`AsyncSubscriptionRenewalSuccessEvent** *<Subscription, PendingTransaction<Subscription>>`\n\n* Fires when a subscription purchase is successful. Developers must grant the subscription and acknowledge the pending transaction.\n\n`AsyncSubscriptionRenewalFailureEvent** *<Subscription, FailedTransaction<Subscription>>`\n\n* Fires when a subscription fails to renew. When a subscription fails to renew, developers must be sure to revoke the perks previously granted by this subscription.\n\nAlthough, developers have the choice of acknowledging incoming purchases.\r\nIt is recommended to acknowledge and grant any purchases as soon as possible.\r\nIf a purchase is not acknowledged, there will be a few delayed attempts before refunding the purchase.\n\nLet's use the example product above and create a listener that can give a player the power-up in game.\n\n### Example\n\n<Step>\n  <StepItem title=\"Purchase Event Listener\">\n    ```java\n    public class PurchaseEventListener implements Listener {\r\n\r\n        private static final I18nText GRANT_POWERUP = new I18nText(\"MyPlugin\", \"PURCHASE_GRANT_POWERUP\", \"<gold>You received a power up!</gold>\");\r\n        private static final I18nText PURCHASE_FAIL = new I18nText(\"MyPlugin\", \"PURCHASE_FAIL\", \"<red>Purchase of <product> failed! <reason></red>\");\r\n\r\n        @EventHandler\r\n        public void onProductPurchaseSuccess(final AsyncProductPurchaseSuccessEvent event) {\r\n            // Get the transaction and product.\r\n            final PendingTransaction<Product> transaction = event.getTransaction();\r\n            final Product product = event.getPurchasable();\r\n\r\n            final OfflinePlayer offlinePlayer = event.getPlayer();\r\n            final Player onlinePlayer = offlinePlayer.getPlayer();\r\n\r\n            // Verify this is the correct product by productId\r\n            if (product.getId().equals(\"power-up-1\")) {\r\n\r\n                // Verify that the player is online.\r\n                if (onlinePlayer == null) {\r\n                    return;\r\n                }\r\n\r\n                // Effect we want to grant to the player.\r\n                final PotionEffect potionEffect = new PotionEffect(PotionEffectType.ABSORPTION, (int) MinecraftTimeUnit.MINUTES.toTicks(2), 4);\r\n\r\n                // Grant the purchase. Make sure grant is thread-safe.\r\n                TaskUtil.onMainThread(() -> onlinePlayer.addPotionEffect(potionEffect)).run();\r\n\r\n                // Get message in the correct language and message the player.\r\n                final Component translatedMessage = MiniMessage.miniMessage().deserialize(GRANT_POWERUP.getText(onlinePlayer.locale()));\r\n                onlinePlayer.sendMessage(translatedMessage);\r\n\r\n                // Acknowledge the purchase after it has been granted and handle reversal in the event the acknowledgment fails.\r\n                transaction.acknowledge().exceptionally(ex -> {\r\n                    // Make sure reversal is thread-safe.\r\n                    TaskUtil.onMainThread(() -> onlinePlayer.removePotionEffect(potionEffect.getType())).run();\r\n                    return null;\r\n                });\r\n            }\r\n        }\r\n\r\n        @EventHandler\r\n        public void onProductPurchaseFail(final AsyncProductPurchaseFailureEvent event) {\r\n            // Get the transaction and product.\r\n            final FailedTransaction<Product> transaction = event.getTransaction();\r\n            final Product product = transaction.getPurchasable();\r\n\r\n            final OfflinePlayer offlinePlayer = event.getPlayer();\r\n            final Player onlinePlayer = offlinePlayer.getPlayer();\r\n\r\n            // Verify that the player is online.\r\n            if (onlinePlayer == null) {\r\n                return;\r\n            }\r\n\r\n            // Get message in the correct language, fill in the placeholders, and message the player.\r\n            final Component translatedMessage = MiniMessage.miniMessage().deserialize(\r\n                    PURCHASE_FAIL.getText(onlinePlayer.locale()),\r\n                    Placeholder.unparsed(\"product\", product.getName()),\r\n                    Placeholder.unparsed(\"reason\", transaction.getFailureReason().orElse(\"\"))\r\n            );\r\n\r\n            onlinePlayer.sendMessage(translatedMessage);\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Register the Listener\">\n    ```java\n    Bukkit.getPluginManager().registerEvents(new PurchaseEventListener(), plugin);\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/sdk/features/queueing",
    "title": "Queue Module",
    "description": "How to use the Mineplex Studio Queue Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.queuing.QueuingModule\" />\n\nThe Queue Module is a key Mineplex Studio component that allows you to manage queues for players to join games. This module supports both dynamic and static game allocations and provides various methods to control queueing behavior. With it, you can build a centralized hub, facilitating player flow across different games in your setup. However, queuing a player does not guarantee immediate transfer, as this depends on the matchmaking status of the target game.\n\n## Queuing Methods\n\nThe following methods can be used to manage player queues in your games:\n\n### 1. `enqueuePlayer(Player player, String gameId)`\n\nQueues a player for a dynamically allocated game. This method is useful for games that are created on-demand.\n\n* **Parameters**:\n  * `player`: The player to queue.\n  * `gameId`: The identifier of the game or game tag.\n* **Returns**: A `CompletableFuture<Void>` that completes when the player is enqueued.\n\n#### Example\n\n```java\npublic void queueForGame(Player player, String gameId) {\r\n    queuingModule.enqueuePlayer(player, gameId).thenAccept(unused -> {\r\n        player.sendMessage(\"You have been queued for \" + gameId);\r\n    }).exceptionally(error -> {\r\n        player.sendMessage(\"Queue failed: \" + error.getMessage());\r\n        return null;\r\n    });\r\n}\n```\n\n### 2. `enqueuePlayer(Player player, String gameId, String commonName)`\n\nQueues a player for a statically allocated game, based on a common name. This is useful for games that are permanently available.\n\n* **Parameters**:\n  * `player`: The player to queue.\n  * `gameId`: The identifier of the game.\n  * `commonName`: The common name associated with the server to move to.\n* **Returns**: A `CompletableFuture<Void>` that completes when the player is enqueued.\n\n#### Example\n\n```java\npublic void queueForStaticGame(Player player, String gameId, String commonName) {\r\n    queuingModule.enqueuePlayer(player, gameId, commonName).thenAccept(unused -> {\r\n        player.sendMessage(\"You have been queued for \" + commonName);\r\n    }).exceptionally(error -> {\r\n        player.sendMessage(\"Queue failed: \" + error.getMessage());\r\n        return null;\r\n    });\r\n}\n```\n\n### 3. `dequeuePlayer(Player player)`\n\nRemoves a player from the queue they are currently in.\n\n* **Parameters**:\n  * `player`: The player to remove from the current queue.\n* **Returns**: A `CompletableFuture<Void>` that completes when the player is dequeued.\n\n#### Example\n\n```java\npublic void leaveQueue(Player player) {\r\n    queuingModule.dequeuePlayer(player).thenAccept(unused -> {\r\n        player.sendMessage(\"You have been removed from the queue.\");\r\n    });\r\n}\n```\n\n### 4. `getPlayerQueueStatus(Player player)`\n\nRetrieves the queue status for a player.\n\n* **Parameters**:\n  * `player`: The player to check.\n* **Returns**: A `CompletableFuture<GetQueueStatusResponse>` containing the player's queue status.\n\n```java\npublic void checkQueueStatus(Player player) {\r\n    queuingModule.getPlayerQueueStatus(player).thenAccept(status -> {\r\n        player.sendMessage(\"Queue status: \" + status.getStatus());\r\n    });\r\n}\n```\n\n### 5. `returnLobby(Player player)`\n\nReturns a player to the main lobby, removing them from any queues or active games.\n\n* **Parameters**:\n  * `player`: The player to return to the lobby.\n\n```java\npublic void returnToLobby(Player player) {\r\n    queuingModule.returnLobby(player);\r\n    player.sendMessage(\"You have been returned to the lobby.\");\r\n}\n```\n\n### 6. `retainPlayer(Player player)`\n\nKeeps a player in their current queue, avoiding entry into specific game tags. This is useful when a player wants to continue playing your mode rather than playing the tag rotation.\n\n* **Parameters**:\n  * `player`: The player to retain.\n* **Returns**: A `CompletableFuture<Void>` that completes once the player is retained\n\n```java\npublic void keepPlayerInQueue(Player player) {\r\n    queuingModule.retainPlayer(player).thenAccept(unused -> {\r\n        player.sendMessage(\"You will stay in Micro Battles.\");\r\n    });\r\n}\n```\n\n### 7. `requeuePlayer(Player player)`\n\nRe-queues a player based on their previous queue choice, making it easy for them to play again without manual selection.\n\n* **Parameters**:\n  * `player`: The player to requeue.\n* **Returns**: A `CompletableFuture<Void>` that completes once the player is requeued.\n\n#### Example\n\n```java\npublic void requeuePlayer(Player player) {\r\n    queuingModule.requeuePlayer(player).thenAccept(unused -> {\r\n    player.sendMessage(\"You have been requeued.\");\r\n});\r\n}\n```\n\n### 8. `joinedThroughTag(Player player)`\n\nChecks if a player joined the current game mode via a tag. Useful for prompting people to re-queue for a tag instead of your own mode.\n\n* **Parameters**:\n  * `player`: The player to check.\n* **Returns**: `true` if the player joined through any tag, otherwise `false`.\n\n#### Example\n\n```java\npublic boolean didJoinThroughTag(Player player) {\r\n    return queuingModule.joinedThroughTag(player);\r\n}\n```\n\n### 9. `joinedThroughTag(Player player, String tag)`\n\nChecks if a player joined the current game mode using a specific tag, allowing you to trigger different behaviour (e.g. rewards to incentivise people to stick with your game).\n\n* **Parameters**:\n  * `player`: The player to check.\n  * `tag`: The tag to verify as the player's entry method.\n* **Returns**: `true` if the player joined through the specified tag, otherwise `false`.\n\n#### Example\n\n```java\npublic boolean didJoinThroughSpecificTag(Player player, String tag) {\r\n    return queuingModule.joinedThroughTag(player, tag);\r\n}\n```\n\n***\n\n## Queue Responses\n\nQueue operations may result in the following responses:\n\n* `SUCCESS` - Player successfully queued for the target game.\n* `FAIL_ALREADY_QUEUED` - Player is already queued for a game.\n* `FAIL_IN_PARTY` - Player cannot queue because they are in a party but not the leader.\n* `FAIL_OTHER` - Queue request failed for another reason.\n\n#### Example: Interactive Queue with NPC\n\nIn a custom hub, players can interact with NPCs to join a game queue.\n\n```java\npublic void interactWithNPC(Player player, GameNPC npc) {\r\n    if (queuingModule.getPlayerQueueStatus(player).isQueued()) {\r\n        queuingModule.dequeuePlayer(player);\r\n    } else {\r\n        queuingModule.enqueuePlayer(player, npc.getGameId());\r\n    }\r\n}\n```\n\n## Tag Queue\n\nThe following tags (or category) are currently supported for tag queueing: `Arcade`\n\n**Guidelines for all games in supported tag queues:**\n\n* Partners should prompt people to re-queue for the tag on death/elimination.\n* Not block the queue flow in any way (e.g. re-queueing for your game without affirimitive action from player)\n* Use the `requeue` method for re-queueing people rather than `enqueue`\n* Must support an option in hotbar to return to the lobby before game start, or when a spectator (clock or bed item).\n\n**If your game is tagged or has the `Arcade` category, it must also meet certain conditions:**\n\n* Must not kick to hub after game end (requeue instead), avoid closing server until players are empty (or server is killed), save stats/data on game end (before re-queue) to avoid race conditions.\n* Must have a hotbar item to re-queue for Arcade if joining via Arcade tag\n\nFailing to abide by a tag's guidelines will result in the tag being removed and the game being blocked from using the tag until approval is given.\n"
  },
  {
    "slug": "/sdk/features/resourcepack",
    "title": "Resource Pack SDK",
    "description": "How to use the Mineplex Studio Resource Pack SDK",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.resourcepack.ResourcePackModule\" />\n\n# Resource Pack Module\n\nThe resource pack module allows game developers on the Mineplex Studio to retrieve uploaded resource pack and display those to players.\r\nAll resource packs must be stored in the `config/resource-packs` directory and are identified by their file name.\n\n## Uploading Resource Packs\n\nStore all your resource packs in the `config/resource-packs` directory, and they will be uploaded to the Mineplex Studio\r\nautomatically during the github build action or during the start of your development server.\n\n## Updating Resource Packs\n\nTo update a resource pack, simply replace the old version with the new version and re-run the github action or re-start the development server.\n\n## Retrieving Resource Packs\n\n```java\npublic ResourcePack getResourcePack(final String packName) {\r\n   resourcePackModule.get(packName);\r\n}\r\n\r\npublic ImmutableMap<String, ResourcePack> getResourcePacks() {\r\n   return resourcePackModule.getAll();\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/stats",
    "title": "Stats Module",
    "description": "How to use the Mineplex Studio Stats Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.stats.StatsModule\" />\n\nThe Stats Module is one of the built-in Studio Modules that allows you to quickly and easily store, update, and retrieve dynamic player stats in categories that are configurable on-the-fly at runtime. Let players celebrate their wins and hours spent in your game, without having to do any of the heavy lifting and data storage yourself.\n\n## CRUD\n\nThe CRUD methods provided in the Stats Module are as follows:\n\n* `getPlayerStats(player)` - Retrieves a `Map<String, Long>` of all stats the player has earned in this project namespace\n* `awardPlayerStats(player, Map<String, Long>)` - Increments the specific stats for the player by specified amounts, returning the resulting stat values after the increment\n* `setPlayerStats(player, Map<String, Long>` - Updates the specific stats for the player to the specified amounts\n* `deletePlayerStats(player, List<String>` - Deletes the specified stats from the player's record\n\nEach CRUD method can be called using either the player ID or the Player object itself. Additionally, each CRUD method has an asynchronous version for use when calling from the main thread.\n\n# Examples\n\n## Retrieving Player Stats\n\nLet's say we've devised a cool way to show players their stats in our game. Before we can start displaying them, we have to retrieve them!\n\n```java\npublic void displayStats(final Player player) {\r\n    statsModule.getPlayerStatsAsync(player).thenAccept(stats -> {\r\n        Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n            // Display stats!\r\n        });\r\n    });\r\n}\n```\n\n## Recording Stats\n\nIf we're going to display stats, we have to make sure we record them first!\n\n```java\npublic void recordWin(final Player player) {\r\n    // Increments player's \"Wins\" and \"WinStreak\" stats by 1\r\n    statsModule.awardPlayerStatsAsync(player, Map.of(\"Wins\", 1L, \"WinStreak\", 1L));\r\n}\r\n\r\npublic void recordLoss(final Player player) {\r\n    // Increments player's \"Losses\" stat by 1\r\n    statsModule.awardPlayerStatsAsync(player, Map.of(\"Losses\", 1L));\r\n    // Sets player's WinStreak to 0 (since they lost)\r\n    statsModule.setPlayerStatsAsync(player, Map.of(\"WinStreak\", 0L));\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/world/datapoints",
    "title": "World Datapoints",
    "description": "Information about our map datapoint system.",
    "content": "### What are datapoints?\n\nData Points are designed to be stored and loaded from template maps. They allow your level designers to dynamically place down keyed data points while building your maps, which can then be queried at runtime to locate points of interest. This allows you to constantly deploy new maps without needing to update your code, and saves you having to hardcode points of interest for each map.\n\n### MineplexWorld Datapoints\n\nData Points can be queried from a `MineplexWorld` using the `getDataPoints(String)` method, which returns a `List` of `Location`s stored under a given key, or using the `getDataPoints()` method, which returns a `Map` of each key to the `List` of `Location`s stored under them.\n\n### Default Implementation\n\nOur implementation of the MineplexWorldModule allows you to load up a Zip file. This zip file is able to be encoded with datapoints without the need for runtime rendering or calculation of the datapoints.\n\nIn order to load them, within a world's zip file, include `dataPoints.json` or `dataPoints.yml`:\n\n#### Example file structure:\n\n<FileTree>\n  <Folder name=\"CAKE-WARS_COOKIE.zip\" label=\"Example World\">\n    <Folder name=\"data\" label=\"data\" />\n\n    <Folder name=\"entities\" label=\"entities\" />\n\n    <Folder name=\"region\" label=\"region\" />\n\n    <File name=\"dataPoints.json\" label=\"dataPoints.json\" />\n\n    <File name=\"level.dat\" label=\"level.dat\" />\n  </Folder>\n</FileTree>\n\nThis Zip file would then be placed in your repository's `/assets/world-templates` folder and loaded using the world loading methods described in the [World Module](.) documentation.\n\n#### Example JSON file:\n\n```json\n{\r\n  \"SPAWNPOINT_1\": [\r\n    {\r\n      \"x\": 0.5,\r\n      \"y\": 67.0,\r\n      \"z\": 11.5,\r\n      \"yaw\": -180.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"STORE_NPC\": [\r\n    {\r\n      \"x\": -11.476646845190304,\r\n      \"y\": 72.0,\r\n      \"z\": 25.511839252200495,\r\n      \"yaw\": 269.12354,\r\n      \"pitch\": 33.138355\r\n    },\r\n    {\r\n      \"x\": 12.5,\r\n      \"y\": 72.0,\r\n      \"z\": 25.5,\r\n      \"yaw\": 90.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"SPAWNPOINT_2\": [\r\n    {\r\n      \"x\": 41.5,\r\n      \"y\": 67.0,\r\n      \"z\": -18.5,\r\n      \"yaw\": 90.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"SPAWNPOINT_3\": [\r\n    {\r\n      \"x\": 18.5,\r\n      \"y\": 122.0,\r\n      \"z\": 180.5,\r\n      \"yaw\": -180.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"SPAWNPOINT_4\": [\r\n    {\r\n      \"x\": 18.5,\r\n      \"y\": 121.0,\r\n      \"z\": 238.5,\r\n      \"yaw\": -180.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/world",
    "title": "World Module",
    "description": "How to use the Mineplex Studio World Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.world.MineplexWorldModule\" />\n\nThe World Module is one of the built-in Studio Modules that allows you to create, load, save, and generate worlds dynamically in your project. With the World Module, you can do anything from per-player stored plot worlds, to massive persistent generated adventure worlds, to ephemeral worlds created from map templates. `MineplexWorld`s are totally configurable, from their persistence, to their generation, to whether they exist only in memory. They also contain keyed Data Points that can be used to dynamically load points of interest from varied map templates - the days of hard coding specific locations in your game are long gone.\n\n## Creating a `MineplexWorld`\n\nIn order to create a new `MineplexWorld`, the World Module method `createMineplexWorld(MineplexWorldConfig)` must be executed with a completed and valid `MineplexWorldConfig`.\n\n### `MineplexWorldConfig`\n\nA `MineplexWorldConfig` is comprised of a few key options.\n\nFirst, you have the option to specify a `PersistentWorldConfig`. By default, this is `null`, indicating that the `MineplexWorld` will not be persistent. Setting this value to a valid `PersistentWorldConfig` will cause the created `MineplexWorld` to be persistent.\n\n#### `PersistentWorldConfig`\n\nThe only configuration needed in a `PersistentWorldConfig` is a `String` value for the `worldBucket` option. This value will determine the name of the data collection this persistent world will be stored within.\n\nNext comes the significant portion of the configuration process for a new `MineplexWorld`. The `WorldCreationConfig` comprises almost all of the options that control the makeup of the new world. This config cannot be `null`, and must be filled out by you so as to be valid.\n\n#### `WorldCreationConfig`\n\nWithin the `WorldCreationConfig` there are several configuration options, some of which conflict with each other. The first option is a `String` value for the `worldTemplate`, which defaults to `null`. If this is set to a value, any further options in the `WorldCreationConfig` will be ignored and the `MineplexWorld` will be initialized from the project map template named the same as the `String` value, if the template exists. If there is no such named template, then the world creation will fail. The next option is `voidWorld`, which can be `true` or `false`. This option defaults to `true`, in which case the created world will generate no terrain, and therefore all subsequent options in the `WorldCreationConfig` will be ignored. If this option is set to `false`, then the world will generate via the default generator, or a custom one if specified. A custom world generator can be defined for the new world via the following options:\n\n* `customChunkGenerator` will accept a `ChunkGenerator` implementation from the Bukkit API. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n* `customBlockPopulators` will accept a `Collection<BlockPopulator>`, based on `BlockPopulator` implementations from the Bukkit API. This can be directly specified, or included in the above `customChunkGenerator` if one is set. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n* `customBiomeProvider` will accept a `BiomeProvider` implementation from the Bukkit API. This can be directly specified, or included in the above `customChunkGenerator` if one is set. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n\nFinally, the seed for the world generation can be specified by setting the `customSeed` option to a given `Long` value. Defaults to `null`, in which case a random seed is used.\n\nAfter the `WorldCreationConfig` is complete, you need to make a determination as to what region format your new `MineplexWorld` should use, by setting the `worldRegionType` option to one of the `WorldRegionFormatType`s. Defaults to `WorldRegionFormatType.ANVIL`.\n\n#### `WorldRegionFormatType`\n\n* `ANVIL`: The Minecraft Java Edition standard region format developed by Mojang. Regions are stored as `.mca` files.\n\nFinally, you must specify whether your `MineplexWorld` should exist exclusively in memory via the `inMemoryOnly` option, or if it should instead utilize the storage of the container to load/unload chunks. By default this is set to `true`, in memory only, and this should work for most use cases. However, **if your map template is significantly large, or if players are able to cause the world to generate without a sufficiently tight boundary, the world may grow to a size that cannot be retained in memory. If this is the case, electing to keep the `inMemoryOnly` option set to `true` may result in undefined behavior or container crashes.**\n\n## Loading a `MineplexWorld` from Storage\n\nThere are two ways to load a persistent `MineplexWorld` from long-term storage. Your first option is the World Module method `loadMineplexWorld(String, String, WorldCreationConfig)`, which attempts to asynchronously download and load in the `MineplexWorld` with the specified ID from the specified `worldBucket`. If no `MineplexWorld` matches the ID in that `worldBucket`, then no `MineplexWorld` is loaded. Alternatively, you can use the World Module method `loadOrCreateMineplexWorld(String, String, MineplexWorldConfig)`, which also attempts to asynchronously download and load in the `MineplexWorld` with the specified ID from the specified `worldBucket`. However, in the case where this method does not find a matching `MineplexWorld`, it will create a new one using the provided `MineplexWorldConfig`.\n\n## Unloading a `MineplexWorld`\n\nYou are not able to force a `MineplexWorld` to unload, however you should not need to. Instead, you can use the World Module method `releaseWorld(MineplexWorld)` to indicate to the World Module that the world is no longer needed. At that point, the World Module will conduct save procedures for the `MineplexWorld` (if any are defined), then unload the world and free up any space.\n\n## Deleting a `MineplexWorld`\n\nThis functionality is specifically for unloaded persistent `MineplexWorld`s. **This should not be called for a loaded or ephemeral world.** To delete a stored persistent `MineplexWorld`, call the World Module method `deleteWorld(String, String)` with the `MineplexWorld` `worldBucket` and ID as the argument.\n\n## Getting a loaded `MineplexWorld`\n\nIn order to get a `MineplexWorld` that has already been loaded by the World Module, use the method `getLoadedMineplexWorld(String)`. **Note that this will require you to know the `MineplexWorld` ID.**\n\n## Data Points\n\nView full information on datapoints [here](docs/sdk/features/world/datapoints)\n\n# Examples\n\n## Creating a `MineplexWorld` from a Map Template\n\nLet's say we have some map templates in our project. We can dynamically create new `MineplexWorld`s based on those templates at runtime.\n\n```java\npublic MineplexWorld createFromTemplate(final String template) {\r\n    // Creates a new in-memory, ephemeral world from the given template using the ANVIL region format\r\n    return worldModule.createMineplexWorld(MineplexWorldConfig.builder()\r\n            .worldRegionType(MineplexWorldConfig.WorldRegionFormatType.ANVIL)\r\n            .worldCreationConfig(WorldCreationConfig.builder()\r\n                    .worldTemplate(template)\r\n                    .build())\r\n            .build());\r\n}\n```\n\n## Randomly Generating a `MineplexWorld`\n\nLet's say we don't want to use a template. We can create a new `MineplexWorld` using the random world generation built into the game. We can also make it persistent.\n\n```java\npublic MineplexWorld generateNewPersistentWorld(final Long seed) {\r\n    // Creates and generates a new persistent world cached on the filesystem\r\n    // using the anvil region format and a seed\r\n    return worldModule.createMineplexWorld(MineplexWorldConfig.builder()\r\n            .persistentWorldConfig(PersistentWorldConfig.builder()\r\n                    .worldBucket(\"Examples\")\r\n                    .build())\r\n            .worldCreationConfig(WorldCreationConfig.builder()\r\n                    .voidWorld(false)\r\n                    .customSeed(seed)\r\n                    .build())\r\n            .build());\r\n}\n```\n"
  },
  {
    "slug": "/sdk/gui",
    "title": "GUI Menus",
    "description": "How to use the GUI Menus in the Studio.",
    "content": "By releasing your game on the Mineplex Studio, you are gaining access to players of both the Java Edition and Bedrock Edition of Minecraft simultaneously. While the two editions are similar, there are some key differences. One of the largest distinctions between the two is interaction with GUI Menus. Those familiar with Java Edition should be well-acquainted with the classic inventory-based menu, while those who primarily play Bedrock Edition are instead used to the modal-based Forms used in that version. Since your game is served to both types of player, it is important to reconcile this difference in functionality so everyone can play your game to the fullest.\n\n## MineplexGUI\n\nAny GUI Menu used in a Studio project should implement the `MineplexGUI` interface. To do so properly, you are required to implement both a Bedrock Form menu using [Cumulus](https://wiki.geysermc.org/geyser/forms/) that is created when the `createBedrockForm(Player)` method is called, and a Java inventory menu using [InUI](https://github.com/NichtStudioCode/InvUI) that is created when the `createJavaInventoryMenu(Player)` method is called. The `MineplexGUI` interface additionally provides a default `createAndOpen(Player)` method implementation that checks if the player is on a Bedrock client, and if so opens the Bedrock Form, and otherwise opens the Java inventory menu.\n\n# Example\n\nLet's create a very basic GUI Menu with one button a player can press.\n\n```java\npublic class MyGUI implements MineplexGUI {\r\n   private void pickNo(final Player player) {\r\n       player.sendMessage(Component.text(\"Picked No!\"));\r\n   }\r\n\r\n   private void pickYes(final Player player) {\r\n       player.sendMessage(Component.text(\"Picked Yes!\"));\r\n   }\r\n\r\n   private void pickNone(final Player player) {\r\n       player.sendMessage(Component.text(\"Picked None!\"));\r\n   }\r\n\r\n   @Override\r\n   public Form createBedrockForm(final @NotNull Player player) {\r\n       return ModalForm.builder()\r\n               .title(\"Y/N\")\r\n               .content(\"Pick Yes or No\")\r\n               .button1(\"Yes\")\r\n               .button2(\"No\")\r\n               .closedOrInvalidResultHandler(() -> this.pickNone(player))\r\n               .validResultHandler((modalForm, modalFormResponse) -> {\r\n                   if (\"Yes\".equals(modalFormResponse.clickedButtonText())) {\r\n                       this.pickYes(player);\r\n                   } else {\r\n                       this.pickNo(player);\r\n                   }\r\n               })\r\n               .build();\r\n   }\r\n\r\n   @Override\r\n   public Window createJavaInventoryMenu(final @NotNull Player player) {\r\n       final ItemStack yesItem = new ItemStack(Material.LIME_WOOL);\r\n       yesItem.editMeta(meta -> meta.displayName(MiniMessage.miniMessage().deserialize(\"<green>Yes</green>\")));\r\n\r\n       final ItemStack noItem = new ItemStack(Material.RED_WOOL);\r\n       noItem.editMeta(meta -> meta.displayName(MiniMessage.miniMessage().deserialize(\"<red>No</red>\")));\r\n\r\n       final Gui gui = Gui.normal()\r\n               .setStructure(\"# # # Y # N # # #\")\r\n               .addIngredient('Y', new SimpleItem(yesItem, click -> this.pickYes(click.getPlayer())))\r\n               .addIngredient('N', new SimpleItem(noItem, click -> this.pickNo(click.getPlayer())))\r\n               .build();\r\n\r\n       return Window.single()\r\n               .setViewer(player)\r\n               .setTitle(\"Pick Yes or No\")\r\n               .setGui(gui)\r\n               .addCloseHandler(() -> this.pickNone(player))\r\n               .build();\r\n   }\r\n}\n```\n\nFor details on creating more detailed menus, please visit the documentation for both types of GUIs.\n\nNow that we've created our GUI Menu, we can show it to a player.\n\n```java\nprivate final MyGUI myGUI = new MyGUI();\r\n\r\npublic void askPlayer(final Player player) {\r\n    myGUI.createAndOpen(player);\r\n}\n```\n"
  },
  {
    "slug": "/sdk",
    "title": "Building Your Game",
    "description": "How to get started building a game with the Mineplex Studio SDK.",
    "content": "Once you've created a new project, you can get started building your game on top of the Studio SDK.\n\n## Prerequisites\n\nBefore you can get started with the SDK, you'll need to install the [Dependency](/docs/sdk/installation). If you created your project using the Studio CLI, this will be installed by default already. You also need to make sure you have JDK21 installed on your computer.\n\n## Modules\n\nThe Studio SDK is comprised of multiple different types of functionality, referred to as \"Modules\". The SDK comes pre-packaged with several built-in modules we made for you. You can also make your own custom modules to implement your unique gameplay! Soon, we also plan to allow you to make modules to sell to other game developers via our asset marketplace.\n\n## Java Project Setup\n\nWhen building a game using the Studio SDK, it's important to make sure you're targeting the right version of Minecraft and Java. The Studio currently supports the latest version of Minecraft (1.21.1) and Java 21. Your Studio project will be packaged in the form of a Paper plugin. If you're not familiar with what that is, we encourage you to do some research before getting started.\n"
  },
  {
    "slug": "/sdk/installation",
    "title": "Dependency Installation",
    "description": "How to install the Mineplex Studio SDK.",
    "content": "## Components and Updating the SDK\n\nThe Studio SDK dependency is vended in two pieces:\n\n* The Core SDK, which contains a set of interfaces, data classes, and API contracts to interact with various Mineplex Modules. This is automatically added to your project and has the artifact coordinates of `com.mineplex.sdk.plugin`. You can update the version manually by changing the version of this artifact.\n* The Engine, which implements interfaces provided in the Core SDK. This is installed as a plugin JAR into your project when you test your code in Development Containers or when you publish your game to the Studio. The latest version of the Engine plugin is automatically vended to your game containers as they are launched, and there is not yet any way to specify other versions.\n"
  },
  {
    "slug": "/sdk/internationalization",
    "title": "Internationalization",
    "description": "How to internationalize text strings in the Studio.",
    "content": "By releasing your game on the Mineplex Studio, you are gaining access to a global audience of players, all excited to\r\ntry out what you've built. In order to make sure that all our players have the best possible experience, no matter where\r\nthey're from, we've prioritized our internationalization system from the outset. While you are not required to make use\r\nof this system, you are highly encouraged to take advantage of it if you can. Your game's reach and playerbase will grow\r\nfrom making all players feel welcome!\n\n## Language Selection\n\nOur internationalization system integrates directly with the game client to perform language selection, meaning your\r\nplayers will automagically experience your game in the language they're already familiar with playing Minecraft in -\r\nassuming you've provided the necessary translations.\n\n## Language Mappings\n\nLanguage data files should stored as UTF-8 encoded `.properties` files in the `resource` directory of your project\r\nand loaded on application startup through the `I18NModule`.\n\n## API\n\nAfter loading the translations, you can use the `Component.translatable` method to create a translatable component.\n\n# Examples\n\n## Mappings\n\nLet's say we're internationalizing our application. In our `resource` directory, we need to create a mapping\r\nfile, such as `MyMessages_en.properties` for English or `MyMessages_de.properties` for German.\n\nOur english translations inside `MyMessages_en.properties`\n\n```properties\nmy_game.join.greeting=Hello there!\n```\n\nOur german translations inside `MyMessages_de.properties`\n\n```properties\nmy_game.join.greeting=Hallo!\n```\n\nLets load our new translations!\n\n```java\npublic void loadTranslations() {\r\n    final I18NModule i18NModule = MineplexModuleManager.getRegisteredModule(I18NModule.class);\r\n    for (final Locale locale : i18NModule.getAvailableLocales()) {\r\n        final ResourceBundle bundle = ResourceBundle.getBundle(\"MyMessages\", locale, UTF8ResourceBundleControl.get());\r\n        i18NModule.addTranslation(locale, bundle, true);\r\n    }   \r\n}\n```\n\n## API\n\nNow that we have our mapping, we can use it in our game code.\n\n```java\nprivate final Component greetingText = Component.translatable(\"my_game.join.greeting\");\r\n\r\n@EventHandler\r\npublic void onJoin(final PlayerJoinEvent event) {\r\n   player.sendMessage(greetingText);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/modules/messaging",
    "title": "Messaging Module",
    "description": "How to use the Mineplex Studio Messaging Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.messaging.MessagingdModule\" />\n\nThe Messaging Module enables communication between containers in the same namespace by sending and receiving messages. Messages can be targeted to specific containers based on various criteria.\n\n## Key Concepts\n\n* **Namespace-Specific Messaging**: Messages can only be sent to and received from containers within the same namespace.\n* **Event-Driven Architecture**: Messages trigger events, enabling responsive and asynchronous communication.\n* **Targeted Delivery:** Messages can be directed to specific containers, projects, or namespaces.\n\n## Use Cases\n\n* **Inter-Container Communication:** Facilitate communication between different containers within the same namespace for coordinated actions.\n* **Event Handling:** Use event-driven architecture to respond to specific messages with appropriate handlers.\n* **Targeted Messaging:** Send messages to specific containers based on predefined criteria for targeted communication.\n\n## Primary Functionalities\n\n### Registering a Listener\n\nYou can register a listener to receive messages associated with a specific key. When a message with the registered key is received, an AsyncMineplexMessageReceivedEvent is triggered.\n\n```java\nvoid registerKey(@NonNull String key);\n```\n\n#### Parameters:\n\n* key: The key for the messages you want to listen for.\n\n### Sending a Message to a Single Target\n\nSend a message to a specific target with a designated key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessage(\r\n    @NonNull String key, \r\n    @NonNull Object message, \r\n    @NonNull MineplexMessageTarget target\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* message: The message content.\n* target: The target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n### Sending a Message to Multiple Targets\n\nSend a message to multiple specified targets with a designated key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessage(\r\n    @NonNull String key, \r\n    @NonNull Object message, \r\n    @NonNull Collection<@NonNull MineplexMessageTarget> targets\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* message: The message content.\n* targets: Collection of target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n### Sending Multiple Messages to a Single Target\n\nSend multiple messages to a single target with the same key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessages(\r\n    @NonNull String key, \r\n    @NonNull Collection<@NonNull Object> messages, \r\n    @NonNull MineplexMessageTarget target\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* messages: Collection of messages to be sent.\n* target: The target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n## MineplexMessageTarget\n\n### Matching Namespace\n\nCreate a message target by targeting any container in a given namespace.\n\n```java\npublic static MineplexMessageTarget matchingNamespace(@NonNull final String namespaceIdentifier);\n```\n\n### Matching Project\n\nCreate a message target by targeting any container in a given project.\n\n```java\npublic static MineplexMessageTarget matchingProject(@NonNull final String projectIdentifier);\n```\n\n### Matching Pod\n\nCreate a message target by targeting a specific container.\n\n```java\npublic static MineplexMessageTarget matchingPod(@NonNull final String podIdentifier);\n```\n\n## Example\n\nTo assist in using this module, here is an example which sends and receives messages.\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport com.mineplex.studio.sdk.modules.messaging.MessagingModule;\r\nimport com.mineplex.studio.sdk.modules.MineplexModuleManager;\r\nimport com.mineplex.studio.sdk.modules.messaging.target.MineplexMessageTarget;\r\nimport org.bukkit.plugin.java.JavaPlugin;\r\n\r\npublic class MyGame extends JavaPlugin {\r\n\r\n    private MessagingModule messagingModule;\r\n\r\n    @Override\r\n    public void onEnable() {\r\n        // Initialize the messaging module\r\n        this.messagingModule = MineplexModuleManager.getRegisteredModule(MessagingModule.class);\r\n\r\n        // setup the messaging module\r\n        this.messagingModule.setup();\r\n\r\n        // Register a listener for incoming messages\r\n        // This is only required if you'd like to also listen to the incoming message on this key\r\n        messagingModule.registerKey(\"exampleKey\");\r\n\r\n        // Send a test message\r\n        sendMessage();\r\n    }\r\n\r\n    private void sendMessage() {\r\n        final String key = \"exampleKey\";\r\n        final String message = \"Hello from MessagingPlugin!\";\r\n\r\n        // namespace ID can be found in your configuration file\r\n        final MineplexMessageTarget target = MineplexMessageTarget.matchingNamespace(\"exampleNamespace\");\r\n\r\n        messagingModule\r\n          .sendMessage(key, message, target)\r\n          .thenAccept(voidResult -> {\r\n                getLogger().info(\"Message sent successfully.\");\r\n            }).exceptionally(ex -> {\r\n                getLogger().severe(\"Failed to send message: \" + ex.getMessage());\r\n                return null;\r\n            }\r\n        );\r\n    }\r\n}\n```\n\nAnd then to listen to the messaging that will come in:\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport com.mineplex.studio.sdk.modules.messaging.event.AsyncMineplexMessageReceivedEvent;\r\nimport org.bukkit.event.EventHandler;\r\nimport org.bukkit.event.Listener;\r\nimport org.bukkit.plugin.java.JavaPlugin;\r\n\r\npublic class MessageListener implements Listener {\r\n\r\n    private final JavaPlugin plugin;\r\n\r\n    public MessageListener(final JavaPlugin plugin) {\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    @EventHandler\r\n    public void onMessageReceived(final AsyncMineplexMessageReceivedEvent event) {\r\n        if (\"exampleKey\".equals(event.getKey())) {\r\n            final String message = (String) event.getMessage();\r\n            plugin.getLogger().info(\"Received message: \" + message);\r\n        }\r\n    }\r\n}\n```\n\nAnd don't forget to register the listener in your main class!\n\n```java\ngetServer().getPluginManager().registerEvents(new MessageListener(this), this);\n```\n"
  },
  {
    "slug": "/sdk/modules/moderation",
    "title": "Moderation Module",
    "description": "How to use the Mineplex Studio Moderation Module to enforce rules on your projects.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.moderation.ModerationModule\" />\n\nThe Moderation Module is one of the built-in Studio Modules that allows you to manage and enforce player behavior within your projects. With this module, you can punish specific players through various means such as bans, mutes, or other restrictions. These punishments can be managed by your project's moderation team and tailored to fit the needs of your community.\n\n<Note title=\"Important Note\" type=\"danger\">\n  If you'd like to make your own punishment system, all punishments must go through this Module, this helps us track punishments, handle appeals and ensure accountability. Please do not create your own Punishment table / Punishment database, this will result in your project being rejected. You can create your own user interface / systems.\n</Note>\n\n## How everything connects\n\nThe Moderation Module integrates seamlessly with your project, ensuring a consistent approach to managing player behavior. By utilizing the provided methods, you can automate and customize moderation tasks to create a fair and enjoyable experience for all users.\n\nThe `Punishment` Object:\r\nThe Punishment object is central to the Moderation Module and contains the following fields:\n\n* **Identifier:** Unique ID for the punishment.\n* **Player Identifier:** UUID of the punished player.\n* **Moderator Identifier:** UUID of the moderator who applied the punishment.\n* **Start Timestamp:** When the punishment started.\n* **Applicable Projects:** Set of projects where the punishment applies.\n* **[Reason](#reasons):** Pre-defined reason for the punishment.\n* **Notes:** Additional information about the punishment.\n* **Removal Information:** Details about the removal of the punishment, if applicable.\n\nFor a full breakdown of the punishment object, see [the punishment object documentation](/docs/sdk/features/moderation/model)\n\n### Reasons\n\nInstead of allowing arbitrary text, the module uses a pre-defined list of reasons for consistency and clarity.\n\nThe `PunishmentReason` object includes:\n\n* **Punishment type:** Specifies the type of punishment (e.g., mute, ban).\n* **Display reason:** User-friendly explanation of the reason.\n* **Priority:** Importance level of the reason (important if they have multiple at once).\n* **Identifier:** Unique ID for the reason.\n* **Duration:** Length of time the punishment lasts.\n\nFor a full breakdown of the reasons and some defaults we've added for you, check out [the punishment reason documentation](/docs/sdk/features/moderation/reasons)\n\n## Method overview\n\nBelow is an overview of the key methods available in the Moderation Module:\n\n### listActivePunishments\n\n```java\n@NonNull CompletableFuture<@NonNull List<@NonNull Punishment>> listActivePunishments(\r\n            @NonNull UUID playerUUID, boolean includeGlobal);\n```\n\nRetrieves a list of active punishments for a specific player. You can include global punishments by setting includeGlobal to true.\n\n#### Example Usage:\n\n```java\nfinal UUID playerUUID = UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\");\r\nmoderationModule.listActivePunishments(playerUUID, true).thenAccept(punishments -> {\r\n    punishments.forEach(punishment -> {\r\n        System.out.println(\"Active Punishment: \" + punishment);\r\n    });\r\n});\n```\n\n### listAllPunishments\n\n```java\n@NonNull CompletableFuture<@NonNull List<@NonNull Punishment>> listAllPunishments(@NonNull UUID playerUUID, boolean includeGlobal);\n```\n\nRetrieves a complete list of punishments for a player, both active and inactive. Use includeGlobal to fetch global punishments.\n\n### applyPunishment\n\n```java\n@NonNull CompletableFuture<Punishment> applyPunishment(@NonNull Punishment punishment);\n```\n\nApplies a new punishment to a player. Returns the created punishment object.\n\n#### Example Usage:\n\n```java\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(BuiltInReason.HACKING_ESCALATION)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\r\n\r\nmoderationModule.applyPunishment(punishment).thenAccept(appliedPunishment -> {\r\n    System.out.println(\"Punishment applied: \" + appliedPunishment);\r\n});\n```\n\n### updatePunishment\n\n```java\n@NonNull CompletableFuture<Punishment> updatePunishment(@NonNull Punishment punishment);\n```\n\nUpdates an existing punishment with new information, such as adding notes or updating the removal information.\n\n### isMuted\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> isMuted(@NonNull UUID playerUUID);\n```\n\nChecks if a player is currently muted.\n\n#### Example Usage:\n\n```java\nmoderationModule.isMuted(playerUUID).thenAccept(isMuted -> {\r\n    if (isMuted) {\r\n        System.out.println(\"Player is muted.\");\r\n    } else {\r\n        System.out.println(\"Player is not muted.\");\r\n    }\r\n});\n```\n\n### isBanned\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> isBanned(@NonNull UUID playerUUID);\n```\n\nChecks if a player is currently banned.\n\n### hasActivePunishment\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> hasActivePunishment(@NonNull UUID playerUUID);\n```\n\nDetermines whether a player has any active punishment.\n\n### disableDefaultPunishmentCommand\n\n```java\nvoid disableDefaultPunishmentCommand();\n```\n\nDisables the default punishment command, allowing you to implement custom commands tailored to your project. See more information in the [punishment command guide](/docs/sdk/features/moderation/command)\n\n## Examples\n\n### Applying a Temporary Ban\n\n```java\nfinal PunishmentReasonImpl banReason = PunishmentReasonImpl.builder()\r\n    .type(PunishmentType.TEMP_BAN)\r\n    .displayReason(\"Excessive Toxicity\")\r\n    .priority(1)\r\n    .reasonIdentifier(\"toxicity\")\r\n    .duration(Duration.ofSeconds(3600 * 24));\r\n\r\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(banReason)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\r\n\r\nmoderationModule.applyPunishment(punishment).thenAccept(appliedPunishment -> {\r\n    System.out.println(\"Ban applied: \" + appliedPunishment);\r\n});\n```\n\n### Checking and Removing a Punishment\n\n```java\nfinal ModerationModule moderationModule = MineplexModuleManager.getRegisteredModule(ModerationModule.class);\r\nmoderationModule.listActivePunishments(playerUUID, false).thenAccept(punishments -> {\r\n    if (!punishments.isEmpty()) {\r\n        Punishment punishment = punishments.get(0);\r\n\r\n        final PunishmentRemovalImpl removalInformation = PunishmentRemovalImpl.builder()\r\n            .removeFromHistory(false)\r\n            .removalReason(\"Forgiven\")\r\n            .removalTimestamp(Instant.now())\r\n            .removalModerator(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n\r\n        punishment.setRemovalInformation(removalInformation);\r\n        moderationModule.updatePunishment(punishment).thenAccept(updated -> {\r\n            System.out.println(\"Punishment updated: \" + updated);\r\n        });\r\n    } else {\r\n        System.out.println(\"No active punishments found.\");\r\n    }\r\n});\n```\n"
  },
  {
    "slug": "/sdk/modules/world",
    "title": "World Module",
    "description": "How to use the Mineplex Studio World Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.world.MineplexWorldModule\" />\n\nThe World Module is one of the built-in Studio Modules that allows you to create, load, save, and generate worlds dynamically in your project. With the World Module, you can do anything from per-player stored plot worlds, to massive persistent generated adventure worlds, to ephemeral worlds created from map templates. `MineplexWorld`s are totally configurable, from their persistence, to their generation, to whether they exist only in memory. They also contain keyed Data Points that can be used to dynamically load points of interest from varied map templates - the days of hard coding specific locations in your game are long gone.\n\n## Creating a `MineplexWorld`\n\nIn order to create a new `MineplexWorld`, the World Module method `createMineplexWorld(MineplexWorldConfig)` must be executed with a completed and valid `MineplexWorldConfig`.\n\n### `MineplexWorldConfig`\n\nA `MineplexWorldConfig` is comprised of a few key options.\n\nFirst, you have the option to specify a `PersistentWorldConfig`. By default, this is `null`, indicating that the `MineplexWorld` will not be persistent. Setting this value to a valid `PersistentWorldConfig` will cause the created `MineplexWorld` to be persistent.\n\n#### `PersistentWorldConfig`\n\nThe only configuration needed in a `PersistentWorldConfig` is a `String` value for the `worldBucket` option. This value will determine the name of the data collection this persistent world will be stored within.\n\nNext comes the significant portion of the configuration process for a new `MineplexWorld`. The `WorldCreationConfig` comprises almost all of the options that control the makeup of the new world. This config cannot be `null`, and must be filled out by you so as to be valid.\n\n#### `WorldCreationConfig`\n\nWithin the `WorldCreationConfig` there are several configuration options, some of which conflict with each other. The first option is a `String` value for the `worldTemplate`, which defaults to `null`. If this is set to a value, any further options in the `WorldCreationConfig` will be ignored and the `MineplexWorld` will be initialized from the project map template named the same as the `String` value, if the template exists. If there is no such named template, then the world creation will fail. The next option is `voidWorld`, which can be `true` or `false`. This option defaults to `true`, in which case the created world will generate no terrain, and therefore all subsequent options in the `WorldCreationConfig` will be ignored. If this option is set to `false`, then the world will generate via the default generator, or a custom one if specified. A custom world generator can be defined for the new world via the following options:\n\n* `customChunkGenerator` will accept a `ChunkGenerator` implementation from the Bukkit API. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n* `customBlockPopulators` will accept a `Collection<BlockPopulator>`, based on `BlockPopulator` implementations from the Bukkit API. This can be directly specified, or included in the above `customChunkGenerator` if one is set. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n* `customBiomeProvider` will accept a `BiomeProvider` implementation from the Bukkit API. This can be directly specified, or included in the above `customChunkGenerator` if one is set. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n\nFinally, the seed for the world generation can be specified by setting the `customSeed` option to a given `Long` value. Defaults to `null`, in which case a random seed is used.\n\nAfter the `WorldCreationConfig` is complete, you need to make a determination as to what region format your new `MineplexWorld` should use, by setting the `worldRegionType` option to one of the `WorldRegionFormatType`s. Defaults to `WorldRegionFormatType.ANVIL`.\n\n#### `WorldRegionFormatType`\n\n* `ANVIL`: The Minecraft Java Edition standard region format developed by Mojang. Regions are stored as `.mca` files.\n\nFinally, you must specify whether your `MineplexWorld` should exist exclusively in memory via the `inMemoryOnly` option, or if it should instead utilize the storage of the container to load/unload chunks. By default this is set to `true`, in memory only, and this should work for most use cases. However, **if your map template is significantly large, or if players are able to cause the world to generate without a sufficiently tight boundary, the world may grow to a size that cannot be retained in memory. If this is the case, electing to keep the `inMemoryOnly` option set to `true` may result in undefined behavior or container crashes.**\n\n## Loading a `MineplexWorld` from Storage\n\nThere are two ways to load a persistent `MineplexWorld` from long-term storage. Your first option is the World Module method `loadMineplexWorld(String, String, WorldCreationConfig)`, which attempts to asynchronously download and load in the `MineplexWorld` with the specified ID from the specified `worldBucket`. If no `MineplexWorld` matches the ID in that `worldBucket`, then no `MineplexWorld` is loaded. Alternatively, you can use the World Module method `loadOrCreateMineplexWorld(String, String, MineplexWorldConfig)`, which also attempts to asynchronously download and load in the `MineplexWorld` with the specified ID from the specified `worldBucket`. However, in the case where this method does not find a matching `MineplexWorld`, it will create a new one using the provided `MineplexWorldConfig`.\n\n## Unloading a `MineplexWorld`\n\nYou are not able to force a `MineplexWorld` to unload, however you should not need to. Instead, you can use the World Module method `releaseWorld(MineplexWorld)` to indicate to the World Module that the world is no longer needed. At that point, the World Module will conduct save procedures for the `MineplexWorld` (if any are defined), then unload the world and free up any space.\n\n## Deleting a `MineplexWorld`\n\nThis functionality is specifically for unloaded persistent `MineplexWorld`s. **This should not be called for a loaded or ephemeral world.** To delete a stored persistent `MineplexWorld`, call the World Module method `deleteWorld(String, String)` with the `MineplexWorld` `worldBucket` and ID as the argument.\n\n## Getting a loaded `MineplexWorld`\n\nIn order to get a `MineplexWorld` that has already been loaded by the World Module, use the method `getLoadedMineplexWorld(String)`. **Note that this will require you to know the `MineplexWorld` ID.**\n\n## Data Points\n\nView full information on datapoints [here](docs/sdk/features/world/datapoints)\n\n# Examples\n\n## Creating a `MineplexWorld` from a Map Template\n\nLet's say we have some map templates in our project. We can dynamically create new `MineplexWorld`s based on those templates at runtime.\n\n```java\npublic MineplexWorld createFromTemplate(final String template) {\r\n    // Creates a new in-memory, ephemeral world from the given template using the ANVIL region format\r\n    return worldModule.createMineplexWorld(MineplexWorldConfig.builder()\r\n            .worldRegionType(MineplexWorldConfig.WorldRegionFormatType.ANVIL)\r\n            .worldCreationConfig(WorldCreationConfig.builder()\r\n                    .worldTemplate(template)\r\n                    .build())\r\n            .build());\r\n}\n```\n\n## Randomly Generating a `MineplexWorld`\n\nLet's say we don't want to use a template. We can create a new `MineplexWorld` using the random world generation built into the game. We can also make it persistent.\n\n```java\npublic MineplexWorld generateNewPersistentWorld(final Long seed) {\r\n    // Creates and generates a new persistent world cached on the filesystem\r\n    // using the anvil region format and a seed\r\n    return worldModule.createMineplexWorld(MineplexWorldConfig.builder()\r\n            .persistentWorldConfig(PersistentWorldConfig.builder()\r\n                    .worldBucket(\"Examples\")\r\n                    .build())\r\n            .worldCreationConfig(WorldCreationConfig.builder()\r\n                    .voidWorld(false)\r\n                    .customSeed(seed)\r\n                    .build())\r\n            .build());\r\n}\n```\n"
  },
  {
    "slug": "/sdk/thirdparty",
    "title": "Third Party Resources",
    "description": "Third Party Developer Resources in the Studio.",
    "content": "The Mineplex Studio comes packaged with several third party developer resources that make it easier than ever before to make a fantastic game in Minecraft. We are constantly evaluating the developer landscape and adding new resources to this list, so don't forget to check back here often!\n\n## Paper\n\n[Paper](https://papermc.io/software/paper) is a Minecraft game server based on Spigot, designed to greatly improve performance and offer more advanced features and API. This includes the [Adventure User Interface API](https://docs.advntr.dev/index.html), and the [md\\_5 BungeeCord chat API](https://www.spigotmc.org/wiki/the-chat-component-api/).\n\n## FloodGate\n\n[FloodGate](https://wiki.geysermc.org/floodgate/) is a Geyser addition allowing you to distinguish between Java Edition and Bedrock Edition players and to send Bedrock Edition players [Cumulus Forms](https://wiki.geysermc.org/geyser/forms/).\n\n## InvUI\n\n[InvUI](https://github.com/NichtStudioCode/InvUI) is a powerful library allowing you to efficiently and easily create and manage complex and detailed inventory-based GUIs for players to interact with in your projects.\n\n## HolographicDisplays\n\n[HolographicDisplays](https://github.com/filoghost/HolographicDisplays) is a library allowing you to display text and items to players using futuristic in-game Holograms. This API can be accessed using the `HologramUtil` in the Studio SDK.\n\n## ProtocolLib\n\n[ProtocolLib](https://www.spigotmc.org/resources/protocollib.1997/) is a library that allows read and write access to the [Minecraft protocol](https://wiki.vg/Protocol). It handles most of the overhead required with reflection and channel injection and provides wrappers to simplify packet modification.\n\n## LibsDisguises\n\n[Lib's Disguises](https://www.spigotmc.org/resources/libs-disguises-free.81/) is a library that lets you disguise any entity, as any entity. You can fully customize all these disguises, and even apply special effects to disguises. Examples include creating a player disguise called \"Notch\", but he's always sneaking, or disguising every creeper as a friendly villager. Part of the Lib's Disguises functionality is the ability to let players see their own disguises.\n\n## MythicMobs\n\n[MythicMobs](https://www.spigotmc.org/resources/⚔-mythicmobs-free-version-►the-1-custom-mob-creator◄.5702/) allows you to fully modify all attributes of monsters in your project, and even create your own mobs, bosses, and other many other fun mob-related things.\n\n## ModelEngine\n\n[Model Engine](https://mythiccraft.io/index.php?resources/model-engine—ultimate-entity-model-manager-1-16-5-1-20.389/) allows you to effortlessly create seemingly modded models for mobs in your project, without touching any configs.\n\n## Ignite\n\n[Ignite](https://github.com/vectrix-space/ignite) expands the limits of what you can do with just Paper, granting you access to Mixins and Access Wideners within the Paper ecosystem so that you have the option to directly modify the server to make the game of your dreams.\n"
  }
]