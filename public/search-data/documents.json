[
  {
    "slug": "/advanced/managed-databases",
    "title": "Managed Databases",
    "description": "How to create and manage industry-standard databases for Studio projects including MySQL, PostgreSQL, and MongoDB",
    "content": "# When to use Managed Databases\n\nManaged databases are a powerful way to store and query data for your Studio project. Unlike the built-in Data Storage Module, these are highly flexible and often include a robust open-source driver and ecosystem. However, they also have a separate pricing structure and carry addiitonal operational burden.\n\nGenerally speaking, it is best for new projects or Studio developers to start with the built-in Data Storage Module. However, if you are already familiar with a specific database technology, or have a specific use case that requires a more powerful database, you may want to consider using a managed database.\n\n# Creating a Managed Database\n\nManaged Databases can be created with `yaml` files (simliar to purchase definitions) in your project's `config/databases` directory. These files define the database type, and may in the future also allow for version changes and other configuration options.\n\n## Example `config/databases/my-database.yaml`\n\n```yaml\ndatabaseName: \"my-database\"\r\ntype: \"MYSQL\" # can be one of MYSQL, POSTGRES, or MONGO\n```\n\nIf you are using the Mineplex-provided GitHub Publisher action, adding this file to your repository on the default branch will cause a MySQL database named `my-database` to be created.\n\n# Using a Managed Database\n\nThe Mineplex SDK provides built-in functionality for retrieving a database driver client based on its unique name. This client can be used to perform any operations that the database driver supports. For MySQL and Postgres, the SDK provides a `JDBC` client, and for MongoDB, the SDK provides a `MongoClient` client.\n\nMore details on retrieving a managed database client instance will be added soon.\n"
  },
  {
    "slug": "/auxiliary/data-privacy",
    "title": "Data Privacy",
    "description": "Comprehensive guidelines for safeguarding data.",
    "content": "We are committed to ensuring that all user data is protected and secure. To achieve this, studios must take proactive steps to safeguard sensitive or potentially malicious data.\n\n## How We Represent Sensitive Data\n\nSensitive data that should not be shared with the general public is marked with the `@SensitiveData` annotation on the class, field, argument, or other appropriate location.\n\n### What Does This Mean?\n\n* **No Logging**: Sensitive data must not be logged into the console.\n* **No Public Display**: Sensitive data must not be displayed in Minecraft chat for all players to see.\n* **Controlled Access**: Access to sensitive data should be restricted to authorized personnel only.\n* **Regular Audits**: Conduct regular audits to ensure compliance with data protection policies.\n\nViolations of these rules will result in repercussions for your studio, as defined in our Studio End User License Agreement.\n\n## Best Practices for Data Protection\n\nTo further ensure data privacy, studios should adhere to the following best practices:\n\n* **Minimize Data Collection**: Only collect data that is necessary for your operations.\n* **Data Anonymization**: Anonymize data whenever possible to protect user identities.\n* **Secure Coding Practices**: Follow secure coding practices to prevent vulnerabilities.\n* **Regular Updates**: Keep all systems and software up to date with the latest security patches.\n* **Training**: Provide regular training for staff on data protection and privacy best practices.\n\n***\n\n## Reporting Data Mishandling\n\nIt is essential that any violation of our data privacy policies be reported to us immediately, whether by the studio responsible or by a player who notices the issue. Prompt reporting allows us to take corrective action, such as removing sensitive data from logs, and remedy the situation.\n\n### How to Report\n\n* **Email**: Contact us at `support@mineplex.com`.\n* **Discord**: Ping us in the Studio Partner Discord after sending an email if the matter is urgent.\n\nBy adhering to these guidelines and promptly reporting any mishandling, you help us maintain a secure environment for everyone.\n"
  },
  {
    "slug": "/auxiliary/faq",
    "title": "Frequently Asked Questions",
    "description": "A set of frequently asked questions and answers.",
    "content": "### Custom Lobbies and Hubs\n\nThe following guidance applies to custom lobbies and hubs that exist outside of your primary game mode and serve the primary purpose of hosting players and re-queueing them for other games:\n\n* This is discouraged. We want to flatten the queueing within the Studio as much as possible, such that players queue directly for your game from the Mineplex Hub. We are working on figuring out a way for your purchase offerings and different game modes to be embedded or exposed within our lobby.\n* Please consider the genuine need for a secondary lobby: you should only implement this if it's of significant importance to your game functionality, for example - a cosmetic system that cannot be represented in games, only a Lobby. We will not allow lobbies just for linking games together and letting people talk.\n* However, if you need a second lobby, you should implement two games behind the scenes. These should probably be in the same game namespace. For example, `CakeWars-Lobby` and `CakeWars-Game` in the `Mineplex` namespace. In most cases, the lobby should probably be a relatively empty project that uses `DYNAMIC` allocation.\n\n### Manual Game Maintenance\n\nThe following guidance applies for manual game support operations, such as restarting \"unhealthy\" games:\n\n* We will be adding a health check mechanism that you can implement inside the game code. We will call this regularly and initiate restart events if an unhealthy signal is returned. More details on this should be released soon.\n* If you have an additional need to restart a game, adjust server settings, or perform other manual operational interventions, please reach out to our support team.\n* If you will be using our provisioned databases (such as MySQL, managed by Mineplex), you need to follow best-practices for automatically running migrations on game startup (consider something like Flyway or Liquibase). Similarly, you need to ensure backwards compatibility with changes since we may run different versions of your game at the same time during update events.\n\n### Manually Transferring Players\n\nThe following guidance applies for questions around manually transferring players between server instances and games:\n\n* We will provide an API you can poll that returns a list of active games in a namespace. You can manually transfer players between these with a piece of code. This should be used sparingly and intentionally, as we expect most player transfers to occur via our matchmaking system.\n"
  },
  {
    "slug": "/auxiliary",
    "title": "Auxiliary Information",
    "description": "A set of information surrounding the Mineplex Studio system.",
    "content": "# Auxiliary Information\n\nThis page provides a basic overview and links to detailed information about the Mineplex Studio system, including data privacy, FAQs, moderation, publishing guidance, the review process, and security guidelines.\n\n* Understand our commitment to protecting user data and the steps you need to take to ensure data privacy. [Learn More](/docs/auxiliary/data-privacy)\n* Find answers to common questions about using Mineplex Studio. [Learn More](/docs/auxiliary/faq)\n* Learn about our moderation to maintain a positive community. [Learn More](/docs/auxiliary/moderation)\n"
  },
  {
    "slug": "/auxiliary/moderation",
    "title": "Moderation Information",
    "description": "Information about our moderation processes",
    "content": "## Player Transparency\n\nGuidelines to ensure clear communication and accessibility of rules for players.\r\nTo ensure fair play and maintain trust, the following guidelines must be followed:\n\n* **Clear Communication**: Players must always be informed of the reason for their punishment.\n* **Accessibility of Rules**: Your game rules must be published on your Discord server or website and be accessible in-game.\n* **Distinct Game Rules**: If you have multiple games with different rules, it must be clearly communicated to players at the start of each game.\n\n## Studio Responsibility\n\nSpecific responsibilities of studios in enforcing their game rules.\r\nStudios are responsible for enforcing their specific game rules. Here are some examples (optional to enforce) of rules you might include:\n\n* **No Teaming**: Ensuring that players do not form teams in solo game modes or where teaming is not allowed.\n* **No Ghosting**: Preventing players from using outside communication to gain an unfair advantage or providing information to living players after being eliminated.\n* **No Griefing**: Protecting players from actions that intentionally disrupt their gameplay experience, such as destroying another player's creations or resources.\n* **Exploits and Bugs**: Prohibiting the use of game exploits or bugs to gain an unfair advantage and requiring players to report such issues.\n\nThis is not an exhaustive list; you are welcome to create and enforce your own rules.\n\n## Mineplex Responsibility\n\n**Description:** Broader moderation issues managed by Mineplex to maintain server-wide integrity.\r\nMineplex is responsible for addressing broader moderation issues that affect the entire server. This includes:\n\n* **Hacking**: Detecting and taking action against players using unauthorized mods or hacks to gain unfair advantages.\n* **Chat Offenses**: Monitoring and moderating in-game chat to prevent and address inappropriate language, harassment, and other violations of chat rules.\n* **Skin/Name Issues**: Ensuring that player skins and usernames adhere to community guidelines and do not include offensive or inappropriate content.\n* **Account Security**: Taking measures to protect player accounts from unauthorized access or compromise.\n* **Cheating Reports**: Providing a streamlined process for players to report cheating or other rule violations.\n\n## Additional Best Practices\n\n**Description:** Recommended practices to enhance player experience and community engagement.\r\nTo enhance the overall player experience and maintain a positive community, consider implementing the following practices:\n\n* **Regular Updates**: Keep your rules and guidelines up to date with regular reviews and adjustments based on community feedback and emerging issues.\n* **Education and Awareness**: Provide resources and training for moderators and players about the importance of fair play and community guidelines.\n* **Community Engagement**: Foster a positive community environment by encouraging player participation in discussions, events, and feedback sessions.\n* **Transparency in Actions**: When taking action against players, provide clear explanations and evidence to maintain transparency and trust.\n* **Moderation Tools**: Utilize advanced moderation tools and technologies to efficiently detect and address rule violations.\n* **Reward Positive Behavior**: Implement systems to reward players who consistently demonstrate positive behavior and sportsmanship.\n\nBy adhering to these guidelines and continuously striving to improve your moderation processes, you help create a safe and enjoyable environment for all players.\n"
  },
  {
    "slug": "/auxiliary/publishing",
    "title": "Publishing Projects",
    "description": "Learn how to publish and monetize your Studio game",
    "content": "As a Studio developer, you have the ability to interact with three different Mineplex hosted environments which serve different purposes. These are:\n\n* Development, or `dev` (which is allocated for developers and gives an automatic, unique IP when running start)\n* Staging, or `stg` (which is allocated for developers and has the lobby IP of `mc-stg.mineplex.com`)\n* Production, or `prod` (which is allocated for the general public has the lobby IP of `mineplex.com`)\n\n## Deployment Stages\n\n<Step>\n  <StepItem title=\"Development\">\n    Development containers should be used to verify your game works as expected, with your team.\r\n    You can generate a development container using the `studio start` command.\n  </StepItem>\n\n  <StepItem title=\"Staging\">\n    When you're happy with your changes, pushing them to your github repository will\n\n    This environment generally functions identically to the Production environment, with several key differences:\n\n    * There is an in-game override for free Crowns which can be used for testing in-game purchases\n    * The underlying hardware has additional limitations including lower network bandwidth and smaller compute resources\n    * Crown purchases to game modes (whether they are made with free or paid Crowns) are not paid out to developers, but can be manually refunded at any time\n    * Staging is intended for game development and testing, and is monitored regularly for misuse\n\n    When you push code changes to your project's GitHub repository, the Studio GitHub Publisher action will automatically build your project into a TAR file, upload it to the Studio, and upload your purchase definition files and game configuration to Mineplex. You can then launch your game mode within the Studio Staging environment identically to the Production environment, with the restrictions listed above.\n  </StepItem>\n\n  <StepItem title=\"Review\">\n    Once your game is ready for publishing, you must initiate a Game Review. During a Game Review, we perform static analysis and gameplay testing on your code (through both manual and automated means) to ensure that your game complies with the Mineplex terms of service and Studio guidelines. Submissions are processed on a first-come, first-serve basis, and reviews may take up to one week. In the event that your game is rejected, you can make the necessary adjustments and re-submit as soon as you are ready for an additional review.\n\n    You can read more information about our review process on this handy [information page](/docs/auxiliary/review-process).\n  </StepItem>\n\n  <StepItem title=\"Production\">\n    After your project has passed the review process, it will be automatically published to Production. Players in the general public can then discover and play your game, as well as spend Crowns on it which will be paid out (per your profit-sharing agreement) monthly!\n  </StepItem>\n</Step>\n\n## GitHub Publishing Action\n"
  },
  {
    "slug": "/auxiliary/review-process",
    "title": "Review Process",
    "description": "Information on how we review games",
    "content": "<Note title=\"Coming Soon\" type=\"success\">\n  This page is currently under construction. More information will be available soon.\n</Note>\n"
  },
  {
    "slug": "/auxiliary/security-guidelines",
    "title": "Security Guidelines",
    "description": "Rules about what you can and cannot do with the Studio platform.",
    "content": "We’re excited by the opportunities the Studio provides for innovation. However, the security of our platform is an essential and top priority. Players trust us to keep them and their data safe, and we therefore have strict security guidelines that all Studio developers must adhere to.\n\n<Note type=\"danger\" title=\"Warning!\">\n  Violation of the Studio security guidelines may lead to disciplinary actions including, but not limited to, account suspension, Crown payout confiscation, and legal action.\n</Note>\n\n## Security Rules and Prohibited Implementations\n\nThe following actions are prohibited in all Studio projects without our express written permission:\n\n* **External Network Calls**: No calls to external networks are allowed.\n* **Network Eavesdropping**: Prohibited activities include packet listeners or DNS/IP scanning.\n* **API Fuzzing**: No fuzzing, DoS, DDoS attacks, or unapproved load tests against Mineplex services.\n* **Data Exfiltration**: No unauthorized transfer of data, plugins, or assets.\n* **Java Native Interface (JNI)**: Usage of JNI is prohibited.\n* **Process Runners**: No unauthorized execution of external processes.\n* **Network Device Manipulation**: Activities like IP table access, ARP cache manipulation, and similar are forbidden.\n* **Container Runtime Access**: No attempts to access, interact with, or manipulate the underlying container runtime or Studio agent process.\n\n## Best Practices for Security\n\nTo further enhance security, studios should adhere to the following best practices:\n\n* **Secure Coding**: Follow secure coding practices to minimize vulnerabilities.\n* **Regular Updates**: Keep your development environment and dependencies up-to-date.\n* **Access Control**: Implement strict access control measures to ensure only authorized personnel can access sensitive areas of your project.\n* **Code Reviews**: Conduct regular code reviews to identify and mitigate potential security issues.\n* **Threat Modeling**: Regularly perform threat modeling to anticipate and defend against potential security threats.\n* **Incident Response Plan**: Have a clear incident response plan in place to quickly address any security breaches.\n\n## Reporting Security Issues\n\nIt is crucial that any security vulnerabilities or violations are reported immediately to maintain the integrity of our platform.\n\n### How to Report\n\n* **Email**: Contact us at `support@mineplex.com`.\n* **Discord**: Notify us in the Studio Partner Discord after sending an email for urgent issues.\n\nBy following these guidelines and promptly reporting any security concerns, you help us ensure a safe and secure environment for everyone.\n\n## FAQ\n\n### What should I do if I'm unsure whether an action is prohibited?\n\nIf you are unsure whether a specific action is allowed, please contact us in the Studio Partner Discord for clarification before proceeding.\n\n### Can I request permission for a prohibited action?\n\nYes, you can request permission by contacting us at `support@mineplex.com`. Provide a detailed explanation of your request and the reasons for it.\n\n### What happens if I accidentally violate a security rule?\n\nAccidental violations should be reported immediately. We will investigate the incident and work with you to resolve the issue, taking into account the nature and impact of the violation.\n\nBy adhering to these security guidelines and best practices, you contribute to the overall safety and trust of our platform.\n"
  },
  {
    "slug": "/cli/commands",
    "title": "Command-Line Interface (CLI) Reference Guide",
    "description": "This page contains a reference guide to all commands in the Studio CLI.",
    "content": "## Commands\n\n### `studio check`\n\nThis command validates your local environment and ensures that you have all the necessary dependencies (such as the GitHub CLI) installed.\r\nYou can also view your current authentication status by running `studio check`.\n\n### `studio login`\n\nTo use the CLI, you must log in to your Mineplex Studio Partner account. This is separate from your in-game account, and should be created from our website at [studio.mineplex.com](https://studio.mineplex.com).\n\nThen, you can run a command like `studio login -u example@example.com -p testpassword` to log in to your account.\n\nAfter logging in, the Studio CLI stores a long-lived authentication token in your system home directory with the file name `.mineplex-studio-credentials`.\n\nYou should generally never need to access or manage this manually, and should use the `logout` command to log out and invalidate existing tokens rather than deleting this file directly.\n\n### `studio logout`\n\nTo log out of your account, run `studio logout`. This invalidates your token and any active sessions, and deletes the authentication token from your system home directory.\n\n### `studio create-project`\n\nYou can run this command to create a Studio project. This will also create a boilerplate project in your current directory, and a GitHub repository\r\nfor your project. By default, the repository that the Studio CLI creates will be private, and will include an Actions secret for Studio deployments.\r\nYou can run `studio help create-project` for more information on the command.\n\nThere are several required arguments for this command:\n\n* `--name`: The name of your project. This should typically be a case-insensitive name like `cake-wars`.\n* `--repository`: The name of the GitHub repository (which will be created in GitHub by the Studio CLI). This must include your GitHub username or GitHub organization name, separated by a slash. For example, `Mineplex-LLC/CakeWars`.\n\nIf you wish to further customize your project, you may also append the following optional arguments:\n\n* `--description`: A description of your project. This will be used in the Studio control plane and is visible to your collaborators from our web interface.\n* `--groupId`: The Gradle group ID for your project. This is conventionally a reverse domain name, such as `com.mineplex`.\n* `--artifactId`: The Gradle artifact ID for your project. This is conventionally the name of your project without any special characters, such as `cakewars`.\n\nA full example of this command is `studio create-project --name CakeWars --repository Mineplex-LLC/CakeWars --description \"A fun game!\" --groupId com.mineplex --artifactId cakewars`.\n\nAfter you run this command, the Studio CLI automatically:\n\n1. Creates a private GitHub repository in the `Mineplex-LLC` org with the name `CakeWars` and clones it to your current working directory.\n2. Creates a Studio project within the Mineplex control plane with the name `CakeWars` and description `\"A fun game!\"`.\n3. Creates a deployment token for the project with the Mineplex control plane, and uploads it to the `CakeWars` GitHub repository as a secret.\n4. Generates and downloads a boilerplate project from the Mineplex control plane, and places it in your local repo (but does not commit or push it).\n\n### `studio list-projects`\n\nThis command lists all of your Studio projects. It will display the name, repository, and description of each project.\n\n### `studio build`\n\nBuilds the project in the working directory into a plugin JAR using the default Studio CLI settings and Gradle integration.\n\n### `studio start`\n\nThis command starts a Development Container for your project on the Mineplex staging network. It will automatically build the project in the working directory into a plugin JAR and watches the file system to alert you when changes are ready for hotswap.\n\nUsing Development Containers allows you to test your code in a production-like environment. After running this command, note the IP address that it prints to the console. You can connect to this IP address from your Minecraft client to test your project.\n\nFor security, development containers always have a player allowlist based on account UUIDs. You can manage the allowlist after running `studio start` for the first time, and can also save it to disk to avoid manually re-entering after each restart.\n\nOptional flags:\n\n* `--no-jar-build`: skips the automatic JAR build step, which may be useful if you have already built the plugin file or if you don't want to use the CLI's default Gradle integration.\n* `--plugin-path`: the relative path to the built plugin JAR file for your project; defaults to the JAR built by the CLI (using Gradle).\n\nAfter you run `studio start`, the CLI will continue to listen for additional commands that control your Development Container. These commands are:\n\n* `r`: Re-upload project assets and restart the Minecraft game process\n* `r-hard`: Forcefully restart the entire container (equivalent to `studio stop && studio start`)\n* `l`: Retrieve game process logs\n* `s`: Shutdown the running container fully (equivalent to `studio stop`)\n* `allowlist [add/remove] [player UUID]`: Add or remove a player by UUID to the container allowlist\n* `allowlist list`: Print a list of all players currently on the container allowlist\n* `allowlist save`: Save the current allowlist locally (per-project); it will be automatically restored on container startup\n* `allowlist clear`: Remove all existing players from the container allowlist\n\nIf you kill the CLI process, the Development Container will stay alive in the background. By default, containers live for a two-hour time duration, after which they are automatically cleaned up. You can only have one container running at a given time per Studio account.\n\n### `studio stop`\n\nForcefully shut down a running container. This can be useful if your container enters an unexpected state and is unresponsive to other commands, but it is generally faster to use the `r` command on a running container to hotswap new code and assets during development.\n\n## Organization Management\n\nStudio Organizations are groups of accounts that share projects and subscriptions. They are generally used to represent groups of developers working on the same game. Members of an Organization can have one of three roles:\n\n* Member: can perform read-only actions and use Development Containers\n* Admin: all the permissions of a Member, plus user management rights\n* Owner: all the permissions of an Admin, and cannot be removed from the Organization or demoted\n\n### `studio list-orgs`\n\nList the Organizations your account is authorized to act on.\n\n### `studio create-org --name [MyOrganization]`\n\nCreate a Studio Organization with the specified name. Note that names are globally unique and cannot be changed after the organization is created.\n\n### `studio org-add-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAdd an existing Studio account to the specified organization.\n\n### `studio org-list-users --org [MyOrganization]`\n\nList all of the users who are in the specified organization.\n\n### `studio org-remove-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAs an Admin or Owner, remove the specified user from the organization.\n\n### `studio org-promote-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAs an Admin or Owner, promote the specified Member to an Admin.\n\n### `studio org-demote-user --org [MyOrganization] --username [SomeOtherDeveloper]`\n\nAs an Admin or Owner, demote the specified Admin to a Member.\n\n### `studio org-redeem-promo-code --org [MyOrganization] --code [MyPromoCode]`\n\nAs an Admin or Owner, redeem a Mineplex-provided promo code for beta functionality or free or discounted subscriptions.\n\n### `studio org-transfer-project --org [MyOrganization]`\n\nTransfer the project within the current working directory to be owned by the specified Organization.\n\n### `studio org-list-projects --org [MyOrganization]`\n\nList the projects owned by the specified Organization.\n"
  },
  {
    "slug": "/cli",
    "title": "Command-Line Interface (CLI) Overview",
    "description": "An introduction to the Mineplex Studio CLI.",
    "content": "![Banner](/images/cli.png \"Mineplex Studio CLI\")\n\nThe Studio CLI is a command-line interface for Windows, Mac, and Linux that allows you to create and develop content on Mineplex.\n\nWhile you can interact with our control plane API directly (and may wish to in custom build and deployment environments), the CLI provides a simple, intuitive mechanism for getting started with the Mineplex Studio platform. It wraps helpful functionality for both beginners and advanced users, including project scaffolding, hotswapping development builds, and more.\n"
  },
  {
    "slug": "/cli/installation",
    "title": "CLI Installation",
    "description": "Instructions to install the Studio CLI",
    "content": "The Mineplex Studio CLI is distributed as a pre-built binary file for Windows, Mac, and Linux.\n\nYou can download the Studio CLI for your platform:\n\n<CardGrid>\n  <Card title=\"Windows\" subtitle=\"Download\" variant=\"small\" href=\"https://public-mineplex-content.s3.amazonaws.com/studio-cli-win.exe\" external=\"true\" />\n\n  <Card title=\"Mac\" subtitle=\"Download\" variant=\"small\" href=\"https://public-mineplex-content.s3.amazonaws.com/studio-cli-macos\" external=\"true\" />\n\n  <Card title=\"Linux\" subtitle=\"Download\" variant=\"small\" href=\"https://public-mineplex-content.s3.amazonaws.com/studio-cli-linux\" external=\"true\" />\n</CardGrid>\n\nYou may wish to rename the Studio binary file and add it to your path or project directory. In our documentation, we use the `studio` command, which references a version of the binary file that has been added to the system path.\n\nOn a Windows system, you can add executables to the system path from the Environment Variables menu in the Control Panel. On a Mac or Linux system, you can add executables to the system path by editing the `~/.bashrc` or `~/.zshrc` file.\n\nNote that there are peer dependencies to the Studio CLI. Specifically, you must have the GitHub CLI installed (as well as Java to fully utilize optional CLI functions).\r\nTo validate your system setup, run the `studio check` command in your terminal.\n"
  },
  {
    "slug": "/configuration",
    "title": "Project Configuration",
    "description": "How to adjust your project configuration",
    "content": "## Adjusting Game Properties\n\nIn order to configure your project, we provide a file! This allows you to change your project's behaviour.\n\nAll Studio projects have an auto-generated file, see below for the file structure.\n\n<FileTree>\n  <Folder name=\"config\" label=\"config\">\n    <File name=\"game-properties.yaml\" label=\"game-properties.yaml\" />\n  </Folder>\n</FileTree>\n\n## Example Properties File\n\n```yaml\n# DO NOT EDIT: this project ID is unique to your repository and should not be changed\r\nprojectId: 6546c318242da444451434bd\r\n\r\n# This is a mandatory user-specified identifier that can be used to share products and data between games.\r\n# If you wish to share data (including player stats, purchases, leaderboard rankings, and more) between multiple Studio projects, \r\n# you should sync this attribute. This field is internal, and is not visible within your game. \r\nnamespaceId: MineplexStudio \r\n\r\ngame:\r\n  # a name given to your game\r\n  name: MicroBattles \r\n  # The visibility of your game. Options: HIDDEN, PLAYTEST, PUBLIC\r\n  visibility: PUBLIC \r\n  # A multiline description for your game\r\n  description: [\"§fBe the §eLast Team §fstanding\", \"§fThe §bGlass Barrier §fwill disappear after §c10 seconds\"] \r\n  # The item to be displayed in the game explorer\r\n  iconItem: \"minecraft:beacon\"\r\n  # A category for your game\r\n  category: \"PvP\"\r\n  # Any tags you'd like to add to your game\r\n  tags: [ \"Team\", \"Strategy\" ]\r\n  # The display name of your game in the lobby menu\r\n  displayName: \"Micro Battles\"\r\n  # players whitelisted to test your game on staging\r\n  playtestPlayerIds: [\"b2cc0572-9634-4210-baa6-803d7cb4f511\", \"0c6b231a-1f12-49b6-a1fc-1a9279de277c\"]\r\n  # an icon url to show on the bedrock compass\r\n  iconURL: \"https://fastly.picsum.photos/id/21/200/200.jpg?hmac=a2iQ6UhOjpU6jn7QSsCpk1CiiKTxmW1R4UivDsv-n8o\"\r\n  # supported Minecraft platforms\r\n  supportedPlatforms: [\"JAVA\", \"BEDROCK\"]\r\n\r\n# matchaker configuration\r\nmatchmaker:\r\n  # an allocation mode (See details below)\r\n  allocationMode: DYNAMIC \r\n  # Only can be set when allocationMode is STATIC\r\n  maxReplicas: 4 \r\n  # The minimum players for an instance (server) to start up\r\n  minPlayers: 2\r\n  # The maximum amount of players an instance of your game holds\r\n  maxPlayers: 16\r\n  # Determines if players should be allowed to join an instance of your game that is already running\r\n  allowPlayerBackfill: false\r\n\r\n# any mineplex provided dependencies you'd like to add - requires Organization account\r\ndependencies:\r\n  libraries:\r\n    - MYTHIC_MOBS\r\n    - MODEL_ENGINE\r\n    - MYTHIC_DUNGEONS\r\n    - MYTHIC_CRUCIBLE\n```\n\n## Matchmaking and Game Allocation\n\n### STATIC mode:\n\n* Your game will be allocated as a set of stateful containers. You can specify an additional property for the maximum number of containers (maxInstanceCount) and we will automatically provision additional servers based on the actual player load over time, up to that maximum count.\n* In a static mode, players can queue for a specific instance of your game. For example, Clans-1, Clans-2, and so on.\r\n  Your code should not make any assumptions about the actual number of servers at any given time. If there are no players on Clans-2, we may deallocate that instance until someone re-queues for Clans-2, at which point the server will be re-allocated (with its state restored).\n* We reserve the right to restart containers as needed, but will fire off an event to your game before doing so. For example, if we need to restart Clans-2 to apply a code update that you published, our orchestration server will give your game a grace period to shut down before it is automatically restarted. This will be very similar to a SIGTERM and SIGKILL lifecycle in a process -- the game gets a warning first, giving it a chance to gracefully handle a shutdown, and then it is forcefully shut down at some point in the future. Our systems will make a best-effort attempt to avoid restarting instances with active players, and we will work on exposing the grace period as a parameter to you. We are still figuring out the best way to handle this case, but want for you to plan in advance for it.\n\n### DYNAMIC mode:\n\n* Your game will be allocated on-demand in response to matchmaking and queuing events. For example, if your game requires four players to begin, and eight players enter the queue, two instances of the game will be created automatically by our matchmaking and orchestration systems behind the scenes. These players are also transferred automatically once your game enters a healthy state as per our SDK lifecycle management.\n* In a dynamic mode, players queue for your game mode itself, and are allocated to game instances as they become available. For example, players may queue for SSM and end up being assigned to any number of different servers, as per our orchestration logic.\n* Your game must interact with our lifecycle SDK to indicate when it is safe or unsafe to shut down the game. This is usually between minigame iterations. Our systems make a best-effort attempt to keep the container alive, and may add more players during this time (it's like a game lobby window). However, in some cases (such as if insufficient players are in the game mode), the container may be shut down. Once again, we will deliver a shutdown event and a grace period in case you want to re-queue players for another mode or lobby before the container is killed. Otherwise, players are sent back to the Mineplex hub.\n\n## Dependencies\n\n<Note type=\"note\">\n  This feature requires an Organization subscription, individual subscriptions cannot use this feature!.\n</Note>\n\nMineplex has partnered with a number of leading plugin authors to support unique and innovative game experiences within the Studio. These plugins can be enabled using the `dependencies.libraries` configuration property within the `game-properties.yaml` file.\n\nSome of the values that are currently supported are:\n\n* `MYTHIC_MOBS`: This plugin allows you to create custom mobs with unique abilities and behaviors.\n* `MODEL_ENGINE`: This plugin allows you to create custom models for mobs, items, and blocks.\n* `MYTHIC_DUNGEONS`: This plugin allows you to create custom dungeons with unique mobs, loot, and mechanics.\n* `MYTHIC_CRUCIBLE`: This plugin allows you to create custom PvP arenas with unique mechanics and objectives.\n\n## Game Explorer Configuration\n\nPlayers can find your game from the Mineplex Lobby using the compass icon and navigation menu. In the game explorer menu, they are able to see a list of attributes that describe your game which can be configured in the `game-properties.yaml` file. These attributes include:\n\n* `game.displayName`: (string) the name of your game as shown to players in the game explorer menu. Unlike the project name (in `game.name`, which is used internally), this name can contain spaces and special characters.\n* `game.visibility`: (`HIDDEN`, `PLAYTEST`, or `PUBLIC`) determines if your game is visible to players in the staging game explorer menu. Most games that are actively being developed and iteratively released (they are not in an initial draft stage) should be set to `PLAYTEST`. This setting only impacts the staging environment, as all approved and published games are visible in production.\n* `game.description`: (string\\[]) a brief description of your game, separated into lines.\n* `game.iconItem`: (string) the item that represents your game in the game explorer menu. This should be a valid Minecraft item ID, such as `minecraft:diamond_sword`.\n* `game.iconURL`: (string) a URL to an image that represents your game in the game explorer menu. This is only visible in Bedrock clients.\n* `game.category`: (string) the category that your game falls under in the game explorer menu. Examples include `Survival`, `PvP`, and `Parkour`.\n* `game.tags`: (string\\[]) a list of tags that describe your game. These can describe categories, but can also describe attributes of the game such as `Team`, `Sandbox`, and so on.\n* `game.playtestPlayerIds`: (string\\[]) a list of player UUIDs that are allowed to playtest your game on the staging network. This is useful for sharing your game with a select group of players before it is published to the Mineplex network.\n\n## Specialized Tags\n\nBelow is a list of specialized tags that you can apply in your `game-properties.yaml` that can affect your game when published.\n\n* `Arcade` - Your game will be shown and playable via the Mixed Arcade system. Note that there are additional requirements you must meet to use this tag that can be found [here](/docs/sdk/features/queueing#tag-queue)\n\n## Advanced Configuration and Overrides\n\nThere are a set of internal overrides that can be applied to your project by the Mineplex team. These unlock advanced or non-standard functionality, which is generally available, but not exposed in the `game-properties.yaml` file. We currently support:\n\n* **Persistent volumes**\n  * When this setting is enabled, a persistent network file system will be attached to each of your game servers. It will be consistent based on the game identifier (for example, `Game-1` and `Game-2` will have unique file stores, but the file system within each is persistent across server restarts).\n  * The file system is always mounted at the `/data` directory.\n  * This feature is only supported for games that use the `STATIC` allocation mode.\n* **Health check modifications**\n  * Changing the default health check wait time after server initialization. This may be useful if your games take a long time to start up, and you want to avoid the health check failing prematurely.\n  * Changing the default health check interval. This may be useful if your game may be expected to ignore the Health SDK or not respond to it in a timely manner.\n\nIf you are interested in enabling these features, please reach out to us via a support request.\n"
  },
  {
    "slug": "/example-project/dragons/core-gameplay/dragon",
    "title": "The Dragons",
    "description": "Creating the dragons",
    "content": "![Dragon](https://i.makeagif.com/media/3-08-2021/DGZ1vK.gif \"Dragon\")\n\nThe dragons: where would we be without them? A very boring minigame, that's for sure!\n\nIn order to make our games' core goal actually work, we need to spawn some dragons!\n\n<Step>\n  <StepItem title=\"Create the listener class\">\n    ```java\n    @Slf4j\r\n    public class DragonSpawnListener extends AbstractStateBasedListener {\r\n        public DragonSpawnListener(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.STARTED);\r\n        }\r\n    }\n    ```\n\n    🔗 [DragonSpawnListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/dragons/DragonSpawnListener.java)\n  </StepItem>\n\n  <StepItem title=\"Register our listener instance\">\n    In our main `DragonsGame` class, as always, we must register our state listener!\n\n    ```java\n    @Override\r\n    public void setup() {\r\n\r\n        // after our existing listener code!\r\n        this.listeners.add(new DragonSpawnListener(this, this.dragonsPlugin));\r\n\r\n        // ...\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Create a method to spawn a dragon!\">\n    We'll need to spawn in some dragons, time for a method to do it!\n\n    We'll start by adding a static list of dragon names to our class, these will be randomly picked from and assigned to each Dragon as it spawns!\n\n    ```java\n    private static final List<String> dragonNames = Arrays.asList(\r\n        \"Douglas\", \"Deidra\", \"Daphne\", \"Dexter\", \"Dorian\", \"Damien\", \"Darla\", \"Dylan\", \"Darius\", \"Delilah\",\r\n        \"Darwin\", \"Dawn\", \"Donovan\", \"Diana\", \"Dante\", \"Dakota\", \"Desmond\", \"Dominic\", \"Delaney\", \"Dahlia\");\n    ```\n\n    Then we'll use these names, and use Paper's mob spawning API to let us spawn a **Bukkit EnderDragon** (this will get confusing in a bit, for now, this is a Bukkit entity, keep that in mind).\n\n    ```java\n    private EnderDragon spawnDragon() {\r\n        return this.game\r\n            .getSpectatorLocation()\r\n            .getWorld()\r\n            .spawn(this.game.getSpectatorLocation().clone().add(0, 30, 0), EnderDragon.class, d -> {\r\n                d.customName(\r\n                        Component.text(dragonNames.get(new Random().nextInt(dragonNames.size())) + \" The Dragon\")\r\n                                .color(NamedTextColor.LIGHT_PURPLE)\r\n                                .decorate(TextDecoration.BOLD));\r\n            });\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Hit the method\">\n    Now let's override our setup method, this gets called on state change to in progress, as we've seen before!\n\n    ```java\n    @Override\r\n    public void register() {\r\n        super.register();\r\n\r\n        // bukkit dragon\r\n        final EnderDragon enderDragon = DragonSpawnListener.this.spawnDragon();\r\n\r\n    }\n    ```\n\n    We'll be using this in a new class.\n  </StepItem>\n\n  <StepItem title=\"Create a new holding class for our dragon\">\n    To keep our code clean and maintain object orientated standards, we'll be creating a MineplexDragon class. This part will become pretty pivotal soon.\n\n    🔗 [MineplexDragon class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/dragons/MineplexDragon.java)\n\n    ```java\n    public class MineplexDragon {\r\n        private final DragonsGame game;\r\n        private final EnderDragon entity;\r\n\r\n        public MineplexDragon(final DragonsGame host, final EnderDragon entity) {\r\n            this.game = host;\r\n            this.entity = entity;\r\n        }\r\n    }\n    ```\n\n    **We'll expand upon this object in the next tutorial page, as it gets pretty spicy.**\n  </StepItem>\n\n  <StepItem title=\"Hold them in a list of dragons\">\n    When we come to add extra features to our game, like a scoreboard or sparkles, we'll need to know which dragon instances we have flying around!\n\n    To do this, we'll store the list of our created dragon objects in a field within our `DragonSpawnListener`.\n\n    ```java\n    @Getter\r\n    private final List<MineplexDragon> dragonList = new ArrayList<>();\n    ```\n\n    Then in our `register()` method, we'll be using the dragon we created in **Step 4** to create an instance of `MineplexDragon`\n\n    ```java\n    @Override\r\n    public void register() {\r\n        super.register();\r\n\r\n        // bukkit dragon\r\n        final EnderDragon enderDragon = DragonSpawnListener.this.spawnDragon();\r\n\r\n        // create mineplex dragon & add to our list\r\n        this.dragonList.add(new MineplexDragon(DragonSpawnListener.this.game, enderDragon));\r\n\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Create more dragons on a timer\">\n    Every 60 seconds, we'll want to add an extra dragon to the skies, let's do that!\n\n    ```java\n    @Override\r\n    public void register() {\r\n        super.register();\r\n\r\n        // bukkit dragon\r\n        final EnderDragon enderDragon = DragonSpawnListener.this.spawnDragon();\r\n\r\n        // create mineplex dragon & add to our list\r\n        this.dragonList.add(new MineplexDragon(DragonSpawnListener.this.game, enderDragon));\r\n\r\n        new BukkitRunnable() {\r\n            @Override\r\n            public void run() {\r\n                // if our game isn't in progress, let's remove this task: to avoid cleanup issues.\r\n                if (!DragonSpawnListener.this.game.getGameState().isInProgress()) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n                // create a new Bukkit dragon instance\r\n                final EnderDragon enderDragon = DragonSpawnListener.this.spawnDragon();\r\n                // create a new MineplexDragon and add it to our list\r\n                DragonSpawnListener.this.dragonList.add(new MineplexDragon(DragonSpawnListener.this.game, enderDragon));\r\n            }\r\n        }.runTaskTimer(this.plugin, 30 * 20, 30 * 20); // run every 60s, with a 60s delay\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Broadcast that we've spawned a dragon!\">\n    To inform players we've spawned a dragon, let's announce it in chat!\n\n    First, another translation needs to be added to our `Dragons_en.properties` resources file!\n\n    ```properties\n    mineplex.dragons.module.game.dragon_spawned=<0> has woken up and is very angry!\n    ```\n\n    Then, we'll need to make a method in our class to announce the dragon has spawned!\n\n    ```java\n    private void broadcastSpawn(final EnderDragon dragon) {\r\n        Bukkit.broadcast(Component.join(\r\n                JoinConfiguration.spaces(),\r\n                // using PrefixUtil we created in a previous tutorial\r\n                PrefixUtil.getPrefix(\"Game\"), \r\n                Component.translatable(\"mineplex.dragons.module.game.dragon_spawned\", dragon.customName())\r\n                        .color(NamedTextColor.GRAY)));\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Cleaning up\">\n    Let's clear up the dragons list when the listener is unregistered! This will stop any entities causing some memory leaks.\n\n    ```java\n    @Override\r\n    public void unregister() {\r\n        super.unregister();\r\n        this.dragonList.forEach(MineplexDragon::teardown);\r\n        this.dragonList.clear();\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/core-gameplay/dragon/phase",
    "title": "Dragon Phase NMS",
    "description": "Using the NMS codebase to create a custom dragon phase",
    "content": "Unlike other mobs, ender dragons don't have pathfinder support in Spigot, nor do they allow you to juggle MobGoals. This was a pain, as now we're left with not much choice other than to use reflection and NMS (net.minecraft.server) classes.\n\nUsing this [Spigot thread](https://www.spigotmc.org/threads/nms-enderdragon-make-the-enderdragon-fly-towards-certain-cords.650252/page-4#post-4756136) for information on how, we figured out we could use reflection to override what the dragon uses as it's phase behaviour.\n\nUsing this class, we get to set a vector location we want the dragon to target, and it animates and makes it look like it's flying randomly.\n\n🔗 [CustomPhase class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/dragons/CustomPhase.java)\n\n## Tutorial\n\n<Step>\n  <StepItem title=\"Create the new class\">\n    We'll first create a class that extends `AbstractDragonPhaseInstance` - Minecraft's abstract base class for all of it's dragon flight behaviour.\n\n    ```java\n    @Slf4j\r\n    public class CustomPhase extends AbstractDragonPhaseInstance {\r\n\r\n        private Location targetLocation;\r\n        private final DragonsGame dragonsGame;\r\n\r\n        public CustomPhase(final EnderDragon dragon, final DragonsGame dragonsGame) {\r\n            super(dragon);\r\n            this.dragonsGame = dragonsGame;\r\n            this.targetLocation = dragonsGame.getSpectatorLocation();\r\n        }\r\n\r\n        @Override\r\n        public @NotNull EnderDragonPhase<? extends DragonPhaseInstance> getPhase() {\r\n            return CHARGING_PLAYER;\r\n        }\r\n\r\n        @Nullable\r\n        @Override\r\n        public Vec3 getFlyTargetLocation() {\r\n            return null; // temp\r\n        }\r\n\r\n    }\n    ```\n\n    When we get to it, this will allow us to define our own behaviour for movement of the dragons.\n  </StepItem>\n\n  <StepItem title=\"Set the dragon target a random player\">\n    To start off with, let's make our dragon target a random alive player, as a first implementation, this will allow us to have a functional, moving dragon.\n\n    First, we add a function that gives us all alive players:\n\n    ```java\n    private List<? extends Player> getAlivePlayers() {\r\n        return Bukkit.getOnlinePlayers().stream()\r\n                .filter(player -> this.dragonsGame.getPlayerState(player).isAlive())\r\n                .toList();\r\n    }\n    ```\n\n    Second, we need to add Random to our class (as a static field), this will let us add some random values to our pathfinding.\n\n    ```java\n    private static final Random random = new Random();\n    ```\n\n    Next, we need to add a couple of utility methods.\n\n    ```java\n    // choose a random number between two given values\r\n    private static int rRange(final int min, final int max) {\r\n        return min + random.nextInt(max - min + 1);\r\n    }\r\n\r\n    // choose a random object from a given list\r\n    private static <T> T random(final List<T> list) {\r\n        if (list.isEmpty()) {\r\n            return null;\r\n        }\r\n        return list.get(random.nextInt(list.size()));\r\n    }\n    ```\n\n    Then, we'll use these static methods to get the dragon to target a player, whenever we call this method (soon!) it'll change the pathfinding to target the player's location at the time we call the method.\n\n    ```java\n    private void targetPlayer() {\r\n        final Player player = random(this.getAlivePlayers());\r\n        this.targetLocation = player.getLocation().clone().add(rRange(-10, 10), rRange(-10, 2), rRange(-10, 10));\r\n    }\n    ```\n\n    Finally, we'll implement the `serverTick()` method - this is called every tick and we'll hijack this to build targetting decision making.\n\n    ```java\n    @Override\r\n    public void doServerTick() {\r\n\r\n        final Location location = this.dragon.getBukkitEntity().getLocation();\r\n\r\n        // if the dragon's location is lower than 25 blocks below spawnpoint\r\n        if (location.getY() < this.dragonsGame.getSpectatorLocation().getY() - 25) {\r\n            // then it'll target a random player\r\n            this.targetPlayer();\r\n            return;\r\n        }\r\n\r\n        // if the dragons are pushed too far up, teleport them to underneath the map\r\n        if (location.getY() > this.dragonsGame.getSpectatorLocation().getY() + 40) {\r\n            this.dragon\r\n                    .getBukkitEntity()\r\n                    .teleport(this.dragonsGame.getSpectatorLocation().clone().add(0, -40, 0));\r\n            return;\r\n        }\r\n\r\n        // if it's a bit too high, target a random player\r\n        if (location.getY() > this.dragonsGame.getSpectatorLocation().getY() + 10) {\r\n            this.targetPlayer();\r\n            return;\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Send it to the sky\">\n    Once the dragon's found it's target, we don't want it to stick to the player and constantly target them, that'd be a bit frustrating. Instead, we want the dragon to re-enter the sky and fly around until it matches another one of our above conditions.\n\n    So, we'll need to add a new `targetSky()` method.\n\n    ```java\n    private void targetSky() {\r\n        // target a random location within the map area\r\n        this.targetLocation =\r\n                this.dragonsGame.getSpectatorLocation().clone().add(rRange(-50, 50), rRange(-15, 20), rRange(-50, 50));\r\n    }\n    ```\n\n    Before we call it, let's first make sure the dragon reaches it's current target first.\n\n    To do this, we need to create a new static method for finding the distance squared between two locations.\n\n    ```java\n    private static double offsetSquared(final Location loc1, final Location loc2) {\r\n        final double dx = loc1.getX() - loc2.getX();\r\n        final double dy = loc1.getY() - loc2.getY();\r\n        final double dz = loc1.getZ() - loc2.getZ();\r\n        return dx * dx + dy * dy + dz * dz;\r\n    }\n    ```\n\n    Then at the **bottom** of our `doServerTick()` method, we'll add a check to see if it's close enough to it's destination, and if so, we'll make it fly to the random location returned by `targetSky()`\n\n    ```java\n        // Not near target.\r\n        if (offsetSquared(location, this.targetLocation) > 6) {\r\n            return;\r\n        }\r\n\r\n        this.targetSky();\n    ```\n  </StepItem>\n\n  <StepItem title=\"Making sure it all goes smoothly\">\n    Our code now has a couple places where the target location could be null, let's start addressing this by adding a method that handles setting the first target location by overriding `begin()`\n\n    ```java\n    @Override\r\n    public void begin() {\r\n        this.targetSky();\r\n    }\n    ```\n\n    And then, we also want to add something to our constructor to do the same.\n\n    ```java\n    public CustomPhase(final EnderDragon dragon, final DragonsGame dragonsGame) {\r\n        super(dragon);\r\n        this.dragonsGame = dragonsGame;\r\n        this.targetLocation = dragonsGame.getSpectatorLocation(); // this line!\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/core-gameplay",
    "title": "Core Gameplay",
    "description": "An overview of the key gameplay mechanics in our Dragons game",
    "content": "### Core Gameplay\n\nThe core gameplay of our Dragons game revolves around the interaction between players, dragons, and various kits. Players must navigate through the map, avoid dragons, and use their chosen kits to outsmart their opponents. Below is an overview of the key components of the game.\n\n#### **Dragon Spawning and Pathfinding**\n\nDragons are one of the central threats in the game, and their behavior is key to creating tension. The spawning and pathfinding mechanics control how and where dragons appear, as well as how they move across the map. The dragons are designed to be dynamic and react to different stimuli, such as players' actions and the use of sparkler items (in the case of the Pyrotechnic kit). Proper dragon pathfinding ensures they provide a challenging and engaging experience for players as they navigate the map.\n\n#### **Kit Selector**\n\nBefore entering the game, players must choose their kit. The Kit Selector is an essential part of the pregame phase, where players can decide between available kits that offer unique abilities and equipment. The choice of kit can greatly affect gameplay, with each kit providing strategic advantages in different situations.\n\n#### **Kits**\n\nThe kits available in the game are designed to change the way players interact with the environment and dragons. For example, the **Pyrotechnic** kit provides players with sparklers to lure dragons away, while the **Coward** kit gives players a mobility advantage by allowing them to leap using an iron axe. These kits not only provide varied gameplay but also cater to different playstyles, whether players prefer direct engagement or tactical evasion.\n\n***\n\nAs you progress in the game, the interaction between these elements—dragon spawning, pathfinding, kit selection, and kit usage—will shape the gameplay experience, offering multiple strategies and playstyles for players to explore.\n"
  },
  {
    "slug": "/example-project/dragons/core-gameplay/kits/coward",
    "title": "Coward Kit",
    "description": "Implementing a new kit for gameplay!",
    "content": "The **Coward** kit is designed for players who prefer to avoid confrontation by leaping away from danger. With full leather armor and an iron axe that allows them to leap with a right-click, players using this kit can quickly escape from dragons or other threats. Additionally, the kit removes knockback upon landing, giving players an advantage in maintaining control after their leap.\n\n### Creating the kit\n\n<Step>\n  <StepItem title=\"Create the kit class\">\n    We start by creating a class to house our Coward kit. We'll implement the `Kit<DragonsGame>` interface provided by the Mineplex SDK. This interface allows us to define essential mechanics for the kit.\n\n    🔗 [View the kit documentation](https://docs.mineplex.com/docs/sdk/features/game/mechanics/kit)\n\n    🔗 [CowardKit class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/kits/CowardKit.java).\n\n    Here's the basic structure of the `CowardKit` class:\n\n    ```java\n    public class CowardKit implements Kit<DragonsGame> {\r\n\r\n        @Override\r\n        public @NonNull String getName() { return \"Coward\"; } // The name of our kit\r\n\r\n        @Override\r\n        public void setup(@NonNull DragonsGame game) { } // Setup logic for the kit\r\n\r\n        @Override\r\n        public void teardown() { } // Logic for when the kit is removed or the game ends\r\n\r\n        @Override\r\n        public void giveKit(@NonNull LivingEntity livingEntity) { } // Logic to give the kit to a player\r\n\r\n        @Override\r\n        public void removeKit(@NonNull LivingEntity livingEntity) { } // Logic to remove the kit from a player\r\n\r\n    }\n    ```\n\n    <Note type=\"danger\">\n      You'll see your IDE complaining about missing methods, hold on for a moment, we're coming to it!\n    </Note>\n  </StepItem>\n\n  <StepItem title=\"Implementing core methods\">\n    The next step is to implement some essential methods for the `CowardKit`.\n\n    **Adding Lombok Annotations**\r\n    We'll use Lombok annotations to simplify the code:\n\n    * `@Getter` to automatically generate getters for our fields (this will automatically override, satisfying your IDE's shouting).\n    * `@RequiredArgsConstructor` to generate a constructor that initializes final fields.\n\n    This allows for cleaner and more efficient code.\n\n    ```java\n    @RequiredArgsConstructor\r\n    @Getter\r\n    public class CowardKit implements Kit<DragonsGame> {\n    ```\n\n    **Adding Kit Mechanics**\r\n    We need to define the mechanics that drive this kit. These mechanics will help distribute and manage kits, as well as manage the abilities associated with the kit:\n\n    ```java\n    // Used to distribute and manage kits\r\n    private final KitMechanic kitMechanic;\r\n\r\n    // Used to manage abilities\r\n    private final AbilityMechanic abilityMechanic;\r\n\r\n    private final DragonsGame game; // The game instance to tie this kit to\n    ```\n\n    These fields will be initialized through the constructor, thanks to `@RequiredArgsConstructor`.\n  </StepItem>\n\n  <StepItem title=\"Register the coward kit in the game\">\n    We need to register it in the `DragonsGame` class. This will make sure that the kit is available to our kit mechanic.\n\n    In your `DragonsGame` class, add the Coward Kit to the kit registry within the `setup()` method\n\n    ```java\n    this.kitMechanic.registerKit(this, CowardKit.class, new CowardKit(this.kitMechanic, this.abilityMechanic, this));\n    ```\n  </StepItem>\n</Step>\n\n### Adding the leap ability\n\nThe **Coward Kit** includes a unique ability: **LeapAbility**. This allows players to leap away from danger by right-clicking with their iron axe.\n\n<Note type=\"success\">\n  We're skipping over adding translations in our future steps, we've done this a few times already, so this should be simple!\n\n  🔗 [Complete translations file](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/resources/i18n/Dragons_en.properties)\n</Note>\n\n.\n\n<Step>\n  <StepItem title=\"Add LeapAbility class\">\n    Begin by creating the `LeapAbility` class:\n\n    ```java\n    public class LeapAbility implements ActiveAbility<DragonsGame> {\r\n        @Override\r\n        public void activate(@NonNull LivingEntity livingEntity) {}\r\n\r\n        @Override\r\n        public void deactivate(@NonNull LivingEntity livingEntity) {}\r\n\r\n        @Override\r\n        public @NonNull AbilityMechanic getAbilityMechanic() {\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public @NonNull DragonsGame getGame() { return null; }\r\n\r\n        @Override\r\n        public @NonNull String getName() { return \"\"; }\r\n\r\n        @Override\r\n        public void setup(@NonNull DragonsGame game) {}\r\n\r\n        @Override\r\n        public void teardown() {}\r\n\r\n        @Override\r\n        public void start(@NonNull LivingEntity livingEntity) {}\r\n\r\n        @Override\r\n        public void stop(@NonNull LivingEntity livingEntity) {}\r\n    }\n    ```\n\n    🔗 [LeapAbility class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/kits/ability/LeapAbility.java)\n  </StepItem>\n\n  <StepItem title=\"Enhance LeapAbility class\">\n    Add necessary imports, fields, and annotations to define the full functionality of the LeapAbility. Update your class like this:\n\n    ```java\n    @Slf4j\r\n    @Getter\r\n    @AllArgsConstructor\r\n    public class LeapAbility implements ActiveAbility<DragonsGame>, Listener {\r\n\r\n        private final AbilityMechanic abilityMechanic;\r\n        private final DragonsGame game;\r\n\r\n        private static final ItemStack ITEM_STACK;\r\n        private static final long COOLDOWN_DURATION = 7000; // 7 seconds in milliseconds\r\n        private static final long LEAP_PROTECTION_DURATION = 5000; // 5 seconds for fall damage protection\r\n\r\n        private final Set<LivingEntity> abilityUsers = new HashSet<>();\r\n        private final Map<UUID, Long> cooldowns = new HashMap<>();\r\n        private final Set<UUID> protectedFromFall = new HashSet<>();\r\n\r\n        static {\r\n            ITEM_STACK = new ItemStack(Material.IRON_AXE);\r\n            ITEM_STACK.editMeta(meta -> meta.displayName(Component.translatable(\"mineplex.dragons.module.game.kit.coward.axe_name\")\r\n                    .color(NamedTextColor.GREEN)));\r\n        }\r\n    }\n    ```\n\n    * **Annotations**: `@Slf4j`, `@Getter`, and `@AllArgsConstructor` simplify the class by handling logging, getters, and constructor generation.\n    * **Fields**: Define reusable constants and collections for cooldowns and fall damage protection.\n    * **Static Block**: Prepares the special iron axe with a custom name and appearance.\n  </StepItem>\n\n  <StepItem title=\"Handle player interactions\">\n    Add the logic for when players right-click with the iron axe to trigger the leap ability:\n\n    ```java\n    @EventHandler\r\n    public void handleClick(final PlayerInteractEvent event) {\r\n        // Check if the player is right-clicking in the air or on a block\r\n        if (event.getAction() == Action.RIGHT_CLICK_AIR || event.getAction() == Action.RIGHT_CLICK_BLOCK) {\r\n            // Get the item the player is holding in their main hand\r\n            final ItemStack heldItem = event.getPlayer().getInventory().getItemInMainHand();\r\n            // Check if the held item matches the predefined special ITEM_STACK\r\n            if (heldItem.isSimilar(ITEM_STACK)) {\r\n                // Get the player's unique identifier and the current time\r\n                final UUID playerId = event.getPlayer().getUniqueId();\r\n                final long currentTime = System.currentTimeMillis();\r\n\r\n                // Check if the player is on cooldown\r\n                if (this.cooldowns.containsKey(playerId)\r\n                        && currentTime - this.cooldowns.get(playerId) < COOLDOWN_DURATION) {\r\n                    // Calculate the remaining cooldown time in seconds\r\n                    final long timeLeft = (COOLDOWN_DURATION - (currentTime - this.cooldowns.get(playerId))) / 1000;\r\n                    // Send a message to the player indicating how much cooldown time is left\r\n                    event.getPlayer()\r\n                            .sendMessage(Component.join(\r\n                                    JoinConfiguration.spaces(),\r\n                                    PrefixUtil.getPrefix(\"Game\"), // Prefix for the message\r\n                                    Component.translatable(\r\n                                                    \"mineplex.dragons.module.game.kit.cooldown-message\", // Translatable key\r\n                                                    Component.text(timeLeft).color(NamedTextColor.YELLOW)) // Cooldown time in yellow\r\n                                            .color(NamedTextColor.RED))); // Main message color\r\n                    return; // Exit the method to prevent further actions\r\n                }\r\n\r\n                // Calculate the velocity vector for the leap\r\n                final Vector leapVelocity = getVector(event);\r\n\r\n                // Set the player's velocity to perform the leap\r\n                event.getPlayer().setVelocity(leapVelocity);\r\n                // Play the sound of an Ender Dragon flapping its wings at the player's location\r\n                event.getPlayer()\r\n                        .getWorld()\r\n                        .playSound(event.getPlayer().getLocation(), Sound.ENTITY_ENDER_DRAGON_FLAP, 1.0f, 1.0f);\r\n\r\n                // Record the time the player used the leap in the cooldown map\r\n                this.cooldowns.put(playerId, currentTime);\r\n\r\n                // Add the player to the fall protection list to prevent fall damage\r\n                this.protectedFromFall.add(playerId);\r\n\r\n                // Schedule a task to remove the player from the fall protection list after the protection duration\r\n                this.game\r\n                        .getDragonsPlugin() // Get the plugin instance\r\n                        .getServer()\r\n                        .getScheduler()\r\n                        .runTaskLater(\r\n                                this.game.getDragonsPlugin(), // Plugin reference for scheduling\r\n                                () -> this.protectedFromFall.remove(playerId), // Remove player from protection list\r\n                                LEAP_PROTECTION_DURATION / 50); // Convert duration from milliseconds to ticks\r\n            }\r\n        }\r\n    }\n    ```\n\n    * **Cooldown Handling**: Ensures players can't spam the ability.\n    * **Velocity Calculation**: Uses `getVector` to determine the leap direction and strength.\n    * **Fall Protection**: Temporarily prevents fall damage after leaping.\n  </StepItem>\n\n  <StepItem title=\"Prevent fall damage\">\n    Add an event handler to cancel fall damage for players who have recently leapt:\n\n    ```java\n    @EventHandler\r\n    public void handleFallDamage(final EntityDamageEvent event) {\r\n        if (event.getEntity() instanceof final Player player\r\n                && event.getCause() == EntityDamageEvent.DamageCause.FALL) {\r\n            if (this.protectedFromFall.remove(player.getUniqueId())) {\r\n                event.setCancelled(true);\r\n            }\r\n        }\r\n    }\n    ```\n\n    * Checks if the player is on the fall protection list.\n    * Cancels fall damage if they are.\n  </StepItem>\n\n  <StepItem title=\"Start and stop logic\">\n    Ensure that when a player starts or stops using the ability, the correct items are applied or cleared:\n\n    ```java\n    @Override\r\n    public void start(@NonNull final LivingEntity livingEntity) {\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        if (equipment != null) {\r\n            equipment.setItemInMainHand(ITEM_STACK.clone());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void stop(@NonNull final LivingEntity livingEntity) {\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        if (equipment != null) {\r\n            equipment.clear();\r\n        }\r\n    }\n    ```\n\n    * Ensures the player always has the correct gear when the ability is active.\n  </StepItem>\n</Step>\n\n### Register the ability within the kit\n\nNow we've created our ability, it's back to our `CowardKit` class!\n\n<Step>\n  <StepItem title=\"Add the ability to the kit\">\n    We need to register the ability as part of the kit! And clean it up properly once the game ends!\n\n    ```java\n    @Override\r\n    public void setup(@NonNull final DragonsGame game) {\r\n        this.abilityMechanic.registerAbility(game, LeapAbility.class, new LeapAbility(this.abilityMechanic, game));\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        this.abilityMechanic.destroyAbility(LeapAbility.class);\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Give and remove the items from the player\">\n    Within the `CowardKit` class: this kit has an armor set, so we'll need to add and remove items from the player when it's activated and deactivated.\n\n    ```java\n    @Override\r\n    public void giveKit(@NonNull final LivingEntity livingEntity) {\r\n        // Apply gear\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        if (equipment != null) {\r\n            equipment.setHelmet(ItemStack.of(Material.LEATHER_HELMET));\r\n            equipment.setChestplate(ItemStack.of(Material.LEATHER_CHESTPLATE));\r\n            equipment.setLeggings(ItemStack.of(Material.LEATHER_LEGGINGS));\r\n            equipment.setBoots(ItemStack.of(Material.LEATHER_BOOTS));\r\n        }\r\n        this.abilityMechanic.grantAbility(livingEntity, LeapAbility.class);\r\n    }\r\n\r\n    @Override\r\n    public void removeKit(@NonNull final LivingEntity livingEntity) {\r\n        this.abilityMechanic.removeAbility(livingEntity, LeapAbility.class);\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/core-gameplay/kits",
    "title": "Kits",
    "description": "Kits that change how the game is played",
    "content": "![Kits](/images/kits.png \"Kits\")\n\n### Overview of Kits\n\nIn our game, players can choose from two different kits, each offering unique advantages and gameplay mechanics. These kits are designed to enhance the player's experience by providing special abilities and equipment that change how they interact with the game world.\n\n#### Pyrotechnic Kit\n\nThe Pyrotechnic kit is for players who enjoy drawing the dragons’ attention. This kit is equipped with tools to manipulate the game’s dynamic dragon behavior.\n\n* **Armor**: Full Golden Armor for durability and protection.\n* **Special Ability**: Players receive 1 sparkler every 25 seconds, with a maximum of 2. Sparklers can be thrown to any location on the map to attract dragons to that spot, providing a tactical advantage by luring the dragons away from the player’s current location or towards enemies.\n\n#### Coward Kit\n\nThe Coward kit focuses on stealth and evasion, perfect for players who prefer to avoid direct confrontation.\n\n* **Armor**: Full Leather Armor, offering basic protection but not as much as higher-tier armors.\n* **Special Ability**: An Iron Axe that grants players the ability to leap when right-clicked, helping them escape danger or quickly traverse the map. This is perfect for creating distance or evading attacks from dragons or other players.\n\n### Let's setup some stuff first:\n\n<Step>\n  <StepItem title=\"Declare Mechanics as Fields\">\n    First, add the required fields to your `DragonsGame` class to store the mechanics:\n\n    ```java\n    private AbilityMechanic abilityMechanic;\r\n    private KitMechanic kitMechanic;\n    ```\n\n    These fields will allow the game to manage kits and abilities effectively, providing a centralized way to initialize and access them.\n  </StepItem>\n\n  <StepItem title=\"Initialize the Kit mechanic\">\n    In the `setup` method of your `DragonsGame` class, construct and set up the `KitMechanic`:\n\n    ```java\n    this.kitMechanic = this.gameMechanicFactory.construct(KitMechanic.class);\r\n    this.kitMechanic.setup(this);\n    ```\n\n    * Constructs the `KitMechanic` using the factory.\n    * Prepares it to manage kits within the game, such as assigning or removing them.\n\n    🔗 [Kit Mechanic Documentation](http://docs.mineplex.com/docs/sdk/features/game/mechanics/kit)\n  </StepItem>\n\n  <StepItem title=\"Initialize the Ability Mechanic\">\n    Next, in the same `setup` method, construct and set up the `AbilityMechanic`:\n\n    ```java\n    this.abilityMechanic = this.gameMechanicFactory.construct(AbilityMechanic.class);\r\n    this.abilityMechanic.setup(this);\n    ```\n\n    * Constructs the `AbilityMechanic` using the factory.\n    * Prepares it to handle abilities like the Coward's leap, ensuring they're properly registered and functional.\n\n    🔗 [Ability Mechanic Documentation](http://docs.mineplex.com/docs/sdk/features/game/mechanics/ability)\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/core-gameplay/kits/kit-selector",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/core-gameplay/kits/pyrotechnic",
    "title": "Pyrotechnic Kit",
    "description": "A kit that attracts dragons towards a thrown Sparkler",
    "content": "The Pyrotechnic Kit introduces a dynamic and tactical ability to influence dragon behavior during gameplay. By throwing sparkler items, players can attract dragons to specific locations, making it an effective tool for both offense and sabotage.\n\n### Kit Features\n\n* **Armor**: Full golden armor set for added protection.\n* **Sparkler Ability**:\n  * Automatically receives 1 sparkler every **25 seconds** (maximum of 2 sparklers).\n  * Sparklers can be thrown to any location on the map.\n  * **Effect**: Attracts dragons to the location of the thrown sparkler, creating opportunities for strategic gameplay.\n\n![Dragon Sparkle](/images/dragons-sparkle.gif \"Sparkle Effect\")\n\n### Adding the kit\n\n<Step>\n  <StepItem title=\"Create the kit class\">\n    First things first, we need a class to house our kit, we'll be implementing a handy Mineplex SDK kit interface `Kit<DragonsGame>`\n\n    🔗 [View the kit documentation](https://docs.mineplex.com/docs/sdk/features/game/mechanics/kit)\n\n    🔗 [PyrotechnicKit class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/kits/PyrotechnicKit.java)\n\n    ```java\n    public class PyrotechnicKit implements Kit<DragonsGame> {\r\n        @Override\r\n        public @NonNull KitMechanic getKitMechanic() { return null; }\r\n\r\n        @Override\r\n        public @NonNull DragonsGame getGame() { return null; }\r\n\r\n        @Override\r\n        public @NonNull String getName() { return \"Pyrotechnic\"; }\r\n\r\n        @Override\r\n        public void setup(@NonNull DragonsGame game) { }\r\n\r\n        @Override\r\n        public void teardown() { }\r\n\r\n        @Override\r\n        public void giveKit(@NonNull LivingEntity livingEntity) { }\r\n\r\n        @Override\r\n        public void removeKit(@NonNull LivingEntity livingEntity) { }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Implementing some of the methods\">\n    First, let's mark the class as `@Getter` and `@RequiredArgsConstructor` (as we did last time!)\n\n    ```java\n    @RequiredArgsConstructor\r\n    @Getter\r\n    public class PyrotechnicKit implements Kit<DragonsGame> {\n    ```\n\n    Then, let's add some helper mechanics, and our game class to our fields (same as with our Coward kit)\n\n    ```java\n    // used to distribute and manage kits\r\n    private final KitMechanic kitMechanic;\r\n\r\n    // used to manage abilities\r\n    private final AbilityMechanic abilityMechanic;\r\n\r\n    private final DragonsGame game;\n    ```\n  </StepItem>\n\n  <StepItem title=\"Register the Pyrotechnic kit in the game\">\n    We need to register it in the `DragonsGame` class. This will make sure that the kit is available to our kit mechanic.\n\n    In your `DragonsGame` class, add the Pyrotechnic Kit to the kit registry within the `setup()` method\n\n    ```java\n    this.kitMechanic.registerKit(this, PyrotechnicKit.class, new PyrotechnicKit(this.kitMechanic, this.abilityMechanic, this));\n    ```\n  </StepItem>\n</Step>\n\n### Adding the sparkler ability\n\nNext, we're going to have to create our ability, as mentioned: a throwable sparkler item.\n\n<Note type=\"success\">\n  We're skipping over adding translations in our future steps, we've done this a few times already, so this should be simple!\n\n  🔗 [Complete translations file](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/resources/i18n/Dragons_en.properties)\n</Note>\n\n🔗 [SparklerAbility class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/kits/ability/SparklerAbility.java)\n\n<Step>\n  <StepItem title=\"Add SparklerAbility class\">\n    Begin by creating the `SparklerAbility` class:\n\n    ```java\n    public class SparklerAbility implements ActiveAbility<DragonsGame> {\r\n        @Override\r\n        public void activate(@NonNull LivingEntity livingEntity) {}\r\n\r\n        @Override\r\n        public void deactivate(@NonNull LivingEntity livingEntity) {}\r\n\r\n        @Override\r\n        public @NonNull AbilityMechanic getAbilityMechanic() { return null; }\r\n\r\n        @Override\r\n        public @NonNull DragonsGame getGame() { return null; }\r\n\r\n        @Override\r\n        public @NonNull String getName() { return \"\"; }\r\n\r\n        @Override\r\n        public void setup(@NonNull DragonsGame game) {}\r\n\r\n        @Override\r\n        public void teardown() {}\r\n\r\n        @Override\r\n        public void start(@NonNull LivingEntity livingEntity) {}\r\n\r\n        @Override\r\n        public void stop(@NonNull LivingEntity livingEntity) {}\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Enhance SparklerAbility class\">\n    Add necessary imports, fields, and annotations to define the full functionality of the SparklerAbility. Update your class like this:\n\n    ```java\n    private final DragonsGame game;\r\n\r\n    // map for player -> task to give out sparklers\r\n    private final Map<UUID, BukkitTask> bukkitTaskMap = new HashMap<>();\r\n\r\n    // our item stack for the sparklers\r\n    private static final ItemStack itemStack;\r\n    static {\r\n        itemStack = new ItemStack(Material.EMERALD);\r\n        itemStack.editMeta(meta ->\r\n                meta.displayName(Component.translatable(\"mineplex.dragons.module.game.kit.pyrotechnic.sparkler_name\")\r\n                        .color(NamedTextColor.GREEN)));\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Give people sparkler items on a timer\">\n    ```java\n        @Override\r\n    public void start(@NonNull final LivingEntity livingEntity) {\r\n        if (!(livingEntity instanceof final Player player)) {\r\n            throw new IllegalArgumentException(\"SparklerAbility can only be applied to players.\");\r\n        }\r\n\r\n        // safety net in-case we call start twice.\r\n        if(this.bukkitTaskMap.containsKey(player.getUniqueId())) {\r\n            return;\r\n        }\r\n\r\n        this.bukkitTaskMap.put(\r\n                player.getUniqueId(),\r\n                new BukkitRunnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (player.isDead()) {\r\n                            SparklerAbility.this.deactivate(player);\r\n                            return;\r\n                        }\r\n\r\n                        // if player is dead, de-activate the giving\r\n                        if (!SparklerAbility.this.game.getPlayerState(player).isAlive()) {\r\n                            SparklerAbility.this.deactivate(player);\r\n                            return;\r\n                        }\r\n\r\n                        final PlayerInventory inventory = player.getInventory();\r\n                        int emeraldCount = 0;\r\n\r\n                        // Count emeralds in all inventory slots\r\n                        for (final ItemStack item : inventory.getContents()) {\r\n                            if (item != null && item.isSimilar(itemStack)) {\r\n                                emeraldCount += item.getAmount();\r\n                            }\r\n                        }\r\n\r\n                        // Add emerald if there are less than 2\r\n                        if (emeraldCount < 2) {\r\n                            final ItemStack emerald = SparklerAbility.itemStack.clone();\r\n                            inventory.addItem(emerald);\r\n                        }\r\n                    }\r\n                }.runTaskTimer(this.getGame().getDragonsPlugin(), 0, 25 * 20));\r\n    }\n    ```\n\n    You'll also want to handle cleaning up once the game is over!\n\n    ```java\n    @Override\r\n    public void stop(@NonNull final LivingEntity livingEntity) {\r\n\r\n        if (!(livingEntity instanceof final Player player)) {\r\n            throw new IllegalArgumentException(\"SparklerAbility can only be applied to players.\");\r\n        }\r\n\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        equipment.clear();\r\n\r\n        if (this.bukkitTaskMap.containsKey(player.getUniqueId())) {\r\n            this.bukkitTaskMap.get(player.getUniqueId()).cancel();\r\n            this.bukkitTaskMap.remove(player.getUniqueId());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        this.bukkitTaskMap.forEach((key, value) -> value.cancel());\r\n        this.bukkitTaskMap.clear();\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Create our event listener\">\n    As we're handling a dropped item, we need to listen for the drop and act upon it.\n\n    ```java\n    @EventHandler\r\n    public void onPlayerDropItem(final PlayerDropItemEvent event) {\r\n        final Item droppedItem = event.getItemDrop();\r\n\r\n        // Check if the dropped item is our sparkler item\r\n        if (droppedItem.getItemStack().isSimilar(itemStack)) {\r\n\r\n            // Make the item non-pickable\r\n            droppedItem.setPickupDelay(Integer.MAX_VALUE);\r\n\r\n        }\r\n\r\n    }\n    ```\n\n    If an emerald is dropped, we set it so it can never be picked up.\n  </StepItem>\n\n  <StepItem title=\"Add a way to get registered listeners\">\n    Since the list of dragons for our game is held in our `DragonSpawnListener`, we'll need to add a generic way to fetch listeners by a given listener class.\n\n    In our main game class (`DragonsGame`)\n\n    ```java\n    // optional because there's no guarantee this class has a registered instance\r\n    public <T> Optional<T> getRegisteredListener(final Class<? extends T> listenerClass) {\r\n        return (Optional<T>) this.getListeners().stream()\r\n                .filter(stateBasedListener -> stateBasedListener.getClass().equals(listenerClass))\r\n                .findFirst();\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Pick a random dragon\">\n    Using our new method, we'll use this to fetch the listener instance of `DragonSpawnListener` and fetch the list of current dragons.\n\n    To do this, we'll add to our `SparklerAbility`, we'll choose a random dragon from  and make it attract to our sparkler.\n\n    We'll use the `targetSparkler` method we added when working with our [Dragon Phase](../dragon/phase) behaviour.\n\n    ```java\n    @EventHandler\r\n    public void onPlayerDropItem(final PlayerDropItemEvent event) {\r\n        final Item droppedItem = event.getItemDrop();\r\n\r\n        // Check if the dropped item is an emerald\r\n        if (droppedItem.getItemStack().isSimilar(itemStack)) {\r\n\r\n            // Make the item non-pickable\r\n            droppedItem.setPickupDelay(Integer.MAX_VALUE);\r\n\r\n            // fetch the list of dragons\r\n            final List<MineplexDragon> dragons = this.game\r\n                .getRegisteredListener(DragonSpawnListener.class)\r\n                // this is a safe orElseThrow() as we registered it when adding our dragon behaviour\r\n                .orElseThrow() \r\n                .getDragonList();\r\n\r\n            // Check if there are any dragons\r\n            if (!dragons.isEmpty()) {\r\n                // Pick a random dragon\r\n                final MineplexDragon selectedDragon = dragons.get(new Random().nextInt(dragons.size()));\r\n\r\n                // Set the sparkler target for the selected dragon\r\n                selectedDragon.getPhase().targetSparkler(droppedItem.getLocation());\r\n            }\r\n\r\n        }\r\n\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Create a firework utility\">\n    Since we may want to re-use this firework effect in future, it's utility time!\n\n    🔗 [FireworkUtil class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/utils/FireworkUtil.java)\n\n    ```java\n    @UtilityClass\r\n    public class FireworkUtil {\r\n\r\n        public static void playFirework(final DragonsPlugin plugin, final Location loc, final FireworkEffect fe) {\r\n            final Firework firework = loc.getWorld().spawn(loc, Firework.class);\r\n            final FireworkMeta data = firework.getFireworkMeta();\r\n            data.clearEffects();\r\n            data.setPower(1);\r\n            data.addEffect(fe);\r\n            firework.setFireworkMeta(data);\r\n\r\n            // Set firework lifespan to 1 tick\r\n            new BukkitRunnable() {\r\n                @Override\r\n                public void run() {\r\n                    firework.detonate(); // Detonates the firework after 1 tick\r\n                }\r\n            }.runTaskLater(plugin, 1); // Adjust your plugin instance here\r\n        }\r\n\r\n        public static void playFirework(\r\n                final DragonsPlugin plugin,\r\n                final Location loc,\r\n                final FireworkEffect.Type type,\r\n                final Color color,\r\n                final boolean flicker,\r\n                final boolean trail) {\r\n            playFirework(\r\n                    plugin,\r\n                    loc,\r\n                    FireworkEffect.builder()\r\n                            .flicker(flicker)\r\n                            .withColor(color)\r\n                            .with(type)\r\n                            .trail(trail)\r\n                            .build());\r\n        }\r\n    }\n    ```\n\n    This allows us to build a firework quickly and it's re-usable\n  </StepItem>\n\n  <StepItem title=\"Implement the sparkle\">\n    In order to make it sparkle, we make a repeating task that counts the ticks and every second, sparkles! After 10s, we remove the item to stop it being annoying!\n\n    We add this to the bottom of our event handler (within the emerald check statement).\n\n    ```java\n    @EventHandler\r\n    public void onPlayerDropItem(final PlayerDropItemEvent event) {\r\n        if (droppedItem.getItemStack().isSimilar(itemStack)) {\r\n            \r\n            // rest of the code...\r\n\r\n            new BukkitRunnable() {\r\n                int ticks = 0;\r\n\r\n                @Override\r\n                public void run() {\r\n                    if (this.ticks % 20 == 0) {\r\n                        FireworkUtil.playFirework(\r\n                                SparklerAbility.this.plugin,\r\n                                droppedItem.getLocation(),\r\n                                FireworkEffect.Type.BURST,\r\n                                Color.LIME,\r\n                                false,\r\n                                false);\r\n                    }\r\n\r\n                    if (this.ticks++ >= 200) {\r\n                        // Remove the dropped item\r\n                        droppedItem.remove();\r\n                        this.cancel();\r\n                    }\r\n                }\r\n            }.runTaskTimer(this.plugin, 60L, 1L); // Run every tick (1/20th of a second)\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Stop the damage\">\n    In modern game versions, fireworks damage players.\n\n    We'll have to cancel that so people don't kill eachother!\n\n    ```java\n    @EventHandler\r\n    public void handleFireworkDamage(final EntityDamageByEntityEvent damageByEntityEvent) {\r\n        if (damageByEntityEvent.getDamager() instanceof Firework) {\r\n            damageByEntityEvent.setCancelled(true);\r\n        }\r\n    }\n    ```\n  </StepItem>\n</Step>\n\n### Register the ability within the kit\n\nNow we've created our ability, it's back to our `PyrotechnicKit` class!\n\n<Step>\n  <StepItem title=\"Add the ability to the kit\">\n    We need to register the ability as part of the kit! And clean it up properly once the game ends!\n\n    ```java\n    @Override\r\n    public void setup(@NonNull final DragonsGame game) {\r\n        this.abilityMechanic.registerAbility(game, SparklerAbility.class, new SparklerAbility(this.abilityMechanic, game));\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        this.abilityMechanic.destroyAbility(SparklerAbility.class);\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Give and remove the items from the player\">\n    Within the `PyrotechnicKit` class: this kit has an armor set, so we'll need to add and remove items from the player when it's activated and deactivated.\n\n    ```java\n    @Override\r\n    public void giveKit(@NonNull final LivingEntity livingEntity) {\r\n        // Apply gear\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        if (equipment != null) {\r\n            equipment.setHelmet(ItemStack.of(Material.GOLDEN_HELMET));\r\n            equipment.setChestplate(ItemStack.of(Material.GOLDEN_CHESTPLATE));\r\n            equipment.setLeggings(ItemStack.of(Material.GOLDEN_LEGGINGS));\r\n            equipment.setBoots(ItemStack.of(Material.GOLDEN_BOOTS));\r\n        }\r\n        this.abilityMechanic.grantAbility(livingEntity, SparklerAbility.class);\r\n    }\r\n\r\n    @Override\r\n    public void removeKit(@NonNull final LivingEntity livingEntity) {\r\n        this.abilityMechanic.removeAbility(livingEntity, SparklerAbility.class);\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons",
    "title": "Dragons Example Project",
    "description": "Dragons Example Studio Project",
    "content": "![Dragons - Example Project](https://i.imgur.com/6s4X9Us.png)\n\nIn **Dragons**, players are thrown into a chaotic arena where their primary objective is to **survive**. The challenge? A horde of fierce and unpredictable dragons wreak havoc on the terrain, smashing through blocks and creating dangerous gaps.\n\n## Follow Along\n\nThis project is available as open-source and hosted on GitHub:\\\n🔗 **[StudioExample-Dragons Source Code](https://github.com/BillyDotWS/StudioExample-Dragons)**\n\nClone the repository, explore the code, and experiment with the gameplay. Whether you're new to Minecraft plugin development or looking to refine your skills, this project offers plenty of opportunities to learn.\n\nWe'll be guiding you through how we've implemented this on the Mineplex Studio platform - navigate using the Next and Previous page buttons at the bottom of the page.\n\n## Gameplay Overview\n\n* **Objective**: Stay alive as long as possible while the arena is destroyed around you.\n* **Dragons**: Ender Dragons fly through the map, destroying blocks in their path. Their attacks are random, forcing players to stay constantly on the move.\n* **Falling to the Void**: Once the terrain is destroyed, players must avoid falling into the void below. The last player standing is the winner.\n\n## Key Features\n\n* **Randomized Chaos**: No two rounds are the same, as the dragons attack unpredictably.\n* **Dynamic Maps**: Each map offers unique layouts and challenges, from floating islands to precarious cliffs.\n* **Survivor Skills**: Use agility, quick thinking, and strategic positioning to outlast your opponents.\n\n## Strategies\n\n* **Keep Moving**: Staying still makes you an easy target for dragons.\n* **High Ground**: Being at a higher elevation can give you a slight advantage as the terrain crumbles.\n* **Avoid Crowds**: Dragons tend to target areas with more players, so spreading out can help you stay safe.\n* **Watch for Edges**: Be mindful of where you're standing—one misstep can send you plummeting into the void.\n\n**Dragons** is a thrilling test of survival instincts and adaptability, where only the bravest and most resourceful players can claim victory. Gather your courage and face the dragons in this timeless Mineplex classic!\n"
  },
  {
    "slug": "/example-project/dragons/initial-classes",
    "title": "Step-by-Step Explanation of Initial Classes",
    "description": "Plain English guide to setting up and understanding the DragonsPlugin and DragonsGame classes",
    "content": "Follow along with us by checking out the 🔗 [source code](https://github.com/BillyDotWS/studioexample-dragons)\n\n### DragonsPlugin\n\nThe `DragonsPlugin` class is the main entry point for the plugin. It sets up key modules and configurations for the \"Dragons\" game on the Mineplex platform. Below is a step-by-step breakdown of what each part does and how to set it up:\n\n🔗 [DragonsPlugin class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/DragonsPlugin.java)\n\n<Step>\n  <StepItem title=\"Logging Initialization\">\n    * The `@Slf4j` annotation enables logging functionality.\n    * Logs are added for important plugin actions, such as startup.\n\n    ```java\n    @Slf4j\r\n    public class DragonsPlugin extends JavaPlugin {\r\n\r\n        @Override\r\n        public void onEnable() {\r\n            DragonsPlugin.log.info(\"Starting plugin!\");\r\n            // Initialization steps go here\r\n        }\r\n\r\n        @Override\r\n        public void onDisable() {\r\n            this.lobbyModule.teardown();\r\n            this.gameModule.teardown();\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"onEnable Method: Log the Plugin Start\">\n    * Logs a message indicating the plugin has started.\n\n    ```java\n    DragonsPlugin.log.info(\"Starting plugin!\");\n    ```\n  </StepItem>\n\n  <StepItem title=\"Add Translation Support\">\n    * Fetch the Translations module and load available translations.\n    * Loop through each locale and add translations.\n\n    **We'll implement some translations in a further page!**\n\n    ```java\n    final I18NModule i18NModule = MineplexModuleManager.getRegisteredModule(I18NModule.class);\r\n    final String baseName = \"i18n.Dragons\";\r\n    for (final Locale locale : i18NModule.getAvailableLocales()) {\r\n        final ResourceBundle bundle = ResourceBundle.getBundle(baseName, locale, UTF8ResourceBundleControl.get());\r\n        i18NModule.addTranslation(locale, bundle, true);\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Load the Lobby World\">\n    * Fetch the `MineplexWorldModule`.\n    * Load a world template (stored in `world-templates/lobby.zip`).\n\n    🔗 [You can find our Lobby world in the example project](https://github.com/BillyDotWS/StudioExample-Dragons/tree/master/assets/world-templates)\n\n    🔗 [View more information about world loading](../../docs/sdk/features/world)\n\n    ```java\n    final MineplexWorldModule mineplexWorldModule =\r\n        MineplexModuleManager.getRegisteredModule(MineplexWorldModule.class);\r\n\r\n    final MineplexWorld lobby = mineplexWorldModule.createMineplexWorld(\r\n        MineplexWorldConfig.builder()\r\n                .worldCreationConfig(WorldCreationConfig.builder()\r\n                        .worldTemplate(\"lobby\")\r\n                        .build())\r\n                .build(),\r\n        null);\n    ```\n  </StepItem>\n\n  <StepItem title=\"Set up the Lobby module\">\n    First, we'll need to add a new field to our class:\n\n    ```java\n    private LobbyModule lobbyModule;\n    ```\n\n    This will allow us to have basic Lobby handling\n\n    🔗 [See more information on our Lobby Module](http://docs.mineplex.com/docs/sdk/features/lobby)\n\n    * Retrieve and configure the `LobbyModule`.\n    * Set the active lobby using the created `MineplexWorld` and finalize setup.\n\n    ```java\n    this.lobbyModule = MineplexModuleManager.getRegisteredModule(LobbyModule.class);\r\n    this.lobbyModule.setActiveLobby(this.lobbyModule.createBasicLobby(lobby));\r\n    this.lobbyModule.setup();\n    ```\n  </StepItem>\n\n  <StepItem title=\"Configure the Game Cycle\">\n    First, we'll need to add a field that stores our Game Module:\n\n    ```java\n    @Getter\r\n    private MineplexGameModule gameModule;\n    ```\n\n    This allows us to manage our Game: think of it as a game manager.\n\n    * Fetch the `MineplexGameModule`.\n    * Define the `GameCycle` and start the game.\n\n    🔗 [View more information about the Game cycle system](../../docs/sdk/features/game#game-cycle)\n\n    ```java\n    this.gameModule = MineplexModuleManager.getRegisteredModule(MineplexGameModule.class);\r\n    this.gameModule.setGameCycle(new GameCycle() {\r\n\r\n        private int gameCounter = 0;\r\n\r\n        @Override\r\n        public MineplexGame createNextGame() {\r\n            this.gameCounter++;\r\n            return new DragonsGame(DragonsPlugin.this);\r\n        }\r\n\r\n        @Override\r\n        public boolean hasNextGame() {\r\n            return this.gameCounter <= 5;\r\n        }\r\n    });\r\n\r\n    this.gameModule.startNextGame();\n    ```\n  </StepItem>\n</Step>\n\n### DragonsGame\n\nThe `DragonsGame` class represents a single instance of the \"Dragons\" game. It handles game-specific logic and player states. Here is how it works:\n\n🔗 [DragonsPlugin class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/DragonsGame.java)\n\n<Step>\n  <StepItem title=\"Fields and Dependencies\">\n    * **Game State Tracker**: Tracks the current state of the game, such as `PREPARING`.\n    * **Player State Tracker**: Keeps track of each player's state, e.g., `ALIVE`.\n    * **Game Mechanic Factory**: A reference to create game-specific mechanics.\n    * **Plugin Reference**: Stores a reference to `DragonsPlugin` for shared resources.\n\n    ```java\n    @Getter\r\n    @RequiredArgsConstructor\r\n    public class DragonsGame implements MineplexGame {\r\n\r\n        private final GameStateTracker gameStateTracker = new GameStateTracker(this, BuiltInGameState.PREPARING);\r\n        private final PlayerStateTracker playerStateTracker = new PlayerStateTracker(this, BuiltInPlayerState.ALIVE);\r\n        private final MineplexGameMechanicFactory gameMechanicFactory =\r\n                MineplexModuleManager.getRegisteredModule(MineplexGameMechanicFactory.class);\r\n\r\n        private final DragonsPlugin dragonsPlugin;\r\n\r\n        @Override\r\n        public @NonNull String getName() {\r\n            return \"Dragons\";\r\n        }\r\n\r\n        @Override\r\n        public @NonNull GameState getGameState() {\r\n            return this.gameStateTracker.getGameState();\r\n        }\r\n\r\n        @Override\r\n        public void setGameState(@NonNull GameState gameState) {\r\n            this.gameStateTracker.setGameState(gameState);\r\n        }\r\n\r\n        @Override\r\n        public @NonNull PlayerState getPlayerState(@NonNull Player player) {\r\n            return playerStateTracker.getPlayerState(player);\r\n        }\r\n\r\n        @Override\r\n        public void setup() {\r\n            // register the game as an event listener\r\n            dragonsPlugin.getServer().getPluginManager().registerEvents(this, dragonsPlugin);\r\n\r\n            // done preparing, allow players in!\r\n            this.setGameState(BuiltInGameState.PRE_START);\r\n        }\r\n\r\n        @Override\r\n        public void teardown() {\r\n            // stop listening to events in this class\r\n            HandlerList.unregisterAll(this);\r\n        }\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/polishing/experience/chat-rendering",
    "title": "Chat Rendering",
    "description": "Rendering levels and information about the player in chat",
    "content": "![Chat Rendering](/images/chat-formatting.png \"Chat Rendering\")\n\n### DragonsChatModule\n\nThe `DragonsChatModule` class customizes the chat functionality for the Dragons game. It modifies chat rendering and defines how messages are displayed to players. Here’s how to make it work:\n\n<Step>\n  <StepItem title=\"Class Definition\">\n    First, we need to create the class!\n\n    ```java\n    @MineplexModuleImplementation(DragonsChatModule.class)\r\n    public class DragonsChatModule implements MineplexModule {\r\n        @Override\r\n        public void setup() {\r\n            // Chat setup logic goes here\r\n        }\r\n\r\n        @Override\r\n        public void teardown() {\r\n            // Cleanup logic goes here\r\n        }\r\n    }\n    ```\n\n    🔗 [DragonsChatModule class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/modules/DragonsChatModule.java)\n\n    The `@MineplexModuleImplementation` annotation signifies which module we intend to set the behaviour of, in our case: `DragonsChatModule`\n  </StepItem>\n\n  <StepItem title=\"Register the module\">\n    In our main `DragonsPlugin` class, we'll register our module.\n\n    Within the `setup()` method, we'll add\n\n    ```java\n    MineplexModuleManager.getInstance().registerModule(new DragonsChatModule());\n    ```\n  </StepItem>\n\n  <StepItem title=\"Add our setup logic\">\n    Within our module, we'll be needing to fetch a couple of other modules to enable us to format the chat.\n\n    Retrieve Modules:\n\n    * Fetch the `MineplexGameModule` and `ChatModule` using `MineplexModuleManager#getRegisteredModule()`.\n\n    Audience Configuration:\n\n    * Configure the global chat channel (BuiltInChatChannel.GLOBAL) to broadcast messages to all online players.\n\n    ```java\n    final MineplexGameModule gameModule = MineplexModuleManager.getRegisteredModule(MineplexGameModule.class);\r\n    final ChatModule chatModule = MineplexModuleManager.getRegisteredModule(ChatModule.class);\r\n    chatModule.setAudienceFunction(BuiltInChatChannel.GLOBAL, sender -> Set.copyOf(Bukkit.getOnlinePlayers()));\n    ```\n  </StepItem>\n\n  <StepItem title=\"Add the custom renderer\">\n    Custom Chat Renderer:\n\n    * Define how chat messages are formatted and displayed to viewers.\n    * Create a `List<Component>` to build the chat message from multiple parts.\n\n    [View further documentation on Chat rendering](../../../docs/sdk/features/chat#chat-channels-1)\n\n    ```java\n    chatModule.setChatRenderer(BuiltInChatChannel.GLOBAL, (source, sourceDisplayName, message, viewer) -> {\r\n        final List<Component> components = new ArrayList<>();\r\n\r\n        // Add a dead player prefix if the player is not alive\r\n        if (!gameModule\r\n                .getCurrentGame()\r\n                .orElseThrow(() -> new RuntimeException(\"No game present!\"))\r\n                .getPlayerState(source)\r\n                .isAlive()) {\r\n            final Component deadPrefix = Component.translatable(\"mineplex.dragons.chat.ghost_prefix\");\r\n            components.add(deadPrefix);\r\n        }\r\n\r\n        // Retrieve and display the player's level and associated color\r\n        final MineplexPlayerExperience levelInfoObject = MineplexModuleManager.getRegisteredModule(MineplexLevelModule.class)\r\n                .getOnlinePlayerExperience(source)\r\n                .orElse(MineplexPlayerExperience.builder()\r\n                        .playerId(source.getUniqueId())\r\n                        .build());\r\n\r\n        final Component levelPrefix = Component.text(levelInfoObject.getLevel()).color(levelInfoObject.getLevelColor());\r\n        components.add(levelPrefix);\r\n\r\n        // Add the player's display name and chat message\r\n        components.add(sourceDisplayName);\r\n        components.add(message.color(NamedTextColor.WHITE));\r\n\r\n        // Combine all components into a single chat message\r\n        return Component.join(JoinConfiguration.spaces(), components);\r\n    });\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/polishing/experience",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/polishing",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/polishing/leaderboard",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/polishing/scoreboard",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/polishing/statistics",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/ended/end-message",
    "title": "EndedMessageListener",
    "description": "Listens for the end of the game and broadcasts the top 3 player placements, playing fireworks for the winner.",
    "content": "In this tutorial, we will walk through the implementation of the `EndedMessageListener` class. This listener handles the end of the game, broadcasting the top 3 placements and playing fireworks for the winner.\n\nThis listener is triggered only when the game reaches the `ENDED` state. It listens for game completions and processes the results.\n\n### Tutorial\n\n<Step>\n  <StepItem title=\"Create the EndedMessageListener class\">\n    Begin by creating the `EndedMessageListener` class. This listener will trigger when the game reaches the `ENDED` state and process the final placements.\n\n    🔗 [EndedMessageListener class source code](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/ended/EndedMessageListener.java)\n\n    Here’s the structure of the class:\n\n    ```java\n    public class EndedMessageListener extends AbstractStateBasedListener {\r\n        public EndedMessageListener(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.ENDED);\r\n        }\r\n    }\n    ```\n\n    * The `EndedMessageListener` class extends `AbstractStateBasedListener` and listens to the `ENDED` game state.\n  </StepItem>\n\n  <StepItem title=\"Reverse the placements list\">\n    In the `register` method, reverse the placements list so that the first 3 players are the last ones to be eliminated.\n\n    ```java\n    final List<OfflinePlayer> placements = this.game.getPlacements().reversed();\n    ```\n\n    * This reversal allows us to correctly display the 1st, 2nd, and 3rd place players in the final message.\n  </StepItem>\n\n  <StepItem title=\"Retrieve the top 3 players\">\n    Use `Optional` to safely retrieve the top 3 players from the reversed placements list.\n\n    ```java\n    final Optional<OfflinePlayer> first = Optional.ofNullable(!placements.isEmpty() ? placements.getFirst() : null);\r\n    final Optional<OfflinePlayer> second = Optional.ofNullable(placements.size() > 1 ? placements.get(1) : null);\r\n    final Optional<OfflinePlayer> third = Optional.ofNullable(placements.size() > 2 ? placements.get(2) : null);\n    ```\n\n    * This ensures that we don’t encounter errors if there are fewer than 3 players in the list.\n  </StepItem>\n\n  <StepItem title=\"Build the end message components\">\n    Construct the message components to display the top 3 players. Add different colors for 1st, 2nd, and 3rd places.\n\n    <Note type=\"success\">\n      We're skipping over adding translations this step, we've done this a few times already, so this should be simple!\n\n      🔗 [Complete translations file](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/resources/i18n/Dragons_en.properties)\n    </Note>\n\n    ```java\n    endComponents.add(GameMessages.GAME_HEADER_FOOTER);\r\n    endComponents.add(GAME_NAME_MESSAGE);\r\n    endComponents.add(Component.empty());\r\n    first.ifPresent(offlinePlayer -> endComponents.add(Component.translatable(\r\n                    \"mineplex.dragons.module.game.complete_position.1\",\r\n                    Component.text(Objects.requireNonNull(offlinePlayer.getName()))\r\n                            .decoration(TextDecoration.BOLD, false)\r\n                            .color(NamedTextColor.WHITE))\r\n            .color(NamedTextColor.RED)\r\n            .decorate(TextDecoration.BOLD)));\r\n    second.ifPresent(offlinePlayer -> endComponents.add(Component.translatable(\r\n                    \"mineplex.dragons.module.game.complete_position.2\",\r\n                    Component.text(Objects.requireNonNull(offlinePlayer.getName()))\r\n                            .decoration(TextDecoration.BOLD, false)\r\n                            .color(NamedTextColor.WHITE))\r\n            .color(NamedTextColor.GOLD)\r\n            .decorate(TextDecoration.BOLD)));\r\n    third.ifPresent(offlinePlayer -> endComponents.add(Component.translatable(\r\n                    \"mineplex.dragons.module.game.complete_position.3\",\r\n                    Component.text(Objects.requireNonNull(offlinePlayer.getName()))\r\n                            .decoration(TextDecoration.BOLD, false)\r\n                            .color(NamedTextColor.WHITE))\r\n            .color(NamedTextColor.YELLOW)\r\n            .decorate(TextDecoration.BOLD)));\n    ```\n\n    * This code formats the text to display each player's position and name with corresponding colors (Red for 1st, Gold for 2nd, and Yellow for 3rd).\n  </StepItem>\n\n  <StepItem title=\"Broadcast the end message\">\n    After building the components, broadcast the message to the server, using newlines to separate each component.\n\n    ```java\n    Bukkit.broadcast(Component.join(JoinConfiguration.newlines(), endComponents));\n    ```\n\n    * This ensures the message is displayed with proper spacing between the components.\n  </StepItem>\n\n  <StepItem title=\"Register the listener\">\n    Finally, we need to register the `EndedMessageListener` in the `DragonsGame` class.\n\n    Add the listener registration to the setup method in the `DragonsGame` class:\n\n    ```java\n    this.listeners.add(new EndedMessageListener(this, this.dragonsPlugin));\n    ```\n\n    * This adds the `EndedMessageListener` to the list of listeners in the game, ensuring it is triggered during the `ENDED` game state.\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/ended",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/ended/queuing",
    "title": "QueueAgainListener",
    "description": "Listens for the game to end and re-queues players to a new game or shuts down the server if no games are left.",
    "content": "In this tutorial, we will go through the implementation of the `QueueAgainListener` class. This listener handles the re-queuing of players into a new game after the current game ends.\n\nThis listener is triggered when the game reaches the `ENDED` state. It manages the re-queuing of players to continue playing or shuts down the server if no more games are available.\n\n### Tutorial\n\n<Step>\n  <StepItem title=\"Create the QueueAgainListener class\">\n    Begin by creating the `QueueAgainListener` class. This listener will be triggered when the game ends and will re-queue players into a new game or shut down the server.\n\n    🔗 [QueueAgainListener class source code](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/ended/QueueAgainListener.java)\n\n    Here’s the structure of the class:\n\n    ```java\n    @Slf4j\r\n    public class QueueAgainListener extends AbstractStateBasedListener {\r\n        public QueueAgainListener(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.ENDED);\r\n        }\r\n    }\n    ```\n\n    * The `QueueAgainListener` class extends `AbstractStateBasedListener` and listens to the `ENDED` game state.\n  </StepItem>\n\n  <StepItem title=\"Initialize the Queuing module\">\n    Initialize the `QueuingModule` in our fields to manage the re-queuing of players:\n\n    ```java\n    private final QueuingModule queueModule = MineplexModuleManager.getRegisteredModule(QueuingModule.class);\n    ```\n\n    * This module handles the process of adding players to the game queue for a new round.\n  </StepItem>\n\n  <Note type=\"success\">\n    We're skipping over adding translations further steps, we've done this a few times already, so this should be simple!\n\n    🔗 [Complete translations file](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/resources/i18n/Dragons_en.properties)\n  </Note>\n\n  <StepItem title=\"Define the BukkitTask for player notifications\">\n    Create a `BukkitRunnable` task that runs 5 seconds after the game ends. It will send a message to all online players, notifying them about their re-queue status.\n\n    ```java\n    new BukkitRunnable() {\r\n        @Override\r\n        public void run() {\r\n            Bukkit.getOnlinePlayers().forEach(p -> {\r\n                final boolean isArcadePlayer = QueueAgainListener.this.queueModule.joinedThroughTag(p, \"arcade\");\r\n                final Component newLocation = Component.text(isArcadePlayer ? \"Mixed Arcade\" : \"Dragons\")\r\n                        .color(NamedTextColor.YELLOW);\r\n                p.sendMessage(Component.join(\r\n                        JoinConfiguration.spaces(),\r\n                        PrefixUtil.getPrefix(\"Portal\"),\r\n                        Component.translatable(\"mineplex.dragons.module.portal.queued_again_message\", newLocation)\r\n                                .color(NamedTextColor.GRAY)));\r\n                QueueAgainListener.this\r\n                        .queueModule\r\n                        .requeuePlayer(p)\r\n                        .thenAcceptAsync(ignored -> log.info(\"Re-queued {} into a new game\", p.getName()));\r\n            });\r\n        }\r\n    }.runTaskLater(this.plugin, 20 * 5);\n    ```\n\n    * This task sends a message to the player and then re-queues them into a new game.\n  </StepItem>\n\n  <StepItem title=\"Define the BukkitTask for action bar notifications\">\n    Create another `BukkitRunnable` task that runs repeatedly, sending action bar notifications to all online players while they are waiting for a new game.\n\n    ```java\n    this.bukkitTask = new BukkitRunnable() {\r\n        @Override\r\n        public void run() {\r\n            if (!Bukkit.getOnlinePlayers().isEmpty()) {\r\n                for (final Player player : Bukkit.getOnlinePlayers()) {\r\n                    player.sendActionBar(\r\n                            Component.translatable(\"mineplex.dragons.module.portal.finding_server_actionbar\")\r\n                                    .color(NamedTextColor.GREEN));\r\n                }\r\n            } else {\r\n                if (!QueueAgainListener.this\r\n                        .plugin\r\n                        .getGameModule()\r\n                        .getGameCycle()\r\n                        .get()\r\n                        .hasNextGame()) {\r\n                    Bukkit.shutdown();\r\n                    return;\r\n                }\r\n                QueueAgainListener.this.plugin.getGameModule().startNextGame();\r\n                this.cancel();\r\n            }\r\n        }\r\n    }.runTaskTimer(this.plugin, 20 * 5, 5);\n    ```\n\n    * This task sends an action bar message to players every 5 seconds, informing them that the system is finding a server for the next game.\n  </StepItem>\n\n  <StepItem title=\"Shutdown or start next game\">\n    If there are no players online, check if the game cycle has more games to play. If there are no more games, shut down the server. Otherwise, start the next game.\n\n    ```java\n    if (!QueueAgainListener.this\r\n            .plugin\r\n            .getGameModule()\r\n            .getGameCycle()\r\n            .get()\r\n            .hasNextGame()) {\r\n        Bukkit.shutdown();\r\n        return;\r\n    }\r\n    QueueAgainListener.this.plugin.getGameModule().startNextGame();\n    ```\n\n    * This ensures that the server either continues to the next game or shuts down if no games are available.\n  </StepItem>\n\n  <StepItem title=\"Unregister the listener\">\n    Finally, unregister the listener and cancel the tasks when the listener is disabled.\n\n    ```java\n    this.bukkitTask.cancel();\r\n    this.bukkitTask = null;\n    ```\n\n    * This prevents the tasks from continuing to run after the listener is no longer active.\n  </StepItem>\n\n  <StepItem title=\"Register the listener\">\n    Finally, we need to register the `QueueAgainListener` in the `DragonsGame` class.\n\n    Add the listener registration to the setup method in the `DragonsGame` class:\n\n    ```java\n    this.listeners.add(new QueueAgainListener(this, this.dragonsPlugin));\n    ```\n\n    * This adds the `QueueAgainListener` to the list of listeners in the game, ensuring it is triggered during the `ENDED` game state.\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/in-progress/death",
    "title": "Player Death Listener",
    "description": "Handles player deaths, teleporting to spectators, and ending the game based on player count.",
    "content": "In this tutorial, we will walk through the implementation of the `PlayerDeathListener`. This listener handles player deaths during the `STARTED` game state by:\n\n* Teleporting players to the spectator spawnpoint.\n* Changing player states to \"eliminated\".\n* Handling damage events related to dragon wings.\n* Announcing player deaths.\n* Managing game state transitions based on player count.\n\n<Note title=\"Cuboid class\" type=\"success\">\n  The Cuboid class would take up a lot of space, check out our implementation here:\n\n  🔗 [Cuboid class source code](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/java/com/mineplex/studio/dragons/objects/Cuboid.java)\n\n  You'll need to add this to continue, as it's required to create a border.\n</Note>\n\n### Tutorial\n\n<Step>\n  <StepItem title=\"Create the PlayerDeathListener Class\">\n    Begin by creating the `PlayerDeathListener` class. This listener will be triggered during the `STARTED` game state, allowing us to handle player deaths appropriately.\n\n    Here’s the structure of the class:\n\n    ```java\n    @Slf4j\r\n    public class PlayerDeathListener extends AbstractStateBasedListener {\r\n        private final Cuboid border;\r\n        private BukkitTask bukkitTask;\r\n\r\n        public PlayerDeathListener(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.STARTED);\r\n            this.border = new Cuboid(\r\n                    game.getGameWorld().getDataPoints(\"BORDER\").getFirst(),\r\n                    game.getGameWorld().getDataPoints(\"BORDER\").getLast());\r\n        }\r\n    }\n    ```\n\n    * The `PlayerDeathListener` class extends `AbstractStateBasedListener`, ensuring it listens to the `STARTED` game state.\n    * The `border` is a `Cuboid` representing the playable area, preventing players from leaving the game world.\n\n    🔗 [PlayerDeathListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/death/PlayerDeathListener.java)\n  </StepItem>\n\n  <StepItem title=\"Add a method to get the spectator spawnpoint\">\n    In our `DragonsGame` class, we'll add a method to get the Spectator spawnpoint\n\n    ```java\n    public Location getSpectatorLocation() {\r\n        return this.getGameWorld().getMinecraftWorld().getSpawnLocation();\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Handle Player Deaths\">\n    Back in PlayerDeathListener, we'll handle player deaths. When a player dies, their health is reset, and they are teleported to the spectator location. Additionally, the player's state is changed to \"eliminated.\"\n\n    Here’s the `handleDeathEvent` method:\n\n    ```java\n    @EventHandler\r\n    public void handleDeathEvent(final PlayerDeathEvent deathEvent) {\r\n        deathEvent.deathMessage(Component.empty()); // Hide default death message\r\n        deathEvent.getPlayer().setHealth(20); // Reset health to full\r\n        deathEvent.getPlayer().teleport(this.game.getSpectatorLocation()); // Teleport to spectator area\r\n        if (this.game.getPlayerState(deathEvent.getPlayer()).isAlive()) {\r\n            this.game.getPlayerStateTracker().setPlayerState(deathEvent.getPlayer(), BuiltInPlayerState.ELIMINATED);\r\n            this.announceDeath(deathEvent.getPlayer(), deathEvent.getDamageSource().getDirectEntity());\r\n        }\r\n    }\n    ```\n\n    * The player's health is reset to 20, and the default death message is cleared.\n    * The player is then teleported to the spectator area.\n    * If the player was alive before dying, their state is changed to \"ELIMINATED\", and the death is announced.\n  </StepItem>\n\n  <StepItem title=\"Create a placements list\">\n    This placements list will help us determine who dies in what order when we come to implementing our win handler.\n\n    In the `DragonsGame` class, add a placements field.\n\n    ```java\n    private final List<OfflinePlayer> placements = new ArrayList<>();\n    ```\n  </StepItem>\n\n  <StepItem title=\"Handle death messages\">\n    Add logic to handle the death message and update placements within our PlayerDeathListener class:\n\n    ```java\n    @EventHandler\r\n    public void handleDeathMessage(final PlayerStateChangeEvent changeEvent) {\r\n        if (!changeEvent.getToState().isAlive() && changeEvent.getToState().isGameParticipant()) {\r\n            this.game.getPlacements().add(changeEvent.getPlayer());\r\n        }\r\n    }\n    ```\n\n    * This event handler listens for state changes, and if a player is eliminated, they are added to the placements list for scoring.\n  </StepItem>\n\n  <StepItem title=\"Handle Dragon Wing Flap Damage\">\n    We also need to handle any damage caused by the dragon's wing flap. If the damage comes from an entity explosion (e.g., the dragon), we cancel it.\n\n    ```java\n    @EventHandler\r\n    public void onPlayerDamageByDragonWingFlap(final EntityDamageEvent event) {\r\n        if (event.getEntity() instanceof Player && event.getCause() == EntityDamageEvent.DamageCause.ENTITY_EXPLOSION) {\r\n            event.setCancelled(true); // Cancel damage from dragon wing flap\r\n        }\r\n    }\n    ```\n\n    * This event cancels damage events caused by dragon-related explosions, preventing players from being eliminated by environmental damage.\n  </StepItem>\n\n  <StepItem title=\"Announce Deaths\">\n    To announce player deaths, we create a helper method that broadcasts the death message to the entire server.\n\n    ```java\n    private void announceDeath(final Player player, final Entity killer) {\r\n        if (killer != null && killer.customName() == null) {\r\n            return;\r\n        }\r\n        Bukkit.broadcast(Component.join(\r\n                JoinConfiguration.spaces(),\r\n                PrefixUtil.getPrefix(\"Death\"),\r\n                killer == null\r\n                        ? Component.translatable(\r\n                                \"mineplex.dragons.module.death.message_generic\",\r\n                                player.displayName().color(NamedTextColor.YELLOW))\r\n                        .color(NamedTextColor.GRAY)\r\n                        : Component.translatable(\r\n                                \"mineplex.dragons.module.death.message\",\r\n                                player.displayName().color(NamedTextColor.YELLOW),\r\n                                Objects.requireNonNull(killer.customName()))\r\n                        .color(NamedTextColor.GRAY)));\r\n    }\n    ```\n\n    * This method constructs a message based on whether the player was killed by another player or by something else. The message is then broadcast to all players.\n  </StepItem>\n\n  <StepItem title=\"Manage Game State Transitions\">\n    Finally, we need to check if the game should end based on the number of players. We do this by adding a scheduled task that checks the player count every 2 ticks.\n\n    ```java\n    @Override\r\n    public void register() {\r\n        super.register();\r\n        this.bukkitTask = new BukkitRunnable() {\r\n            @Override\r\n            public void run() {\r\n                // check if players are inside the border\r\n                for (final Player player : Bukkit.getOnlinePlayers()) {\r\n                    final PlayerState playerState = PlayerDeathListener.this.game.getPlayerState(player);\r\n\r\n                    if (!playerState.isAlive() && !PlayerDeathListener.this.border.isIn(player)) {\r\n                        player.teleport(PlayerDeathListener.this.game.getSpectatorLocation());\r\n                        continue;\r\n                    }\r\n\r\n                    if (playerState.isAlive() && !PlayerDeathListener.this.border.isIn(player)) {\r\n                        PlayerDeathListener.this\r\n                                .game\r\n                                .getPlayerStateTracker()\r\n                                .setPlayerState(player, BuiltInPlayerState.ELIMINATED);\r\n                        PlayerDeathListener.this.announceDeath(player, null);\r\n                    }\r\n                }\r\n\r\n                // Check if only one player is left\r\n                if (PlayerDeathListener.this.getAlivePlayers().size() == 1) {\r\n                    PlayerDeathListener.this\r\n                            .game\r\n                            .getPlacements()\r\n                            .add(PlayerDeathListener.this.getAlivePlayers().getFirst());\r\n                    PlayerDeathListener.this.game.setGameState(BuiltInGameState.ENDED);\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                // If no players are left, end the game\r\n                if (PlayerDeathListener.this.getAlivePlayers().isEmpty()) {\r\n                    PlayerDeathListener.this.game.setGameState(BuiltInGameState.ENDED);\r\n                }\r\n            }\r\n        }.runTaskTimer(this.plugin, 2, 2);\r\n    }\n    ```\n\n    * This `BukkitRunnable` checks every 2 ticks if players are within the border and eliminates those who are outside.\n    * If only one player remains, the game ends, and the winner is placed in the placements list.\n    * If no players are left, the game also ends.\n  </StepItem>\n\n  <StepItem title=\"Register the Listener\">\n    Finally, we need to register the `PlayerDeathListener` in the `DragonsGame` class.\n\n    Add the listener registration to the setup method in the `DragonsGame` class:\n\n    ```java\n    this.listeners.add(new PlayerDeathListener(this, this.dragonsPlugin));\n    ```\n\n    * This adds the `PlayerDeathListener` to the list of listeners in the game, ensuring it is active during the `STARTED` game state.\n  </StepItem>\n</Step>\n\n### Testing and Final Steps\n\nAfter following the above steps, test the listener by:\n\n* Ensuring that players are teleported to the spectator area upon death.\n* Verifying that players outside the border are eliminated and teleported to the spectator area.\n* Checking that the game ends when only one player remains or when no players are left.\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/in-progress/disable-hunger",
    "title": "Disable Hunger Listener",
    "description": "Prevents hunger from affecting players during the `STARTED` game state.",
    "content": "In this tutorial, we will walk through the implementation of the `DisableHungerListener`, which prevents hunger from affecting players during the `STARTED` game state. This ensures that players won’t experience hunger depletion while playing.\n\n<Step>\n  <StepItem title=\"Create the DisableHungerListener class\">\n    The first step is to create the `DisableHungerListener` class that will listen for the `STARTED` game state. This listener will handle preventing hunger depletion during the game.\n\n    Here’s the basic structure of the class:\n\n    ```java\n    public class DisableHungerListener extends AbstractStateBasedListener {\r\n        public DisableHungerListener(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.STARTED);\r\n        }\r\n\r\n        @EventHandler\r\n        public static void handleHunger(final FoodLevelChangeEvent foodLevelChangeEvent) {\r\n            foodLevelChangeEvent.setFoodLevel(20); // Full food level\r\n            foodLevelChangeEvent.setCancelled(true); // Cancel the event to prevent hunger decrease\r\n        }\r\n    }\n    ```\n\n    🔗 [DisableHungerListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/DisableHungerListener.java)\n\n    * This class extends `AbstractStateBasedListener` to ensure the listener is triggered when the game enters the `STARTED` state.\n    * The `handleHunger` method listens for the `FoodLevelChangeEvent`, which is fired whenever a player's hunger level changes.\n  </StepItem>\n\n  <StepItem title=\"Handling the hunger event\">\n    Inside the `handleHunger` method, we prevent hunger by setting the food level to 20 (the maximum level) and cancelling the event.\n\n    Here’s the implementation again for clarity:\n\n    ```java\n    @EventHandler\r\n    public static void handleHunger(final FoodLevelChangeEvent foodLevelChangeEvent) {\r\n        foodLevelChangeEvent.setFoodLevel(20); // Full food level\r\n        foodLevelChangeEvent.setCancelled(true); // Cancel the event\r\n    }\n    ```\n\n    * `foodLevelChangeEvent.setFoodLevel(20)`: This sets the player's food level to full (20).\n    * `foodLevelChangeEvent.setCancelled(true)`: This cancels the event, preventing the player's hunger from decreasing.\n\n    This ensures that hunger is effectively disabled during the game.\n  </StepItem>\n\n  <StepItem title=\"Register the listener in the DragonsGame class\">\n    In order for the `DisableHungerListener` to be registered and run during the `STARTED` state, we need to add it to the list of listeners in the `DragonsGame` class.\n\n    Update the `setup` method of the `DragonsGame` class to register the listener:\n\n    ```java\n    this.listeners.add(new DisableHungerListener(this, this.dragonsPlugin));\n    ```\n\n    * `this.listeners.add(...)`: This adds the `DisableHungerListener` to the list of listeners, ensuring that it will be executed when the game enters the `STARTED` state.\n  </StepItem>\n\n  <StepItem title=\"Test the Hunger Listener\">\n    Once the listener is implemented and registered, you can test it by:\n\n    1. Starting the game to trigger the `STARTED` state.\n    2. Observing that players' food levels remain at 20 regardless of any actions that would normally deplete hunger (e.g., running, jumping, etc.).\n    3. Verifying that hunger does not decrease during the game.\n\n    **Troubleshooting Tips:**\n\n    * Ensure the listener is correctly registered in the `DragonsGame` class setup method.\n    * Double-check that the `FoodLevelChangeEvent` is being correctly intercepted and cancelled.\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/in-progress",
    "title": "In Progress Listeners",
    "description": "Listeners that handle game behavior during the `STARTED` state.",
    "content": "Once the game transitions to the `STARTED` state, players begin playing the game. During this phase, we'll need to handle various in-game events with listeners.\n\nIn this tutorial, we’ll cover the following listeners:\n\n* Disabling hunger for players\n* Teleporting players to the game map\n* Handling the game start message\n* Handling player death messages\n* Changing players to spectator mode when they die\n* Handling spectators\n\nLater in this tutorial, we’ll dive into more advanced topics, including:\n\n* Dragon spawning mechanics\n* Sparkler dropping effects\n\nLet’s get started by implementing these listeners to manage the gameplay experience!\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/in-progress/spectator",
    "title": "Spectator Mode Listener",
    "description": "Manages players in spectator mode during the game, including handling player interactions, item pickups, and rejoining the game.",
    "content": "In this tutorial, we will walk through the implementation of the `SpectatorHandler` class. This listener handles players in spectator mode during the `STARTED` game state by:\n\n* Preventing certain player actions like damage, block interaction, item pickup, and inventory edits.\n* Managing the player's appearance and behavior when they enter spectator mode.\n* Allowing players to rejoin the game or the arcade queue by interacting with specific items.\n\n<Note type=\"success\">\n  We're skipping over adding translations in our future steps, we've done this a few times already, so this should be simple!\n\n  🔗 [Complete translations file](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/resources/i18n/Dragons_en.properties)\n</Note>\n\n### Tutorial\n\n<Step>\n  <StepItem title=\"Create the SpectatorHandler Class\">\n    Begin by creating the `SpectatorHandler` class. This class will manage spectator behaviors and interactions during the game. It extends `AbstractStateBasedListener` to listen for events while the game state is `STARTED`.\n\n    🔗 [SpectatorHandler class source code](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/spectator/SpectatorHandler.java)\n\n    Here's the basic structure of the class:\n\n    ```java\n    @Slf4j\r\n    public class SpectatorHandler extends AbstractStateBasedListener {\r\n        private static final ItemStack PLAY_AGAIN_PAPER;\r\n        private static final ItemStack PLAY_AGAIN_ARCADE_JUKEBOX;\r\n        private final QueuingModule queuingModule = MineplexModuleManager.getRegisteredModule(QueuingModule.class);\r\n\r\n        public SpectatorHandler(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.STARTED);\r\n        }\r\n\r\n        static {\r\n            PLAY_AGAIN_PAPER = new ItemStack(Material.PAPER);\r\n            PLAY_AGAIN_PAPER.editMeta(meta -> {\r\n                meta.displayName(Component.translatable(\"mineplex.dragons.module.game.spectator.item.paper_name\")\r\n                        .color(NamedTextColor.AQUA));\r\n            });\r\n\r\n            PLAY_AGAIN_ARCADE_JUKEBOX = new ItemStack(Material.JUKEBOX);\r\n            PLAY_AGAIN_ARCADE_JUKEBOX.editMeta(meta -> {\r\n                meta.displayName(Component.translatable(\"mineplex.dragons.module.game.spectator.item.jukebox_name\")\r\n                        .color(NamedTextColor.GREEN));\r\n            });\r\n        }\r\n    }\n    ```\n\n    * This class listens for events related to player actions during the spectator mode and sets up items for rejoining the game.\n  </StepItem>\n\n  <StepItem title=\"Add a method to check if the player is alive\">\n    This will be used in our future event handlers.\n\n    ```java\n    private boolean isAlive(final Player player) {\r\n        return this.game.getPlayerState(player).isAlive();\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Handle player damage\">\n    We need to prevent damage to players who are in spectator mode. Here's how you can cancel any damage events for players who are not alive:\n\n    ```java\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleDamageToSelf(final EntityDamageEvent e) {\r\n        if (!(e.getEntity() instanceof Player player)) return;\r\n        if (this.isAlive(player)) return;\r\n        e.setCancelled(true);\r\n    }\r\n\r\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleDamageToOthers(final EntityDamageByEntityEvent e) {\r\n        if (!(e.getDamager() instanceof Player player)) return;\r\n        if (this.isAlive(player)) return;\r\n        e.setCancelled(true);\r\n    }\n    ```\n\n    * These methods check if the player is alive and, if not, cancel any damage events.\n  </StepItem>\n\n  <StepItem title=\"Prevent block interaction\">\n    Spectators should not be able to interact with blocks. Here's how to cancel block-related actions for spectators:\n\n    ```java\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleBlockBreak(final BlockBreakEvent event) {\r\n        if (this.isAlive(event.getPlayer())) return;\r\n        event.setCancelled(true);\r\n    }\r\n\r\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleBlockPlace(final BlockPlaceEvent event) {\r\n        if (this.isAlive(event.getPlayer())) return;\r\n        event.setCancelled(true);\r\n    }\n    ```\n\n    * These handlers prevent spectators from breaking or placing blocks.\n  </StepItem>\n\n  <StepItem title=\"Disable item pickup and inventory edits\">\n    Spectators should also be prevented from picking up items or editing their inventory. Here's how:\n\n    ```java\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleItemPickup(final PlayerPickupItemEvent event) {\r\n        if (this.isAlive(event.getPlayer())) return;\r\n        event.setCancelled(true);\r\n    }\r\n\r\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleDrop(final PlayerDropItemEvent event) {\r\n        if (this.isAlive(event.getPlayer())) return;\r\n        event.setCancelled(true);\r\n    }\r\n\r\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleInventoryEdit(final PlayerInteractEvent event) {\r\n        if (this.isAlive(event.getPlayer())) return;\r\n        event.setCancelled(true);\r\n    }\n    ```\n\n    * These methods ensure that spectators cannot pick up items or interact with their inventory.\n  </StepItem>\n\n  <StepItem title=\"Make player a spectator\">\n    When a player dies or is assigned to spectator mode, we make them a true spectator by applying specific effects:\n\n    ```java\n    private void makePlayerSpectator(final Player player) {\r\n        player.clearActivePotionEffects();\r\n        player.addPotionEffect(new PotionEffect(PotionEffectType.DARKNESS, 20, 1));\r\n        player.setInvisible(true);\r\n        player.setInvulnerable(true);\r\n        player.setFoodLevel(20);\r\n        player.setVisualFire(false);\r\n        player.setAllowFlight(true);\r\n        player.setFlying(true);\r\n    }\n    ```\n\n    * This method clears the player's active effects, makes them invisible, and grants flight abilities.\n\n    Call this method from an event handler that reacts to a player's state changing:\n\n    ```java\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void spectatorMode(final PlayerStateChangeEvent e) {\r\n        if (e.getToState().isAlive()) {\r\n            return;\r\n        }\r\n        this.makePlayerSpectator(e.getPlayer());\r\n        this.setPlayerSpecInventory(e.getPlayer());\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Set player's spectator inventory\">\n    Spectators should have a specific inventory, typically with items to rejoin the game. Here's how you can set the inventory:\n\n    ```java\n    private void setPlayerSpecInventory(final Player player) {\r\n        player.getInventory().clear();\r\n\r\n        if (this.queuingModule.joinedThroughTag(player, \"arcade\")) {\r\n            player.getInventory().setItem(0, PLAY_AGAIN_ARCADE_JUKEBOX.clone());\r\n        }\r\n\r\n        player.getInventory().setItem(8, PLAY_AGAIN_PAPER.clone());\r\n    }\n    ```\n\n    * This method sets the player's inventory with items like \"Play Again\" paper and arcade jukebox, based on their current state.\n  </StepItem>\n\n  <StepItem title=\"Handle requeue click\">\n    When a spectator clicks an item in their inventory, we allow them to rejoin the game or arcade queue.\n\n    <Note type=\"success\" title=\"Tag queue\">\n      Because our game is an Arcade game, we allow people to join via the `Arcade` tag rotation. We want to show a special inventory item if they joined using this system. This allows people to re-join the rotation. **This is required for all Arcade games**\n\n      🔗 [Tag queuing documentation](http://docs.mineplex.com/docs/sdk/features/queueing#tag-queue)\n    </Note>\n\n    Here's how to handle it:\n\n    ```java\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void handleRequeueClick(final PlayerInteractEvent e) {\r\n        if (e.getAction() != Action.RIGHT_CLICK_AIR && e.getAction() != Action.RIGHT_CLICK_BLOCK) return;\r\n\r\n        if (e.getPlayer().getInventory().getItemInMainHand().isSimilar(PLAY_AGAIN_PAPER)) {\r\n            this.queuingModule.requeuePlayer(e.getPlayer());\r\n        }\r\n\r\n        if (e.getPlayer().getInventory().getItemInMainHand().isSimilar(PLAY_AGAIN_ARCADE_JUKEBOX)) {\r\n            this.queuingModule.requeuePlayer(e.getPlayer());\r\n        }\r\n    }\n    ```\n\n    * This event listens for right-click interactions on specific items (e.g., play again items) to trigger a requeue.\n  </StepItem>\n\n  <StepItem title=\"Make player spectator upon joining\">\n    When a player joins and enters spectator mode, we ensure they are set up properly:\n\n    ```java\n    @EventHandler(priority = EventPriority.HIGH)\r\n    public void join(final PlayerJoinEvent e) {\r\n        this.game.getPlayerStateTracker().setPlayerState(e.getPlayer(), BuiltInPlayerState.SPECTATOR);\r\n        new BukkitRunnable() {\r\n            @Override\r\n            public void run() {\r\n                SpectatorHandler.this.makePlayerSpectator(e.getPlayer());\r\n            }\r\n        }.runTaskLater(this.plugin, 20);\r\n    }\n    ```\n\n    * This method ensures the player is set as a spectator immediately after joining.\n  </StepItem>\n\n  <StepItem title=\"Register the listener\">\n    Finally, register the `SpectatorHandler` in the `DragonsGame` class. This ensures the spectator logic is applied during the `STARTED` game state.\n\n    Within the setup method, we add:\n\n    ```java\n    this.listeners.add(new SpectatorHandler(this, this.dragonsPlugin));\n    ```\n\n    * This will make sure the `SpectatorHandler` is active and listening for events.\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/in-progress/start-teleport",
    "title": "Start Teleport and Message Listener",
    "description": "Handle player teleportation and broadcasting the start message during the `STARTED` state.",
    "content": "In this tutorial, we'll break down the flow of teleporting players and broadcasting the start message into clear steps.\n\n<Step>\n  <StepItem title=\"Create the StartTeleportMessageListener class\">\n    We will begin by creating the `StartTeleportMessageListener` class that will listen for the `STARTED` game state. This listener will handle teleporting players to their designated spawn points and broadcasting a start message.\n\n    Here’s the basic structure of the class:\n\n    ```java\n    public class StartTeleportMessageListener extends AbstractStateBasedListener {\r\n\r\n        public StartTeleportMessageListener(final DragonsGame game, final DragonsPlugin plugin) {\r\n            super(plugin, game, BuiltInGameState.STARTED);\r\n        }\r\n\r\n        @Override\r\n        public void register() {\r\n            // Implement logic here later\r\n        }\r\n    }\n    ```\n\n    This class extends `AbstractStateBasedListener` to automatically handle game state transitions and ensures that the listener will be triggered when the game enters the `STARTED` state.\n\n    🔗 [StartTeleportMessageListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/inprogress/StartTeleportMessageListener.java)\n  </StepItem>\n\n  <StepItem title=\"Set up spawn point retrieval\">\n    The next step is to retrieve the spawn points for players. We will create a method that fetches spawn points based on the player's index.\n\n    Add the following method to your class to get the spawn point for each player:\n\n    ```java\n    private Location getSpawnPoint(final int playerIndex) {\r\n        return this.game.getGameWorld().getDataPoints(\"SPAWNPOINTS\")\r\n                .get(playerIndex);\r\n    }\n    ```\n\n    This method retrieves the spawn point for a player using their index. The spawn points are stored in the world’s data points and can be accessed via the key `\"SPAWNPOINTS\"`.\n\n    * `getGameWorld().getDataPoints(\"SPAWNPOINTS\")`: This retrieves a list of spawn points.\n    * The `playerIndex` is used to map each player to their corresponding spawn point.\n  </StepItem>\n\n  <StepItem title=\"Teleport players to spawn points\">\n    Now that we have the spawn points, we can teleport players to their respective locations.\n\n    Update the `register` method to iterate through all online players, set their display names, and teleport them to their spawn points:\n\n    ```java\n    @Override\r\n    public void register() {\r\n        int index = 0;\r\n        for (final Player player : Bukkit.getOnlinePlayers()) {\r\n            // Set player list and chat name colors to make them stand out\r\n            player.displayName(player.displayName().color(NamedTextColor.YELLOW));\r\n            player.playerListName(player.displayName().color(NamedTextColor.YELLOW));\r\n\r\n            // Teleport player to their spawn point\r\n            player.teleport(this.getSpawnPoint(index));\r\n            index++;\r\n        }\r\n    }\n    ```\n\n    * We iterate over each online player and assign them a yellow display name.\n    * We teleport each player to their spawn point using `getSpawnPoint(index)`.\n\n    This ensures that every player is in the correct location before the game starts.\n  </StepItem>\n\n  <StepItem title=\"Create GameMessages constants class\">\n    So that we have a central place for all our game messages, let's create a GameMessages constant class:\n\n    ```java\n    @UtilityClass\r\n    public class GameMessages {\r\n\r\n        public static Component GAME_HEADER_FOOTER = Component.text(\"=============================================\")\r\n                .color(NamedTextColor.DARK_GREEN)\r\n                .decorate(TextDecoration.STRIKETHROUGH);\r\n\r\n        public static Component GAME_NAME_MESSAGE = Component.translatable(\r\n                        \"mineplex.dragons.module.game.game_name_message\",\r\n                        Component.text(\"Dragons\").decorate(TextDecoration.BOLD).color(NamedTextColor.WHITE))\r\n                .color(NamedTextColor.GREEN);\r\n    }\n    ```\n\n    🔗 [GameMessages class source code](https://github.com/BillyDotWS/StudioExample-Dragons/blob/master/src/main/java/com/mineplex/studio/dragons/utils/GameMessages.java)\n  </StepItem>\n\n  <StepItem title=\"Create start message components\">\n    Next, we will create the message components that will be broadcast to all players once the game starts. These messages will include the game description, the game header/footer, and other important details.\n\n    Add the following static field to your class:\n\n    ```java\n    private static final List<String> GAME_DESCRIPTION = List.of(\r\n            \"mineplex.dragons.module.game.description.1\",\r\n            \"mineplex.dragons.module.game.description.2\",\r\n            \"mineplex.dragons.module.game.description.3\");\n    ```\n\n    Then within the register logic (after the previous step's loop)\n\n    ```java\n    final List<Component> startComponents = new ArrayList<>();\r\n    startComponents.add(GameMessages.GAME_HEADER_FOOTER);\r\n    startComponents.add(GAME_NAME_MESSAGE);\r\n    startComponents.add(Component.empty());\r\n    for (final String key : GAME_DESCRIPTION) {\r\n        startComponents.add(Component.translatable(key));\r\n    }\r\n    startComponents.add(Component.empty());\r\n    startComponents.add(GameMessages.GAME_HEADER_FOOTER);\n    ```\n\n    * We define a list of strings (`GAME_DESCRIPTION`) containing the keys for our localized game description messages.\n    * These components are added to a `startComponents` list, which is later used to broadcast the message.\n\n    Next, we'll have to add these translations to our `Dragons_en.properties` file within our resources directory.\n\n    ```properties\n    mineplex.dragons.module.game.description.1=You have angered the Dragons!\r\n    mineplex.dragons.module.game.description.2=Survive as long as you can!\r\n    mineplex.dragons.module.game.description.3=The Last player alive will win!\n    ```\n  </StepItem>\n\n  <StepItem title=\"Broadcast the game start message\">\n    Now that we have our start message components, we will broadcast the message to all players using `Bukkit.broadcast()`.\n\n    Add the following code to broadcast the start message:\n\n    ```java\n    Bukkit.broadcast(Component.join(JoinConfiguration.newlines(), startComponents));\n    ```\n\n    **Explanation:**\n\n    * `Component.join(JoinConfiguration.newlines(), startComponents)`: This joins the components with new lines between them to format the message nicely.\n    * `Bukkit.broadcast()`: This sends the constructed message to all online players.\n\n    This will ensure that all players are notified about the game’s start with the description and header/footer.\n  </StepItem>\n\n  <StepItem title=\"Unregister the listener\">\n    Finally, after broadcasting the start message and teleporting the players, we need to unregister the listener to prevent it from running again.\n\n    Add the following code at the end of the `register` method:\n\n    ```java\n    this.unregister();\n    ```\n\n    **Explanation:**\n\n    * `this.unregister()`: This ensures the listener is removed after it has executed, which prevents unnecessary processing once the game has started.\n\n    Unregistering the listener ensures that it only runs once, right when the game begins.\n  </StepItem>\n\n  <StepItem title=\"Register the listener in DragonsGame setup\">\n    Now, we need to ensure that the `StartTeleportMessageListener` is registered when the game setup occurs.\n\n    In the `setup` method of the `DragonsGame` class, add the following line:\n\n    ```java\n    this.listeners.add(new StartTeleportMessageListener(this, this.dragonsPlugin));\n    ```\n\n    `this.listeners.add(...)`: This adds the `StartTeleportMessageListener` to the list of listeners, ensuring it will be executed during the `STARTED` state.\n\n    This step ensures that the listener is properly registered and executed when the game enters the `STARTED` state.\n  </StepItem>\n\n  <StepItem title=\"Testing the listener\">\n    Finally, let's test the listener. After completing the previous steps, you can test the game by:\n\n    1. Starting the game to trigger the `STARTED` state.\n    2. Observing that all players are teleported to their spawn points.\n    3. Ensuring that player display names and player list names are updated to yellow.\n    4. Verifying that the game start message is broadcasted to all players.\n\n    **Troubleshooting Tips:**\n\n    * Ensure the spawn points are correctly configured.\n    * Double-check that the listener is properly registered in the `DragonsGame` class setup method.\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners",
    "title": "State Listeners",
    "description": "How we handle different states and trigger different things",
    "content": "State listeners allow you to dynamically handle game events based on the current game state. In dragons, we use them to create, implement, and use state-based listeners.\n\n<Step>\n  <StepItem title=\"Create an Abstract Implementation of StateBasedListener\">\n    We added the `StateBasedListener` interface within our [lifecycle tutorial page](./)\n\n    To reduce repetitive code, create an abstract class that implements `StateBasedListener`. This class handles common functionality, such as registering and unregistering the listener.\n\n    🔗 [AbstractStateBasedListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/AbstractStateBasedListener.java)\n\n    ```java\n    import lombok.RequiredArgsConstructor;\r\n    import org.bukkit.event.HandlerList;\r\n    import org.bukkit.event.Listener;\r\n\r\n    /**\r\n    * Abstract implementation of the StateBasedListener interface.\r\n    */\r\n    @RequiredArgsConstructor\r\n    public abstract class AbstractStateBasedListener implements StateBasedListener {\r\n\r\n        protected final DragonsGame game;\r\n        protected final DragonsPlugin plugin;\r\n        protected final GameState activeState;\r\n\r\n        @Override\r\n        public void register() {\r\n            this.plugin.getServer().getPluginManager().registerEvents(this, this.plugin);\r\n        }\r\n\r\n        @Override\r\n        public void unregister() {\r\n            HandlerList.unregisterAll(this);\r\n        }\r\n\r\n        @Override\r\n        public GameState getActiveState() {\r\n            return this.activeState;\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Implement a State-Based Listener\">\n    Once you have the abstract class, you can create specific listeners for different game states. Below is an example of a listener that handles player joins during the `PRE_START` state.\n\n    **We'll expand on this further when we come to adding listeners!**\n\n    ```java\n    public class PlayerJoinPregameListener extends AbstractStateBasedListener {\r\n        public PlayerJoinPregameListener(final DragonsPlugin plugin, final DragonsGame game) {\r\n            super(game, plugin, BuiltInGameState.PRE_START);\r\n        }\r\n\r\n        @EventHandler\r\n        public static void handleJoin(final PlayerJoinEvent playerJoinEvent) {\r\n            playerJoinEvent.joinMessage(Component.text(\"A player joined!\"));\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Register that we're using our new listener\">\n    Within our `DragonsGame` class, we'll need to tell the plugin we've added this new listener.\n\n    We need to do this every time we add one of these, so don't forget, as this will trip you up!\n\n    ```java\n    @Override\r\n    public void setup() {\r\n\r\n        // rest of our code...\r\n\r\n        // here!\r\n        this.listeners.add(new PlayerJoinPregameListener(this, this.dragonsPlugin));\r\n\r\n        // the rest of our code (added before!)\r\n        this.dragonsPlugin.getServer().getPluginManager().registerEvents(this, this.dragonsPlugin);\r\n        this.setGameState(BuiltInGameState.PRE_START);\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/pregame/countdown",
    "title": "Game Start Countdown",
    "description": "Implementing a countdown timer to start the game and transitioning game states when complete.",
    "content": "This tutorial walks you through how to add a countdown timer to start the Dragons game. We’ll ensure proper player notifications and game state management as the countdown progresses.\n\n### Steps to Implement the Countdown\n\n<Step>\n  <StepItem title=\"Adding min and max players\">\n    We’ll first enhance the `DragonsGame` class to include limits for the minimum and maximum number of players.\n\n    Add the following functions to manage player count:\n\n    ```java\n    public static int getMinPlayercount() {\r\n        return 2; // Minimum players required for the game to start\r\n    }\r\n\r\n    public static int getMaxPlayercount() {\r\n        return 16; // Maximum players allowed in the game\r\n    }\n    ```\n\n    These will be useful for verifying whether we have enough players to begin the countdown. They also ensure that only the intended number of players can join.\n  </StepItem>\n\n  <StepItem title=\"Enhance the PlayerJoinPregameListener class\">\n    Next, we’ll modify the `PlayerJoinPregameListener` class to handle the countdown logic. This class, which we created in the [adding listeners tutorial](../../adding-listeners), will be responsible for managing the countdown.\n\n    🔗 [PlayerJoinPregameListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/prestart/PlayerJoinPregameListener.java)\n\n    First, add a field to store the Bukkit task for the countdown:\n\n    ```java\n    private BukkitTask countdownTask;\n    ```\n\n    This task will be used to track and control the countdown timer.\n  </StepItem>\n\n  <StepItem title=\"Implement the countdown timer\">\n    Define a private method `startTimer` to handle the countdown and manage its state. The timer will check if we have enough players to continue, and if so, it will begin counting down from 60 to 0 seconds. When the timer hits 0, it will trigger the next game phase (`STARTED`).\n\n    The method ensures that the countdown only runs if there are enough players. If the player count falls below the minimum, the timer resets.\n\n    ```java\n    private void startTimer() {\r\n        this.countdownTask = new BukkitRunnable() {\r\n\r\n            int timeRemaining = 60; // Initial countdown time in seconds\r\n\r\n            @Override\r\n            public void run() {\r\n                if (Bukkit.getOnlinePlayers().size() < DragonsGame.getMinPlayercount()) {\r\n                    this.timeRemaining = 60; // Reset timer if not enough players\r\n                    return;\r\n                }\r\n\r\n                // Reduce the remaining time by 1 second\r\n                this.timeRemaining--;\r\n\r\n                // If time is up, trigger the game state change and stop the timer\r\n                if (this.timeRemaining <= 0) {\r\n                    PlayerJoinPregameListener.this.game.setGameState(BuiltInGameState.STARTED);\r\n                    this.cancel(); // Stop the timer\r\n                    return;\r\n                }\r\n\r\n                // Announce remaining time every 10 seconds or when less than 5 seconds remain\r\n                if (this.timeRemaining % 10 == 0 || this.timeRemaining <= 5) {\r\n                    announceTime(this.timeRemaining);\r\n                }\r\n            }\r\n        }.runTaskTimer(this.plugin, 20, 20); // Run every second (20 ticks)\r\n    }\n    ```\n\n    This method will be used to track and manage the countdown state. It also ensures proper cleanup when the countdown ends.\n  </StepItem>\n\n  <StepItem title=\"Register and unregister countdown\">\n    We need to ensure the countdown starts and stops at the right time. We’ll use the `register()` and `unregister()` methods to handle starting and canceling the countdown.\n\n    Override these methods in the listener class:\n\n    ```java\n    @Override\r\n    public void register() {\r\n        super.register();\r\n        this.startTimer(); // Start the countdown when the game state changes to Pregame\r\n    }\r\n\r\n    @Override\r\n    public void unregister() {\r\n        super.unregister();\r\n        if (this.countdownTask != null) {\r\n            this.countdownTask.cancel(); // Cancel the countdown when leaving the Pregame state\r\n            this.countdownTask = null;\r\n        }\r\n    }\n    ```\n\n    These methods will be invoked automatically when the game state transitions, ensuring that the countdown starts when it should and is properly cleaned up afterward.\n  </StepItem>\n\n  <StepItem title=\"Add custom join and leave messages\">\n    To enhance the player experience, we’ll show custom messages when players join or leave the game. To keep things organized, we’ll use a `PrefixUtil` class to format these messages consistently.\n\n    Here’s the utility class for the prefix:\n\n    ```java\n    @UtilityClass\r\n    public class PrefixUtil {\r\n\r\n        public static Component getPrefix(final String type) {\r\n            return Component.translatable(\"mineplex.dragons.module.\" + type.toLowerCase() + \".prefix\")\r\n                    .append(Component.text(\">\"))\r\n                    .color(NamedTextColor.BLUE);\r\n        }\r\n    }\n    ```\n\n    Now, create a file named `i18n/Dragons_en.properties` in your resources directory and add the following entries:\n\n    ```properties\n    mineplex.dragons.module.join.prefix=Join\r\n    mineplex.dragons.module.quit.prefix=Quit\r\n    mineplex.dragons.module.game.starting=The game will start in <0> seconds!\n    ```\n\n    This will allow you to customize the messages based on players' locale.\n\n    Now, update the player join and quit event handlers to use these formatted messages:\n\n    ```java\n    quitEvent.quitMessage(Component.join(JoinConfiguration.spaces(), PrefixUtil.getPrefix(\"Quit\"), quitEvent.getPlayer().name().color(NamedTextColor.GRAY)));\r\n\r\n    playerJoinEvent.joinMessage(Component.join(JoinConfiguration.spaces(), PrefixUtil.getPrefix(\"Join\"), playerJoinEvent.getPlayer().name().color(NamedTextColor.GRAY)));\n    ```\n\n    This will display stylish messages when players join or leave the game.\n  </StepItem>\n\n  <StepItem title=\"Announce time remaining\">\n    We also need to broadcast the remaining time to all players. Add a method to handle this broadcast:\n\n    ```java\n    private static void announceTime(final int time) {\r\n        Bukkit.broadcast(Component.join(\r\n                JoinConfiguration.spaces(),\r\n                PrefixUtil.getPrefix(\"Game\"),\r\n                Component.translatable(\r\n                        \"mineplex.dragons.module.game.starting\",\r\n                        Component.text(String.valueOf(time)).color(NamedTextColor.YELLOW))\r\n                .color(NamedTextColor.GRAY)));\r\n    }\n    ```\n\n    This method will notify all players of the time remaining in the countdown, using the custom message format we defined earlier.\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions/adding-listeners/pregame",
    "title": "Pregame Listeners",
    "description": "Setting up listeners for the PREGAME state",
    "content": "As the game transitions into the `PREGAME` state, it's essential to set up a series of Bukkit listeners to manage key aspects of the game logic.\n\n### What are Pregame Listeners?\n\nPregame listeners are event handlers that manage the 'waiting for players' phase of your game. They help ensure a smooth transition into the `STARTED` state and handle important functionality before the action begins.\n\n### Key Listeners to Implement\n\nIn our example project, we focus on these core listeners during the `PREGAME` state:\n\n* **Game Start Countdown**: Handles the countdown timer leading up to the game start.\n* **Player Join & Quit Handling**: Manages players joining or leaving during the pregame phase.\n\n### Extra Polish\n\nOnce the basics are in place, we will enhance the player experience with additional listeners:\n\n* **Scoreboard Listener**: Displays important game information on a dynamic scoreboard.\n* **Bossbar Listener**: Adds a boss bar to show countdowns, messages, or progress indicators.\n\nReady to dive in? Click to the next tutorial to start adding these listeners and bring your pregame phase to life!\n"
  },
  {
    "slug": "/example-project/dragons/state-transitions",
    "title": "State lifecycle",
    "description": "How our state setup works to transition the game to different states",
    "content": "In order for our game to actually work, we define a state lifecycle. This allows us to switch and listen for state changes. Meaning we can trigger our events and mechanics to players.\n\nWe've set dragons up to follow this lifecycle:\r\n![Banner](/images/example-lifecycle.png \"Game Lifecycle\")\n\n### Game Implementation\n\nWe manage these states in our project's Game class, we added this when we first created our `DragonsGame` class. [See here](../../../docs/example-project/dragons/initial-classes#dragonsgame).\n\nWe need some way of keeping track of what events we listen for, and define in what Game state these event listeners actually matter in (we don't want people falling in the void during pre-game to wipe them out, do we?).\n\n<Step>\n  <StepItem title=\"Define a `StateBasedListener` Interface\">\n    To easily re-use state based listeners, we need to make an interface that all of our created listeners will inherit.\n\n    We create an interface that all state-based listeners will implement. This interface ensures that each listener can register, unregister, and identify its associated game state.\n\n    🔗 [StateBasedListener class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/listeners/StateBasedListener.java)\n\n    ```java\n    /**\r\n    * Interface for listeners that are tied to specific game states.\r\n    * This allows dynamic registration and unregistration of listeners\r\n    * based on the active game state in the game lifecycle.\r\n    */\r\n    public interface StateBasedListener extends Listener {\r\n\r\n        /**\r\n        * Registers the listener with the event system.\r\n        * This method is called when the listener becomes active\r\n        * for its associated game state.\r\n        */\r\n        void register();\r\n\r\n        /**\r\n        * Unregisters the listener from the event system.\r\n        * This method is called when the listener is no longer\r\n        * needed for its associated game state.\r\n        */\r\n        void unregister();\r\n\r\n        /**\r\n        * Gets the game state associated with this listener.\r\n        * \r\n        * @return the {@link GameState} that this listener is tied to.\r\n        */\r\n        GameState getActiveState();\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Holding State Listeners in our game\">\n    In addition to what we've done already - we need to define a set of listeners within our game class: this will keep track of each state and it's associated Bukkit listeners.\n\n    Within `DragonsGame.java`, we add a list of listeners: this will hold\n\n    ```java\n    private final Set<StateBasedListener> listeners = new HashSet<>();\n    ```\n  </StepItem>\n\n  <StepItem title=\"A function to assist\">\n    So we can re-use code to grab our listeners for a state, we'll add a function.\n\n    ```java\n    public Set<StateBasedListener> getListenersByState(final GameState gameState) {\r\n        return this.listeners.stream()\r\n                .filter(stateBasedListener -> stateBasedListener.getActiveState().equals(gameState))\r\n                .collect(Collectors.toSet());\r\n    }\n    ```\n\n    This allows us to grab all of our listeners associated with a given state, for example:\n\n    ```java\n    game.getListenersByState(BuiltInGameState.STARTED)\n    ```\n\n    This would give us a list of our listeners for the 'STARTED' (in progress) state.\n  </StepItem>\n\n  <StepItem title=\"Add another function for registering and unregistering\">\n    When we switch states, we want to register all of the target states' listeners: and remove the old states' listeners.\n\n    ```java\n        private void handleStateSwitch(final GameState previousState, final GameState newState) {\r\n        if (previousState != null) {\r\n            this.getListenersByState(previousState).forEach(StateBasedListener::unregister);\r\n        }\r\n        if (newState != null) {\r\n            this.getListenersByState(newState).forEach(StateBasedListener::register);\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Add a listener in our game to handle state changes\">\n    When our game changes state, we now want to call the method we just defined, so that we can trigger our plugin to listen to any state-based events.\n\n    ```java\n    @EventHandler\r\n    public void handleStateChangeEvent(final PostMineplexGameStateChangeEvent stateChangeEvent) {\r\n        this.handleStateSwitch(stateChangeEvent.getFromState(), stateChangeEvent.getToState());\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project/dragons/world-loading",
    "title": "World Loading",
    "description": "How we'll load up worlds in our dragons game",
    "content": "We've already briefly touched on world loading when we loaded up our lobby world. Now we need to add support for loading up our game worlds when the game starts!\n\nYou'll set up the `DragonsWorldHolder` class to handle world selection and integrate it into the main game class.\n\n<Step>\n  <StepItem title=\"Add World Templates\">\n    * Place world templates in the `assets/world-templates` directory.\n    * Follow the guidelines in the [World Module Documentation](../../docs/sdk/features/world).\n    * Ensure templates are properly named and stored for seamless loading.\n\n    Here's the `dataPoints.json` schema we'll use in this tutorial:\n\n    ```json\n    {\r\n        \"BORDER\": [\r\n            {\r\n                \"x\": -79,\r\n                \"y\": 103,\r\n                \"z\": -54,\r\n                \"yaw\": 0.0,\r\n                \"pitch\": 0.0\r\n            },\r\n            {\r\n                \"x\": 27,\r\n                \"y\": 35,\r\n                \"z\": 65,\r\n                \"yaw\": 0.0,\r\n                \"pitch\": 0.0\r\n            }\r\n        ],\r\n        \"SPAWNPOINTS\": [\r\n            {\r\n                \"x\": -20,\r\n                \"y\": 71,\r\n                \"z\": 0,\r\n                \"yaw\": 0.0,\r\n                \"pitch\": 0.0\r\n            },\r\n            {\r\n                \"x\": -12.5,\r\n                \"y\": 72,\r\n                \"z\": 1.2,\r\n                \"yaw\": 0.0,\r\n                \"pitch\": 0.0\r\n            },\r\n            ...(16 required)\r\n        ]\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Create the `DragonsWorldHolder` Class\">\n    The `DragonsWorldHolder` class manages the game world selection and setup. It encapsulates the world selection logic, keeping the `DragonsGame` class focused on game-specific functionality.\n\n    Below is the complete implementation:\n\n    ```java\n    @RequiredArgsConstructor\r\n    public class DragonsWorldHolder {\r\n\r\n        private final DragonsGame dragonsGame;\r\n        private GameWorldSelectorMechanic gameWorldSelectorMechanic;\r\n\r\n        public void setup() {\r\n            this.gameWorldSelectorMechanic = this.dragonsGame.getGameMechanicFactory()\r\n                                                             .construct(GameWorldSelectorMechanic.class);\r\n            // Blacklist the lobby from being selected as a game world.\r\n            this.gameWorldSelectorMechanic.setFilter(name -> !\"lobby\".equalsIgnoreCase(name));\r\n            // Determine the next map for ::getGameWorld\r\n            this.gameWorldSelectorMechanic.setup(this.dragonsGame);\r\n        }\r\n\r\n        public MineplexWorld getWorld() {\r\n            return this.gameWorldSelectorMechanic.getSelectedGameWorld();\r\n        }\r\n\r\n        public void teardown() {\r\n            this.gameWorldSelectorMechanic.teardown();\r\n        }\r\n\r\n    }\n    ```\n\n    🔗 [DragonsWorldHolder class source code](https://github.com/BillyDotWS/studioexample-dragons/blob/master/src/main/java/com/mineplex/studio/dragons/game/world/DragonsWorldHolder.java)\n  </StepItem>\n\n  <StepItem title=\"Update the Game Class\">\n    To integrate the `DragonsWorldHolder`, make the following updates to the `DragonsGame` class:\n\n    #### a. Add a Field for the World Holder\n\n    * Declare a new field for `DragonsWorldHolder`:\n\n    ```java\n    private DragonsWorldHolder worldHolder;\n    ```\n\n    #### b. Update the Base Class\n\n    * Change the `DragonsGame` class to extend `SingleWorldMineplexGame` instead of `MineplexGame`:\n\n    ```java\n    public class DragonsGame implements SingleWorldMineplexGame {\r\n        // Class implementation\r\n    }\n    ```\n\n    #### c. Override the `getGameWorld` Method\n\n    * Provide the selected game world:\n\n    ```java\n    @Override\r\n    public MineplexWorld getGameWorld() {\r\n        return this.worldHolder.getWorld();\r\n    }\n    ```\n\n    #### d. Modify the `setup()` Method\n\n    * Initialize and configure the `DragonsWorldHolder` in the `setup()` method:\n\n    ```java\n    @Override\r\n    public void setup() {\r\n        // Initialize the world holder\r\n        this.worldHolder = new DragonsWorldHolder(this);\r\n        this.worldHolder.setup();\r\n\r\n        // Other setup logic\r\n        super.setup();\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/example-project",
    "title": "Untitled",
    "description": "",
    "content": ""
  },
  {
    "slug": "/example-project/survival-games",
    "title": "Survival Games",
    "description": "Archived Example Project for Survival Games",
    "content": "<Note type=\"danger\" title=\"This is an archived page!\">\n  This example project is Archived. It should be used for reference only. We decided it wasn't clear and simple to understand, and lacked a lot of the description and explanation required to support our current documentation standards.\n\n  It is also heavily out of date, with the latest update being in Mid 2023.\n</Note>\n\n[Survival Games Example Repository - Archived](https://github.com/Mineplex-LLC/StudioExample-SurvivalGames)\n"
  },
  {
    "slug": "/getting-started/example-project",
    "title": "Example Project",
    "description": "An example project to demonstrate how to implement features using Mineplex Studio.",
    "content": "To help you get started with Mineplex Studio, we have provided an example project. This project showcases how to implement our features and can serve as a reference for your own projects.\n\n## Project Overview\n\n* **Project Name**: Survival Games\n* **Description**: A basic working example of a survival games game mode.\n* **Repository**: [Mineplex Studio Example Project](https://github.com/Mineplex-LLC/StudioExample-SurvivalGames)\n\n## Key Features\n\n* **Game Mechanics**: Essential game mechanics are already implemented for you.\n* **Configuration**: The configuration is set up to demonstrate how to use our features effectively.\n\n## Need Help?\n\nIf you have any further questions or need assistance, please reach out in our Studio Partner Discord\n\nThis example project is designed to provide you with a practical starting point and to illustrate best practices for working with Mineplex Studio.\n"
  },
  {
    "slug": "/getting-started",
    "title": "Quick Start Guide",
    "description": "How to get started with the Mineplex Studio.",
    "content": "## Ready to get started with the Mineplex Studio?\n\nThese are the basic steps to get started!\n\n<Step>\n  <StepItem title=\"Prerequisites\">\n    Before you can get started with the Mineplex Studio, you'll need to install the [Studio CLI](/docs/cli/installation) and [GitHub CLI](https://cli.github.com/). You'll also need a GitHub account.\r\n    Next, head to the [Mineplex Studio](https://studio.mineplex.com) and create a Studio developer account. You can also create and manage organizations from this site to share access across organizations. As part of the account creation process, you'll need to verify your email address and subscribe to one of our plans (this helps cover the cost of running development containers and hosting the rest of your infrastructure for free!).\n  </StepItem>\n\n  <StepItem title=\"Creating a Project\">\n    Once you've installed the Studio CLI and created a Studio Partner account, you're ready to create your first project. To do so, use the `studio login` and `studio create-project` commands. For details, see the [CLI documentation](/docs/cli/commands).\n  </StepItem>\n\n  <StepItem title=\"Editing Your Project\">\n    When you open the project that the Studio CLI created, you'll see a few files and folders. The most important of these is the `src` folder, which contains the source code for your project. You can edit this code to customize your project. For example, you can add new abilities to your game, or change the behavior of existing abilities. While you have full access to the Spigot APIs from your project, we also provide a set of abstractions that make it easier to build games. For more information, see the [Game API documentation](/docs/sdk-game).\r\n    The CLI also adds a few `.yaml` files automatically that hold your game configuration. You can define things player count constraints, matchmaking rules, product offerings for players, and more in these files. For more information, see the [configuration documentation](/docs/configuration).\n  </StepItem>\n\n  <StepItem title=\"Testing Your Project\">\n    Once you've made some changes to your project, you can test them in the Studio staging environment with the CLI hotswap command. This will build your project continuously based on file system changes and allow you to connect to a remote container IP and test your game. For more information, see the [CLI documentation](/docs/cli/commands).\n  </StepItem>\n\n  <StepItem title=\"Deploying Your Project\">\n    Once you're happy with your changes, you can deploy them to Mineplex. By default, the Studio CLI creates a deployment action that runs via GitHub Actions\r\n    in your repository whenever you push to the `main` branch. This action will build your project and deploy it to Mineplex. Additional features (such as publishing channels, change management, and more) are coming soon!\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/getting-started/namespaces",
    "title": "Project Namespaces",
    "description": "How to use the Project Namespaces on the Mineplex Studio.",
    "content": "Projects on the Mineplex Studio can optionally be grouped together inside Namespaces. Grouping Projects together within a Namespace allows you to share resources such as purchases, player stats, player data, and more.\n\nBy default, a Project is created inside its own independent Namespace. You can view and update a Project's Namespace from the `config/game-properties.yaml` file. You should exercise caution when changing a Namespace, since updates can be destructive and may cause your Project to lose access to existing resources inside its previous Namespace.\n\nCurrently, the following resources are shared by all Projects inside a Namespace:\n\n* [Namespace Bans](/docs/sdk/features/moderation)\n* [Data Collections](/docs/sdk/features/data)\n* [Purchaseable Products and Subscriptions](/docs/sdk/features/purchase)\n* [Player Stats](/docs/sdk/features/stats)\n* [Leaderboards](/docs/sdk/features/leaderboard)\n* [Persistent World Buckets](/docs/sdk/features/world)\n"
  },
  {
    "slug": "/introduction",
    "title": "Introduction",
    "description": "This section provides an overview of how to get started with the Mineplex Studio.",
    "content": "![Banner](/images/banner.png \"Mineplex Studio\")\n\n## Mineplex Studio Overview\n\nWelcome to **The Mineplex Studio**, The Studio empowered developers worldwide to create their own minigames and game networks within Minecraft, with cross-platform support, monetization, and infrastructure hosting built-in. The Studio platform massively lowered the barrier to entry for game development in Minecraft and is now publicly available.\n\nInspired by innovations in the gaming space from titles like Roblox and Fortnite, we\r\ninvented the Studio to empower our players to develop games surpassing those they previously\r\nplayed on Mineplex servers and in other titles.\r\nAfter the 2023 shutdown and restructure of the company, we received many requests to\r\nrelaunch both the Java and Bedrock servers, alongside an overwhelming interest in game\r\ndeveloper positions. While considering the skills and interests of the community, along with\r\nMineplex’s long-term goals of inspiring and empowering creators, we decided to create the\r\nStudio to revolutionize the gaming infrastructure space.\n\n<CardGrid>\n  <Card subtitle=\"Getting Started\" title=\"Command Line Interface\" description=\"Get started with our CLI (command line interface). The portal to interact with your Studio Project.\" href=\"/docs/cli\" />\n\n  <Card subtitle=\"Getting Started\" title=\"Project Configuration\" description=\"Some basics around configuring your game, to allow us to understand how your game is to run.\" href=\"/docs/configuration\" />\n\n  <Card subtitle=\"Getting Started\" title=\"Studio Development Kit\" description=\"Our Java studio development kit enables you to interact with our infrastructure within your code, at runtime.\" href=\"/docs/sdk\" />\n</CardGrid>\n\n## Why Mineplex Studio?\n\nThe Mineplex Studio is a groundbreaking platform that redefines the way developers create games within Minecraft. By providing a comprehensive ecosystem of tools and services, it eliminates traditional barriers to entry and empowers creators of all skill levels to bring their visions to life. With cross-platform support, built-in monetization options, and reliable infrastructure hosting, The Studio streamlines the game development process, allowing developers to focus on creativity while we handle the technical complexities. Whether you’re an experienced developer or just starting out, The Studio offers everything you need to design, publish, and sustain your games.\n\nInspired by platforms like Roblox and Fortnite, The Mineplex Studio was built to encourage innovation and surpass expectations. It enables developers to create games that rival or exceed those previously seen on Mineplex servers or other popular titles. More than a development tool, it’s a platform designed to foster creativity and collaboration, making it ideal for building new experiences that captivate players. By prioritizing community feedback and aligning with Mineplex’s mission to inspire creators, The Studio combines cutting-edge technology with the vision of a thriving developer community.\n\n## Key Features\n\nHere are some of the features that make us ideal for building your game:\n\n| Feature                              | Description                                                                                                      |\r\n|--------------------------------------|------------------------------------------------------------------------------------------------------------------|\r\n| **Matchmaking** | Provides advanced matchmaking algorithms to ensure players are grouped together based on skill level, preferences, and game type, creating balanced and enjoyable gameplay experiences. |\r\n| **Infrastructure** | Delivers scalable, high-performance hosting solutions to ensure your games run smoothly with minimal downtime, regardless of player traffic or complexity. |\r\n| **Databases** | Offers robust and secure database integration for storing player data, game progress, and other critical information, enabling developers to focus on creating experiences rather than managing data. |\r\n| **Moderation** | Includes built-in moderation tools for managing player behavior, enforcing community guidelines, and ensuring a safe and enjoyable environment for all users. |\r\n| **Model Engine** | Provides a powerful engine for creating and implementing custom 3D models, animations, and assets directly within Minecraft, giving developers unlimited creative potential. |\r\n| **Cross Play Support** | Ensures seamless compatibility across multiple platforms, allowing players to join and enjoy your games regardless of their device, be it PC, console, or mobile. |\n\n## Join our Community\n\nIf you have questions about anything related to the Mineplex Studio, you're always welcome to ask our community on [Discord](https://discord.gg/khutqUK6Ts).\n"
  },
  {
    "slug": "/sdk/custom",
    "title": "Custom Modules",
    "description": "How to create custom Mineplex Studio Modules.",
    "content": "Creating your own custom `MineplexModule`s is almost effortless! Simply create a class that implements the `MineplexModule` interface, then register it as a `MineplexModule` when your project starts up using the `registerModule(T)` method in the `MineplexModuleManager`. Once your `MineplexModule` is registered, it is able to function as a `Listener`, and/or perform any custom behavior you decide to implement, either independently or in concert with other `MineplexModule`s.\n\n## MineplexModule Interface\n\n### `setup()` and `teardown()` Methods\n\nThese methods are responsible for creating and configuring any additional resources needed by your custom `MineplexModule`, and for destroying and cleaning up these resources, respectively. **NOTE: You do NOT need to register/unregister your `MineplexModule` as a `Listener` in these methods!**\n\n## Example\n\n## Creating a `MineplexModule`\n\nLet's build a very basic custom module that registers an additional `Listener` with itself.\n\n```java\n@MineplexModuleImplementation(MyCustomModule.class)\r\npublic class MyCustomModule implements MineplexModule {\r\n    private final JavaPlugin myProjectPlugin;\r\n    private MySignListener mySignListener;\r\n\r\n    public MyCustomModule(final JavaPlugin myProjectPlugin) {\r\n        this.myProjectPlugin = myProjectPlugin;\r\n    }\r\n\r\n    @Override\r\n    public void setup() {\r\n        mySignListener = new MySignListener();\r\n        Bukkit.getPluginManager().registerEvents(mySignListener, myProjectPlugin);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        HandlerList.unregisterAll(mySignListener);\r\n        mySignListener = null;\r\n    }\r\n}\n```\n\n## Registering your `MineplexModule`\n\nNow that we've created our module, we need to register it from our project class.\n\n```java\npublic class MyProject extends JavaPlugin {\r\n    @Override\r\n    public void onEnable() {\r\n        MineplexModuleManager.getInstance().registerModule(new MyCustomModule(this));\r\n    }\r\n\r\n    @Override\r\n    public void onDisable() {\r\n        MineplexModuleManager.getInstance().destroyModule(MyCustomModule.class);\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/chat",
    "title": "Chat Module",
    "description": "How to use the Mineplex Studio Chat Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.chat.ChatModule\" />\n\nThe Chat Module is one of the built-in Studio Modules that controls player chat. Through the Chat Module, player chat can be enabled or disabled in each channel, chat rendering formats can be set, and chat audiences can be controlled. The Chat Module additionally allows you to use our chat filter for aspects of your game that take in user input.\n\n## Chat Channels\n\nChat Channels allow for the division of player chat into specific sections, each with their own configurable audience and rendering format. You can access some of our built in chat channels using the BuiltInChatChannel enum, or create your own by adding new classes or enums that implement the ChatChannel interface. Each chat channel must have an internal identifier that can be used by our chat reporting system.\n\n### Chat Channel Audience\n\nChat Channels can be configured with different Audiences based on the player sending a message using the Chat Module's `setAudienceFunction(ChatChannel, Function<Player, Set<Audience>>)` method. This function is evaluated each time a message is sent by a player in the channel and used to generate the set of Audiences of the message. The `Audience` class is provided by the third party [Adventure API](https://docs.advntr.dev/index.html). More details can be found on their wiki as to how this works.\n\n### Chat Channel Rendering Format\n\nChat Channel formatting is configurable in the Chat Module using the `setChatRenderer(ChatChannel, ChatRenderer)` method. The `ChatRenderer` class is provided by the third party [Adventure API](https://docs.advntr.dev/index.html). More details can be found on their wiki as to how this works.\n\n### Player Chat Channels\n\nThere are two primary ways for you to manage player interaction via chat channels. Your first option is to use the `setChatChannel(Player, ChatChannel)` method, which sets the active chat channel that a player is currently chatting in. With this set, all the messages a player subsequently sends will be directed to that channel. Alternatively, you can use the `sendToChatChannel(ChatChannel, Player, Component)` method, which will manually send a message from a given player to the target chat channel, just as if the player had sent it themselves.\n\n### Chat Channel Silence\n\nThrough the Chat Module methods `isChatSilenced(ChatChannel)` and `setChatSilence(ChatChannel, boolean)`, you can check if chat is enabled in a given chat channel, as well as enable or disable chatting in a given chat channel.\n\n## Chat Filter\n\nAll Studio projects are required to run any user-provided text that will be displayed to other players through our chat filter. The Chat Module provides the method `isFiltered(String)`, which returns true if the String text is determined to be blocked by our chat filter. There is also a method `isFilteredAsync(String)` which can be used to query the chat filter asynchronously. When filtering text from the main thread, the asynchronous approach should always be used.\n\n## Examples\n\n## Chat Filtering\n\nLet's imagine that players are allowed to freely build in our game. In Minecraft, players are able to write text on signs that they place in the world. If players can place down signs, we have to make sure to run the sign text through the chat filter. This can be done in an event `Listener`.\n\n```java\n@EventHandler\r\npublic void onSignEdit(final SignChangeEvent event) {\r\n    // Since a sign is essentially one message, we want to filter all its lines together.\r\n    final StringBuilder messageBuilder = new StringBuilder();\r\n    for (final Component line : event.lines()) {\r\n        // Since Signs can have component lines, we have to serialize each line into plain text to filter it.\r\n        messageBuilder.append(' ').append(PlainTextComponentSerializer.plainText().serialize(line));\r\n    }\r\n    // Since the SignChangeEvent is fired on the main thread, we have to check the filter asynchronously.\r\n    chatModule.isFilteredAsync(messageBuilder.toString())\r\n            .thenAccept(filtered -> {\r\n                // If the line wasn't filtered, we don't need to do anything\r\n                if (filtered) {\r\n                    Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n                        // Update the sign to clear its lines\r\n                        if (event.getBlock().getState() instanceof final Sign sign) {\r\n                            SignSide side = sign.getSide(event.getSide());\r\n                            final Component cleared = Component.text(\"\");\r\n                            // Minecraft signs have only 4 lines\r\n                            for (int i = 0; i < 4; i++) {\r\n                                side.line(i, cleared);\r\n                            }\r\n                            // We want to update the sign without triggering a game physics update\r\n                            sign.update(false, false);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n}\n```\n\n## Chat Channels\n\n### Custom Channel\n\nFor the next few examples, let's imagine we're creating a Factions game and we need a chat channel for allied Factions to talk to one another in private.\n\n```java\npublic class AllyChatChannel implements ChatChannel {\r\n    @Override\r\n    public String getInternalIdentifier() {\r\n        return \"mygame.allychat\";\r\n    }\r\n}\n```\n\n### Audience\n\nSince we only want allies of the sender's Faction to see messages in Ally chat, we have to configure a custom audience for the channel.\n\n```java\npublic void setupChannelAudiences() {\r\n    chatModule.setAudienceFunction(allyChatChannel, sender -> {\r\n        // Determine what Faction the sender is in\r\n        final Optional<Faction> senderFaction = getFaction(sender);\r\n        // If the sender has no Faction, there are no allies to see their chat\r\n        if (senderFaction.isEmpty()) {\r\n            return Set.of(Audience.audience(sender));\r\n        }\r\n        final Set<Audience> audiences = new HashSet<>();\r\n        // All the members of the sender's own Faction should be considered allies\r\n        audiences.add(Audience.audience(senderFaction.get().getMembers()));\r\n        // Create an audience for each allied Faction\r\n        for (final Faction allyFaction : senderFaction.get().getAllies()) {\r\n            audiences.add(Audience.audience(allyFaction.getMembers()));\r\n        }\r\n        return audiences;\r\n    });\r\n}\n```\n\n### Rendering\n\nWe also want to give our custom chat channel a distinct format and style so the allies know who is chatting.\n\n```java\nprivate static final String CHAT_FORMAT = \"<dark_green>[<faction>]</dark_green><display_name><green>: </green><message>\";\r\n\r\npublic void setupChannelRenderers() {\r\n    chatModule.setChatRenderer(allyChatChannel, (source, sourceDisplayName, message, viewer) -> {\r\n        final String factionName = getFaction(source).map(Faction::getName).orElse(\"\");\r\n        // Renders chat in the format [Faction Name] Player Name: Message\r\n        return MiniMessage.miniMessage()\r\n                .deserialize(\r\n                        CHAT_FORMAT,\r\n                        Placeholder.parsed(\"faction\", factionName),\r\n                        Placeholder.component(\"display_name\", sourceDisplayName),\r\n                        Placeholder.component(\"message\", message));\r\n    });\r\n}\n```\n\n### Player Channels\n\nFinally, we need a way for players to use the ally chat. Let's imagine we've created a `/allychat` command that can either include a message, or switch your chat to ally chat.\n\n```java\n@Override\r\npublic boolean onCommand(@NotNull final CommandSender sender, @NotNull final Command command,\r\n                         @NotNull final String label, @NotNull final String[] args) {\r\n    if (sender instanceof final Player player) {\r\n        // If there are no command args, just set the active player chat channel to ally chat\r\n        if (args.length == 0) {\r\n            chatModule.setChatChannel(player, allyChatChannel);\r\n        } else {\r\n            // Concatenate all command args into one message\r\n            final StringBuilder messageBuilder = new StringBuilder(args[0]);\r\n            for (int i = 1; i < args.length; i++) {\r\n                messageBuilder.append(args[i]);\r\n            }\r\n            // Send the full message in ally chat without updating the player's active channel\r\n            chatModule.sendToChatChannel(allyChatChannel, player, Component.text(messageBuilder.toString()));\r\n        }\r\n    }\r\n    return true;\r\n}\n```\n\n### Silencing\n\nLet's imagine we are building a Hide and Seek game, and we don't want Hiders revealing each other's position to the Seekers. When a round starts, we can silence the global chat, so that Hiders and Seekers can't talk to one another.\n\n```java\nprotected void startRound() {\r\n    chatModule.setChatSilence(BuiltInChatChannel.GLOBAL, true);\r\n}\n```\n\nThen, when the round ends, we want to allow the two teams to communicate with each other again, so we unsilence the global chat.\n\n```java\nprotected void endRound() {\r\n    chatModule.setChatSilence(BuiltInChatChannel.GLOBAL, false);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/command",
    "title": "Command Module",
    "description": "How to use the Mineplex Studio Command Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.command.CommandModule\" />\n\nThe Command Module is one of the built-in Studio Modules that allows you to dynamically register and\r\nunregister commands from the Bukkit CommandMap.\n\n## Examples\n\n## Registering Command\n\nLet's say we want to register our new command!\n\n```java\npublic void register() {\r\n   Command command = new MyCommand();\r\n   commandModule.register(\"fallbackPrefix\", command);\r\n}\n```\n\n## Unregistering Command\n\nLets unregister our command!\n\n```java\npublic void cleanup(final Player player) {\r\n   // Pass the command instance we have created earlier.\r\n   commandModule.unregister(command);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/data",
    "title": "Data Storage Module",
    "description": "How to use the Mineplex Studio Data Storage Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.data.DataStorageModule\" />\n\nThe Data Storage Module is one of the built-in Studio Modules that allows you to dynamically store and load structured objects and binary data objects in your project. The built-in Data Storage Module is a simple way to get started with key-value storage, has no additional cost, and scales globally with the rest of the Studio platform. For advanced use cases, it is also possible to allocate dedicated databases at an additional cost via the Managed Databases system.\n\n## Data Objects\n\nEach data object, whether structured or binary, consists of two components: the key of the data, which is a `String` field in the class annotated withthe `@DataKey` annotation and should be **unique** within the `DataCollection` represented by the class, and the body of the data. The data body isdynamic, allowing you to create objects that are as simple or as complicated as you need. Any data object class needs to implement either the`StorableBinaryData` interface or the `StorableStructuredData` interface, and must be annotated with the `@DataCollection` annotation. This classannotation should include a `name` argument containing the **unique** name of the data collection within your project namespace for all objects of thattype to be stored within.\n\n## Structured Data\n\nStructured data objects should be comprised of individual fields and represent fixed-format data, such as player faction membership data or objectives completed. As previously mentioned, one `String` field of the class should be a unique key for that specific object, and must be annotated with the `@DataKey` annotation.\n\n## Binary Data\n\nBinary data objects are representations of more complex and non-standardized data, such as player worlds or world slices, or block changes on top of a template. There should be one specific `String` field serving as a unique key annotated with the `@DataKey` annotation. The remainder of the class is up to you, but the interface requires that the class can be serialized to/from a ByteArrayInputStream via overriding the `open()` and `load(ByteArrayInputStream)` methods, respectively.\n\n## CRUD\n\nThe CRUD methods provided in the Data Storage Module are as follows:\n\n* `store` - Store a data object in the remote storage system\n* `load` - Load a stored data object by key from the remote storage system\n* `exists` - Check whether a given key is associated with a data object in the remote storage system\n* `delete` - Deletes the data object associated with a given key in the remote storage system\n\nEach CRUD method has both a structured data and binary data version. Additionally, each of the CRUD methods has an asynchronous version, which should always be used when calling from the main thread. With the exception of the `store` method, all CRUD methods take the data class and the object key as parameters. The `store` method takes the data object itself as a parameter.\n\n## Examples\n\n## Creating a Structured Data Object\n\nLet's say we want to create a record object to reflect player access to a specific \"Island\" in our game.\n\n```java\n@Data\r\n@Builder\r\n@DataCollection(name = \"PlayerIslandAccess\")\r\npublic class PlayerIslandAccess implements StorableStructuredData {\r\n    // Player id should never be null\r\n    // This data is keyed by the player's id\r\n    @DataKey\r\n    @NonNull\r\n    String playerId;\r\n    // Island id should never be null\r\n    @NonNull\r\n    String islandId;\r\n}\n```\n\n## Creating a Binary Data Object\n\nNow, let's say we want to create a binary object that represents the chunk the \"Island\" is contained within, so that we can spawn it into our world.\n\n```java\n@Data\r\n@Builder\r\n@DataCollection(name = \"IslandChunk\")\r\npublic class IslandChunk implements StorableBinaryData {\r\n    // Island id should never be null\r\n    // This data is keyed by the island's id\r\n    @DataKey\r\n    @NonNull\r\n    String islandId;\r\n    // The island chunk should never be null\r\n    @NonNull\r\n    Chunk chunk;\r\n    private byte[] serializeChunkToBytes(final Chunk chunk) {\r\n        // Implement chunk serialization here\r\n    }\r\n    private Chunk createChunkFromBytes(final byte[] bytes) {\r\n        // Implement chunk deserialization here\r\n    }\r\n    @Override\r\n    public ByteArrayInputStream open() {\r\n        return new ByteArrayInputStream(serializeChunkToBytes(chunk));\r\n    }\r\n    @Override\r\n    public void load(final ByteArrayInputStream binary) {\r\n        chunk = createChunkFromBytes(binary.readAllBytes());\r\n    }\r\n}\n```\n\n## Using our Structured and Binary Data Objects\n\nNow that we have our structured and binary data objects, we can implement per-chunk persistence in our game.\n\n```java\npublic CompletableFuture<IslandChunk> loadIslandChunk(final Player player) {\r\n    final CompletableFuture<IslandChunk> islandChunkCompletableFuture = new CompletableFuture<>();\r\n    dataStorageModule.structuredDataExistsAsync(PlayerIslandAccess.class, player.getUniqueId().toString())\r\n            .thenAccept(exists -> {\r\n                if (exists) {\r\n                    // We know the object exists\r\n                    final PlayerIslandAccess islandAccess = dataStorageModule.loadStructuredData(\r\n                        PlayerIslandAccess.class, player.getUniqueId().toString())\r\n                            .orElseThrow();\r\n                    // If somehow the island is not there, remake it\r\n                    if (!dataStorageModule.binaryDataExists(\r\n                        IslandChunk.class, islandAccess.getIslandId())) {\r\n                        // Run chunk generation on the main thread\r\n                        Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n                            // Create a new island\r\n                            final IslandChunk islandChunk = generateNewIslandChunk();\r\n                            // Create access to the new island\r\n                            islandAccess.setIslandId(islandChunk.getIslandId());\r\n                            // Store the new island\r\n                            dataStorageModule.storeBinaryDataAsync(islandChunk).thenAccept(v -> {\r\n                                // Store the access to the created island\r\n                                dataStorageModule.storeStructuredData(islandAccess);\r\n                                // Return the new island\r\n                                islandChunkCompletableFuture.complete(islandChunk);\r\n                            });\r\n                        });\r\n                    } else {\r\n                        // We know the object exists\r\n                        final IslandChunk islandChunk = dataStorageModule.loadBinaryData(\r\n                            IslandChunk.class, islandAccess.getIslandId())\r\n                                .orElseThrow();\r\n                        islandChunkCompletableFuture.complete(islandChunk);\r\n                    }\r\n                } else {\r\n                    // Run chunk generation on the main thread\r\n                    Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n                        // Create a new island\r\n                        final IslandChunk islandChunk = generateNewIslandChunk();\r\n                        // Create access to the new island\r\n                        final PlayerIslandAccess islandAccess = PlayerIslandAccess.builder()\r\n                                .playerId(player.getUniqueId().toString())\r\n                                .islandId(islandChunk.getIslandId())\r\n                                .build();\r\n                        // Store the new island\r\n                        dataStorageModule.storeBinaryDataAsync(islandChunk).thenAccept(v -> {\r\n                            // Store the access to the created island\r\n                            dataStorageModule.storeStructuredData(islandAccess);\r\n                            // Return the new island\r\n                            islandChunkCompletableFuture.complete(islandChunk);\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n    return islandChunkCompletableFuture;\r\n}\r\npublic void deletePlayerIsland(final Player player) {\r\n    dataStorageModule.structuredDataExistsAsync(PlayerIslandAccess.class, player.getUniqueId().toString())\r\n            .thenAccept(exists -> {\r\n                if (exists) {\r\n                    // We know the object exists\r\n                    final PlayerIslandAccess islandAccess = dataStorageModule.loadStructuredData(\r\n                        PlayerIslandAccess.class, player.getUniqueId().toString())\r\n                            .orElseThrow();\r\n                    dataStorageModule.deleteBinaryData(IslandChunk.class, islandAccess.getIslandId());\r\n                    dataStorageModule.deleteStructuredData(PlayerIslandAccess.class,\r\n                        player.getUniqueId().toString());\r\n                }\r\n            });\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game",
    "title": "Game Engine Module",
    "description": "How to use the Mineplex Studio Game Engine Module.",
    "content": "The Game Engine Module is one of the built-in Studio Modules that allows you to create immersive and dynamic gameplay\r\nexperiences within Minecraft. Studio games are designed to be modular, allowing you to make amazing gameplay mechanics\r\nthat you can take with you from game to game, or even sell to other developers on our asset marketplace.\n\n## Game Cycle\n\nIf you want to create a project where multiple games play one after another, you should create your own\r\ncustom `GameCycle`. To do so, you need to create a class that implements the `GameCycle` interface. You'll need to\r\ndetermine how the `hasNextGame()` and `createNextGame()` methods should function. In some cases, you may want to cycle\r\nthrough a specific number of games, while in others you may want the cycle to go on forever. Either way, you can control\r\nit via your implementation of `hasNextGame()`. Your implementation of `createNextGame()` will determine what game is up\r\nnext, and will need to handle constructing the next game up. You can also have `getLobbyWorld()` return an\r\nactual `MineplexWorld` if you want the players to be teleported to a lobby world in between games. By default, there is\r\nno `GameCycle`, and a new game will not be created when the previous game ends.\n\n## Game State\n\nThe state of a `MineplexGame` indicates what phase in the game lifecycle it is currently in. The `GameState` of\r\na `MineplexGame` can be retrieved using the `getGameState()` method, and set using the `setGameState(GameState)` method.\n\nBuilt in options are:\n\n* `PREPARING` - When the `MineplexGame` is first being setup after construction\n* `PRE_START` - When the `MineplexGame` is preparing to start after all start conditions are met. This can be used for\r\n  things like countdowns or other starting behaviors. This is the default state in which the Matchmaker will flag your\r\n  game server as available for players\n* `STARTED` - When the `MineplexGame` has officially started\n* `ENDED` - When the `MineplexGame` is completed after the end condition is met. This can be used for things like win\r\n  rooms or other end game behavior\n\n## MineplexGame Interface\n\nThe `MineplexGame` interface is the primary interface for any game playable on the Studio. To make your own game, you'll\r\nneed to create a class for it that implements the `MineplexGame` interface. This class will define the core\r\nfunctionality and gameplay, and is where you will pull in all the `GameMechanic`s that you want to incorporate. To\r\nproperly implement the `MineplexGame` interface, you will need to provide implementations for several methods. You will\r\nneed to implement the `getName()` method, which should be the `String` name for your game. You also need to implement\r\nthe `getGameModule()` method. You'll need to supply some way for your game to return the `MineplexGameModule` within\r\nthis method, either by passing the module in the game's constructor, or another way of your choosing. Next, you'll need\r\nto implement the `getGameState()` and `setGameState(GameState)` methods. These can either actually modify your game's\r\nstate, or simply return `STARTED` for games that do not intend to support a full game lifecycle. Inside\r\nthe `setGameState` method, you should additionally fire the `MineplexGameStateChangeEvent` and propagate that new state\r\nto each of the `GameMechanic`s your game is using via the `GameMechanic` method `onStateChange(GameState, GameState)`\r\nprior to actually changing the `GameState` if you intend to do so. You will need to manage the conditions that trigger\r\ngame lifecycle changes yourself as well. Finally, you must implement the `setup()` and `teardown()` methods, to handle\r\nallocating and deallocating assets for the game. This is where you should create, configure, and destroy any of\r\nthe `GameMechanic`s you want to use.\n\nYou will need to handle registering and unregistering of your `MineplexGame` as a `Listener` yourself as well, based on\r\nyour own conditions.\n\nThere is a sub-interface, `SingleWorldMineplexGame`, that you may also choose to implement rather than just\r\nthe `MineplexGame` interface. This requires all the same implementations as a standard `MineplexGame`, with the\r\nadditional required method implementation of `getGameWorld()`, which should return the `MineplexWorld` serving as the\r\nsingle world that game will take place within.\n\n## Game Mechanics\n\n`GameMechanic`s are discrete elements of gameplay that create a full game when all operating together. These mechanics\r\ncan be tightly coupled to a specific `MineplexGame`, or left generic to support a wide variety of games. We provide\r\nseveral built-in `GameMechanic`s with the Studio SDK, but you can also make your own mechanics to customize your game\r\nprojects. You can even create unique `GameMechanic`s and sell them to other developers on our asset\r\nmarketplace! `GameMechanic`s should register and unregister themselves as `Listener`s in their setup and teardown\r\nmethods, which should be called manually when an owning `MineplexGame` initializes and cleans them up.\n\n### Game Mechanic Factory\n\nA `GameMechanicFactory` provides for the dynamic construction of instances of a specific `GameMechanic`.\r\nTo function, the factory needs to be registered in the `MineplexGameMechanicFactory`\r\nusing the `<M extends GameMechanic<?>> register(Class<M> gameMechanic, Supplier<M> mechanicSupplier)` method.\r\nOnce the factory has been registered, you can use the `MineplexGameMechanicFactory`\r\nto construct instances of the `GameMechanic` using the `construct(Class<M extends GameMechanic<?>>)` method.\r\nAll built-in `GameMechanic`s that we provide have their factories pre-registered in the `MineplexGameMechanicFactory`,\r\nso all you have to do is construct an instance when you want to use them.\r\nYou do not need to create a `GameMechanicFactory` for your own custom `GameMechanic`s, but you can if you'd like to.\r\nYou will need\r\nto implement your own `GameMechanicFactory` if you plan to sell source-unavailable `GameMechanic`s to other developers\r\non our asset marketplace.\n\n### Game World Selector Mechanic\n\nThe `GameWorldSelectorMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic will\r\nrandomly select a map from the game map templates included in your project, load the `MineplexWorld` from the template,\r\nand then provide it to the `MineplexGame` using the mechanic. Once the `MineplexGame` cleans itself up,\r\nthe `GameWorldSelectorMechanic` will unload the `MineplexWorld` and clean it up as well.\n\n### Custom Game Mechanics\n\nImplementing your own custom `GameMechanic`s is easy to do: just create a new class that implements the `GameMechanic`\r\ninterface, and determine if you want a mechanic that is coupled to a game, for example `BossMechanic<BossGame>`, or a\r\nmore generic mechanic, such as `SpectatorMechanic<MineplexGame>`. In your custom class, you will need to implement\r\nthe `setup(Game)`, `teardown()`, and `onStateChange(GameState, GameState)` methods to define the custom behavior of your\r\nmechanic for each of those cases.\n\n## Game Structure\n\nSince this is a game that takes place in one game world, let's base it on the `SingleWorldMineplexGame`.\n\n```java\npublic class HungerGames implements SingleWorldMineplexGame {\r\n    private final JavaPlugin myProjectPlugin;\r\n    private final MineplexGameModule gameModule;\r\n    private GameState gameState;\r\n    @Getter\r\n    private final List<LivingEntity> players = new ArrayList<>();\r\n\r\n    public HungerGames(final JavaPlugin myProjectPlugin, final MineplexGameModule gameModule) {\r\n        this.myProjectPlugin = myProjectPlugin;\r\n        this.gameModule = gameModule;\r\n        this.gameState = GameState.PREPARING;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Hunger Games\";\r\n    }\r\n\r\n    @Override\r\n    public MineplexGameModule getGameModule() {\r\n        return gameModule;\r\n    }\r\n\r\n    @Override\r\n    public GameState getGameState() {\r\n        return gameState;\r\n    }\r\n\r\n    @Override\r\n    public void setGameState(GameState gameState) {\r\n        Bukkit.getPluginManager().callEvent(new MineplexGameStateChangeEvent(this,\r\n                this.gameState, gameState));\r\n        this.gameState = gameState;\r\n\r\n        // When the game starts, teleport every player to a random spawn point\r\n        if (this.gameState == GameState.STARTED) {\r\n            final List<Location> spawns = getGameWorld().getDataPoints(\"SPAWN\");\r\n            players.forEach(player -> {\r\n                final Location spawn = spawns.get(ThreadLocalRandom.current().nextInt(spawns.size()));\r\n                player.teleport(spawn);\r\n            });\r\n        } else if (this.gameState == GameState.ENDED) {\r\n            setGameState(GameState.CLEANING_UP);\r\n        } else if (this.gameState == GameState.CLEANING_UP) {\r\n            teardown();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setup() {\r\n        Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        HandlerList.unregisterAll(this);\r\n        players.clear();\r\n        gameModule.setCurrentGame(null);\r\n    }\r\n\r\n    @Override\r\n    public MineplexWorld getGameWorld() {\r\n        return null;\r\n    }\r\n\r\n    @EventHandler\r\n    public void onDeath(final PlayerDeathEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the dead player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put dead players in spectator mode\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onJoin(final PlayerJoinEvent event) {\r\n        // Automatically add new players to the game\r\n        if (gameState == GameState.PRE_START) {\r\n            players.add(event.getPlayer());\r\n            // If 5 or more players are playing, start the game\r\n            if (players.size() >= 5) {\r\n                setGameState(GameState.STARTED);\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onQuit(final PlayerQuitEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the exiting player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put exiting players in spectator mode\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n```\n\nNext, let's enable and configure the mechanics we want!\n\n## Game Mechanics\n\nFor a very basic hunger games, we'll want\r\nthe `KitMechanic`, `AbilityMechanic`, `GameWorldSelectorMechanic`, `LootChestMechanic`, and `TeamMechanic` with\r\na `SingleTeamAssigner`. Let's take a look at how our `HungerGames` class changes to do this.\n\n```java\n public class HungerGames implements SingleWorldMineplexGame {\r\n    private final JavaPlugin myProjectPlugin;\r\n    private final MineplexGameModule gameModule;\r\n    private final MineplexGameMechanicFactory gameMechanicFactory;\r\n    private GameState gameState;\r\n\r\n    @Getter\r\n    private final List<LivingEntity> players = new ArrayList<>();\r\n\r\n    private AbilityMechanic abilityMechanic;\r\n    private KitMechanic kitMechanic;\r\n    private GameWorldSelectorMechanic gameWorldSelectorMechanic;\r\n    private LootChestMechanic lootChestMechanic;\r\n    private TeamMechanic teamMechanic;\r\n\r\n    public HungerGames(final JavaPlugin myProjectPlugin, final MineplexGameModule gameModule, final MineplexGameMechanicFactory gameMechanicFactory) {\r\n        this.myProjectPlugin = myProjectPlugin;\r\n        this.gameModule = gameModule;\r\n        this.gameMechanicFactory = gameMechanicFactory;\r\n        this.gameState = GameState.PREPARING;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Hunger Games\";\r\n    }\r\n\r\n    @Override\r\n    public MineplexGameModule getGameModule() {\r\n        return gameModule;\r\n    }\r\n\r\n    @Override\r\n    default MineplexGameMechanicFactory getGameMechanicFactory() {\r\n        return gameMechanicFactory;\r\n    }\r\n\r\n    @Override\r\n    public GameState getGameState() {\r\n        return gameState;\r\n    }\r\n\r\n    @Override\r\n    public void setGameState(GameState gameState) {\r\n        Bukkit.getPluginManager().callEvent(new MineplexGameStateChangeEvent(this,\r\n                this.gameState,\r\n                gameState));\r\n        abilityMechanic.onStateChange(this.gameState, gameState);\r\n        kitMechanic.onStateChange(this.gameState, gameState);\r\n        gameWorldSelectorMechanic.onStateChange(this.gameState, gameState);\r\n        lootChestMechanic.onStateChange(this.gameState, gameState);\r\n        teamMechanic.onStateChange(this.gameState, gameState);\r\n        this.gameState = gameState;\r\n\r\n        // When the game starts, teleport every player to a random spawn point, assign teams, and give them the kit\r\n        if (this.gameState == GameState.STARTED) {\r\n            final List<Location> spawns = getGameWorld().getDataPoints(\"SPAWN\");\r\n            players.forEach(player -> {\r\n                final Location spawn = spawns.get(ThreadLocalRandom.current().nextInt(spawns.size()));\r\n                player.teleport(spawn);\r\n\r\n                kitMechanic.grantKit(player, PlayerKit.class);\r\n            });\r\n            teamMechanic.assignTeams(players, teamMechanic.constructTeamAssigner(SingleTeamAssigner.class)\r\n                    .get());\r\n        } else if (this.gameState == GameState.ENDED) {\r\n            setGameState(GameState.CLEANING_UP);\r\n        } else if (this.gameState == GameState.CLEANING_UP) {\r\n            teardown();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setup() {\r\n        gameWorldSelectorMechanic = gameMechanicFactory.construct(GameWorldSelectorMechanic.class);\r\n        kitMechanic = gameMechanicFactory.construct(KitMechanic.class);\r\n        abilityMechanic = gameMechanicFactory.construct(AbilityMechanic.class);\r\n        lootChestMechanic = gameMechanicFactory.construct(LootChestMechanic.class);\r\n        teamMechanic = gameMechanicFactory.construct(TeamMechanic.class);\r\n\r\n        gameWorldSelectorMechanic.setup(this);\r\n        kitMechanic.setup(this);\r\n        abilityMechanic.setup(this);\r\n\r\n        // 60 seconds * 20 ticks per second\r\n        lootChestMechanic.setChestRefillDelay(60 * 20L);\r\n        lootChestMechanic.setChestDataPointKey(\"CHEST\");\r\n        // Loot pool, with a minimum of 3 items per chest and a max of 9\r\n        lootChestMechanic.setChestLootPool(List.of(\r\n                new ItemStack(Material.IRON_SWORD),\r\n                new ItemStack(Material.DIAMOND_CHESTPLATE),\r\n                new ItemStack(Material.WOODEN_SWORD),\r\n                new ItemStack(Material.GOLDEN_APPLE),\r\n                new ItemStack(Material.CHAINMAIL_HELMET),\r\n                new ItemStack(Material.BREAD, 5),\r\n                new ItemStack(Material.EGG, 16),\r\n                new ItemStack(Material.SNOWBALL, 10),\r\n                new ItemStack(Material.DIAMOND_AXE)), 3, 9);\r\n        lootChestMechanic.setup(this);\r\n\r\n        teamMechanic.setup(this);\r\n        teamMechanic.registerTeam(\"Players\", Component.text(\"Players\"));\r\n\r\n        // Register our kit\r\n        kitMechanic.registerKit(PlayerKit.class, new PlayerKit(kitMechanic, abilityMechanic, this));\r\n\r\n        Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        HandlerList.unregisterAll(this);\r\n\r\n        kitMechanic.teardown();\r\n        abilityMechanic.teardown();\r\n        teamMechanic.teardown();\r\n        lootChestMechanic.teardown();\r\n        gameWorldSelectorMechanic.teardown();\r\n\r\n        players.clear();\r\n        gameModule.setCurrentGame(null);\r\n    }\r\n\r\n    @Override\r\n    public MineplexWorld getGameWorld() {\r\n        return gameWorldSelectorMechanic.getSelectedGameWorld();\r\n    }\r\n\r\n    @EventHandler\r\n    public void onDeath(final PlayerDeathEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the dead player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put dead players in spectator mode and remove their kit\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onJoin(final PlayerJoinEvent event) {\r\n        // Automatically add new players to the game\r\n        if (gameState == GameState.PRE_START) {\r\n            players.add(event.getPlayer());\r\n\r\n            // If 5 or more players are playing, start the game\r\n            if (players.size() >= 5) {\r\n                setGameState(GameState.STARTED);\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventHandler\r\n    public void onQuit(final PlayerQuitEvent event) {\r\n        // If the game is currently ongoing\r\n        if (gameState == GameState.STARTED) {\r\n            // If the exiting player was playing this game\r\n            if (players.remove(event.getPlayer())) {\r\n                // Put exiting players in spectator mode and remove their kit\r\n                event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n                kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n                // If there is one player or less, end the game\r\n                if (players.size() <= 1) {\r\n                    setGameState(GameState.ENDED);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n```\n\nLet's try making a custom `GameMechanic` that makes players glow for a moment when they get hit.\n\n```java\n\r\n@AllArgsConstructor\r\npublic class DamageGlowMechanic implements GameMechanic<HungerGames> {\r\n   private final HungerGames game;\r\n   private final JavaPlugin myProjectPlugin;\r\n\r\n   @Override\r\n   public void setup(final HungerGames game) {\r\n       Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n   }\r\n\r\n   @Override\r\n   public void teardown() {\r\n       HandlerList.unregisterAll(this);\r\n   }\r\n\r\n   @Override\r\n   public void onStateChange(final GameState fromState, final GameState toState) {\r\n       // Nothing needs to be cleaned up on state change\r\n   }\r\n\r\n   // On damage, make players glow\r\n   @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\r\n   public void onDamage(final EntityDamageEvent event) {\r\n       if (event.getEntity() instanceof Player player) {\r\n           // If the game is ongoing\r\n           if (game.getGameState() == GameState.STARTED) {\r\n               // If the player taking damage is in the game\r\n               if (game.getPlayers().contains(player)) {\r\n                   // Make them glow for a bit\r\n                   player.addPotionEffect(new PotionEffect(PotionEffectType.GLOWING,\r\n                           // 5 seconds * 20 ticks per second\r\n                           5 * 20,\r\n                           // No need for a higher level of glowing\r\n                           0,\r\n                           // Not an ambient effect\r\n                           false,\r\n                           // No need for particles\r\n                           false,\r\n                           // No need for the potion effect icon\r\n                           false));\r\n               }\r\n           }\r\n       }\r\n   }\r\n}\n```\n\nNow let's see what we have to do in our `HungerGames` class to use this mechanic.\n\n```java\npublic class HungerGames implements SingleWorldMineplexGame {\r\n   private final JavaPlugin myProjectPlugin;\r\n   private final MineplexGameModule gameModule;\r\n   private GameState gameState;\r\n\r\n   @Getter\r\n   private final List<LivingEntity> players = new ArrayList<>();\r\n\r\n   private AbilityMechanic abilityMechanic;\r\n   private KitMechanic kitMechanic;\r\n   private GameWorldSelectorMechanic gameWorldSelectorMechanic;\r\n   private LootChestMechanic lootChestMechanic;\r\n   private TeamMechanic teamMechanic;\r\n   private DamageGlowMechanic damageGlowMechanic;\r\n\r\n   public HungerGames(final JavaPlugin myProjectPlugin, final MineplexGameModule gameModule) {\r\n       this.myProjectPlugin = myProjectPlugin;\r\n       this.gameModule = gameModule;\r\n       this.gameState = GameState.PREPARING;\r\n   }\r\n\r\n   @Override\r\n   public String getName() {\r\n       return \"Hunger Games\";\r\n   }\r\n\r\n   @Override\r\n   public MineplexGameModule getGameModule() {\r\n       return gameModule;\r\n   }\r\n\r\n   @Override\r\n   public GameState getGameState() {\r\n       return gameState;\r\n   }\r\n\r\n   @Override\r\n   public void setGameState(GameState gameState) {\r\n       Bukkit.getPluginManager().callEvent(new MineplexGameStateChangeEvent(this,\r\n               this.gameState,\r\n               gameState));\r\n       abilityMechanic.onStateChange(this.gameState, gameState);\r\n       kitMechanic.onStateChange(this.gameState, gameState);\r\n       gameWorldSelectorMechanic.onStateChange(this.gameState, gameState);\r\n       lootChestMechanic.onStateChange(this.gameState, gameState);\r\n       teamMechanic.onStateChange(this.gameState, gameState);\r\n       damageGlowMechanic.onStateChange(this.gameState, gameState);\r\n       this.gameState = gameState;\r\n\r\n       // When the game starts, teleport every player to a random spawn point, assign teams, and give them the kit\r\n       if (this.gameState == GameState.STARTED) {\r\n           final List<Location> spawns = getGameWorld().getDataPoints(\"SPAWN\");\r\n           players.forEach(player -> {\r\n               final Location spawn = spawns.get(ThreadLocalRandom.current().nextInt(spawns.size()));\r\n               player.teleport(spawn);\r\n\r\n               kitMechanic.grantKit(player, PlayerKit.class);\r\n           });\r\n           teamMechanic.assignTeams(players, teamMechanic.constructTeamAssigner(SingleTeamAssigner.class)\r\n                   .get());\r\n       } else if (this.gameState == GameState.ENDED) {\r\n           setGameState(GameState.CLEANING_UP);\r\n       } else if (this.gameState == GameState.CLEANING_UP) {\r\n           teardown();\r\n       }\r\n   }\r\n\r\n   @Override\r\n   public void setup() {\r\n       gameWorldSelectorMechanic = gameMechanicFactory.construct(GameWorldSelectorMechanic.class);\r\n       kitMechanic = gameMechanicFactory.construct(KitMechanic.class);\r\n       abilityMechanic = gameMechanicFactory.construct(AbilityMechanic.class);\r\n       lootChestMechanic = gameMechanicFactory.construct(LootChestMechanic.class);\r\n       teamMechanic = gameMechanicFactory.construct(TeamMechanic.class);\r\n       damageGlowMechanic = new DamageGlowMechanic(this, myProjectPlugin);\r\n\r\n       gameWorldSelectorMechanic.setup(this);\r\n       kitMechanic.setup(this);\r\n       abilityMechanic.setup(this);\r\n\r\n       // 60 seconds * 20 ticks per second\r\n       lootChestMechanic.setChestRefillDelay(60 * 20L);\r\n       lootChestMechanic.setChestDataPointKey(\"CHEST\");\r\n       // Loot pool, with a minimum of 3 items per chest and a max of 9\r\n       lootChestMechanic.setChestLootPool(List.of(\r\n               new ItemStack(Material.IRON_SWORD),\r\n               new ItemStack(Material.DIAMOND_CHESTPLATE),\r\n               new ItemStack(Material.WOODEN_SWORD),\r\n               new ItemStack(Material.GOLDEN_APPLE),\r\n               new ItemStack(Material.CHAINMAIL_HELMET),\r\n               new ItemStack(Material.BREAD, 5),\r\n               new ItemStack(Material.EGG, 16),\r\n               new ItemStack(Material.SNOWBALL, 10),\r\n               new ItemStack(Material.DIAMOND_AXE)), 3, 9);\r\n       lootChestMechanic.setup(this);\r\n\r\n       teamMechanic.setup(this);\r\n       teamMechanic.registerTeam(\"Players\", Component.text(\"Players\"));\r\n\r\n       // Register our kit\r\n       kitMechanic.registerKit(PlayerKit.class, new PlayerKit(kitMechanic, abilityMechanic, this));\r\n\r\n       damageGlowMechanic.setup(this);\r\n\r\n       Bukkit.getPluginManager().registerEvents(this, myProjectPlugin);\r\n   }\r\n\r\n   @Override\r\n   public void teardown() {\r\n       HandlerList.unregisterAll(this);\r\n\r\n       damageGlowMechanic.teardown();\r\n       kitMechanic.teardown();\r\n       abilityMechanic.teardown();\r\n       teamMechanic.teardown();\r\n       lootChestMechanic.teardown();\r\n       gameWorldSelectorMechanic.teardown();\r\n\r\n       players.clear();\r\n       gameModule.setCurrentGame(null);\r\n   }\r\n\r\n   @Override\r\n   public MineplexWorld getGameWorld() {\r\n       return gameWorldSelectorMechanic.getSelectedGameWorld();\r\n   }\r\n\r\n   @EventHandler\r\n   public void onDeath(final PlayerDeathEvent event) {\r\n       // If the game is currently ongoing\r\n       if (gameState == GameState.STARTED) {\r\n           // If the dead player was playing this game\r\n           if (players.remove(event.getPlayer())) {\r\n               // Put dead players in spectator mode and remove their kit\r\n               event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n               kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n               // If there is one player or less, end the game\r\n               if (players.size() <= 1) {\r\n                   setGameState(GameState.ENDED);\r\n               }\r\n           }\r\n       }\r\n   }\r\n\r\n   @EventHandler\r\n   public void onJoin(final PlayerJoinEvent event) {\r\n       // Automatically add new players to the game\r\n       if (gameState == GameState.PRE_START) {\r\n           players.add(event.getPlayer());\r\n\r\n           // If 5 or more players are playing, start the game\r\n           if (players.size() >= 5) {\r\n               setGameState(GameState.STARTED);\r\n           }\r\n       }\r\n   }\r\n\r\n   @EventHandler\r\n   public void onQuit(final PlayerQuitEvent event) {\r\n       // If the game is currently ongoing\r\n       if (gameState == GameState.STARTED) {\r\n           // If the exiting player was playing this game\r\n           if (players.remove(event.getPlayer())) {\r\n               // Put exiting players in spectator mode and remove their kit\r\n               event.getPlayer().setGameMode(GameMode.SPECTATOR);\r\n               kitMechanic.removeKit(event.getPlayer(), PlayerKit.class);\r\n               // If there is one player or less, end the game\r\n               if (players.size() <= 1) {\r\n                   setGameState(GameState.ENDED);\r\n               }\r\n           }\r\n       }\r\n   }\r\n}\n```\n\nFinally, let's look at how our game gets started!\n\n## Project Plugin Class\n\n```java\npublic class MyProject extends JavaPlugin {\r\n   private HungerGames game;\r\n\r\n   @Override\r\n   public void onEnable() {\r\n       final MineplexGameModule gameModule = MineplexModuleManager.getRegisteredModule(\r\n               MineplexGameModule.class);\r\n       game = new HungerGames(this, gameModule);\r\n       gameModule.setCurrentGame(game);\r\n       game.setGameState(GameState.PRE_START);\r\n   }\r\n\r\n   @Override\r\n   public void onDisable() {\r\n       game.teardown();\r\n   }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics/ability",
    "title": "Ability Game Mechanic",
    "description": "How to use the Ability Game Mechanic.",
    "content": "### Mechanic\n\nThe `AbilityMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic allows you to\r\ncreate `Ability`s and grant/remove them to/from `LivingEntity`s. `Ability`s can be tightly coupled to a\r\nspecific `MineplexGame`, or left generic to support a wide variety of games.\n\n#### Interface\n\nThe base `Ability` interface defines a few methods that must be implemented by any specific `Ability`. These include\r\nmethods like getting the name of the `Ability`, setup and teardown methods for the `Ability` instance, and start and\r\nstop methods for when the `Ability` is granted to/removed from a specific `LivingEntity`.\r\nIn addition to the base `Ability` interface, there are two specific types of `Ability`: `PassiveAbility`, an interface\r\nthat defines an `Ability` which is constantly running as long as a `LivingEntity` possesses it, which may grant\r\nthe `LivingEntity` passive bonuses like fall damage reduction or regeneration, and `ActiveAbility`, which performs some\r\nspecific action when triggered. The specific `Ability` is required to implement the passive granted by\r\nthe `PassiveAbility`, as well as listening for the trigger of an `ActiveAbility` and implementing the activation and\r\ndeactivation behavior. All registered `Ability`s function as `Listener`s, and do not have to be explicitly\r\nregistered/unregistered with Bukkit by you.\n\n#### Factory\n\nAn `AbilityFactory` provides for the dynamic construction of instances of a specific `Ability`. To function, the factory\r\nneeds to be registered in the `AbilityMechanic` using\r\nthe `registerAbilityFactory(Class<A extends Ability<G extends MineplexGame>>, AbilityFactory<G, A>)` method. Once the\r\nfactory has been registered, you can use the `AbilityMechanic` to construct instances of the `Ability` using\r\nthe `constructAbility(Class<A extends Ability<G extends MineplexGame>>, G)` method. All built-in `Ability`s that we\r\nprovide have their factories pre-registered in the `AbilityMechanic`, so all you have to do is construct an instance\r\nwhen you want to use them. You do not need to create an `AbilityFactory` for your own custom `Ability`s, but you can if\r\nyou'd like to. You will need to implement your own `AbilityFactory` if you plan to sell source-unavailable `Ability`s to\r\nother developers on our asset marketplace.\n\n## Examples\n\n## Passive Ability\n\nLet's make a custom passive ability that makes players take no fall damage.\n\n```java\n// Since this ability doesn't need to do anything specific to Hunger Games, we can make it generic,\r\n// so we can reuse it!\r\n@AllArgsConstructor\r\npublic class WeightlessAbility implements PassiveAbility<MineplexGame> {\r\n    private final AbilityMechanic abilityMechanic;\r\n    private final MineplexGame game;\r\n\r\n    @Override\r\n    public AbilityMechanic getAbilityMechanic() {\r\n        return abilityMechanic;\r\n    }\r\n\r\n    @Override\r\n    public MineplexGame getGame() {\r\n        return game;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Weightless\";\r\n    }\r\n\r\n    @Override\r\n    public void setup(final MineplexGame game) {\r\n        // This ability doesn't need to allocate any additional resources\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        // This ability has no additionally allocated resources to clean up\r\n    }\r\n\r\n    @Override\r\n    public void start(final LivingEntity livingEntity) {\r\n        // This ability doesn't do anything to the host when it starts\r\n    }\r\n\r\n    @Override\r\n    public void stop(final LivingEntity livingEntity) {\r\n        // This ability doesn't do anything to the host that needs to be removed\r\n    }\r\n\r\n    @Override\r\n    public void tick(LivingEntity livingEntity) {\r\n        // This ability doesn't do anything on every tick\r\n    }\r\n\r\n    // Stop fall damage\r\n    @EventHandler\r\n    public void onFallDamage(final EntityDamageEvent event) {\r\n        // If the entity taking damage has this ability\r\n        if (event.getEntity() instanceof LivingEntity livingEntity && hasAbility(livingEntity)) {\r\n            // Only cancel fall damage\r\n            if (event.getCause() == EntityDamageEvent.DamageCause.FALL) {\r\n                event.setCancelled(true);\r\n            }\r\n        }\r\n    }\r\n}\n```\n\n```java\n// Since this ability doesn't need to do anything specific to Hunger Games, we can make it generic,\r\n// so we can reuse it!\r\n@AllArgsConstructor\r\npublic class SneakyAbility implements ActiveAbility<MineplexGame> {\r\n    private final AbilityMechanic abilityMechanic;\r\n    private final MineplexGame game;\r\n\r\n    @Override\r\n    public AbilityMechanic getAbilityMechanic() {\r\n        return abilityMechanic;\r\n    }\r\n\r\n    @Override\r\n    public MineplexGame getGame() {\r\n        return game;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Sneaky\";\r\n    }\r\n\r\n    @Override\r\n    public void setup(final MineplexGame game) {\r\n        // This ability doesn't need to allocate any additional resources\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        // This ability has no additionally allocated resources to clean up\r\n    }\r\n\r\n    @Override\r\n    public void start(final LivingEntity livingEntity) {\r\n        // This ability doesn't do anything to the host when it starts\r\n    }\r\n\r\n    @Override\r\n    public void stop(final LivingEntity livingEntity) {\r\n        livingEntity.removePotionEffect(PotionEffectType.INVISIBILITY);\r\n    }\r\n\r\n    @Override\r\n    public void activate(final LivingEntity livingEntity) {\r\n        // Grant 10 seconds of invisibility\r\n        livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.INVISIBILITY,\r\n                // 10 seconds * 20 ticks per second\r\n                10 * 20,\r\n                // Invisibility level 1, no need for an amplifier\r\n                0,\r\n                // This is not an ambient effect\r\n                false,\r\n                // We don't want to give away the player with potion particles\r\n                false,\r\n                // We do want the potion effect icon to show up on the player's screen\r\n                true));\r\n    }\r\n\r\n    @Override\r\n    public void deactivate(final LivingEntity livingEntity) {\r\n        livingEntity.removePotionEffect(PotionEffectType.INVISIBILITY);\r\n    }\r\n\r\n    // Listen for crouching\r\n    @EventHandler\r\n    public void onCrouch(final PlayerToggleSneakEvent event) {\r\n        // If the player has this ability\r\n        if (hasAbility(event.getPlayer()) && event.isSneaking()) {\r\n            // If they are crouching, activate, otherwise, deactivate\r\n            if (event.isSneaking()) {\r\n                activate(event.getPlayer());\r\n            } else {\r\n                deactivate(event.getPlayer());\r\n            }\r\n        }\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics",
    "title": "Built-In Game Mechanics",
    "description": "How to use the built-in Mineplex Studio Game MEchanics.",
    "content": "The Studio SDK comes with extensive built-in Game Mechanics that provide foundational functionality for all Studio\r\nprojects. These built-in Game Mechanics are automatically registered, and can be accessed via\r\nthe `MineplexGameMechanicFactory` method `construct(Class<T extends GameMechanic<? extends MineplexGame>)`\n\n## Pricing\n\nBuilt-in mechanics are provided free-of-charge!\n\n## Example\n\nLet's say we want to use the `Ability` mechanic in our project. As a very first step, we need to get\r\na new instance of it.\n\n```java\npublic class ExampleGame implements MineplexGame {\r\n    private final MineplexGameMechanicFactory gameMechanicFactory =\r\n            MineplexModuleManager.getRegisteredModule(MineplexGameMechanicFactory.class);\r\n\r\n    private AbilityMechanic abilityMechanic;\r\n    \r\n    @Override\r\n    public void setup() {\r\n        this.abilityMechanic = this.gameMechanicFactory.construct(AbilityMechanic.class);\r\n        this.abilityMechanic.setup(this);\r\n        \r\n        // TODO: Register your own abilities here\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        this.abilityMechanic.teardown();\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics/kit",
    "title": "Kit Game Mechanic",
    "description": "How to use the Kit Game Mechanic.",
    "content": "### Mechanic\n\nThe `KitMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic allows you to\r\ncreate `Kit`s and grant/remove them to/from `LivingEntity`s. `Kit`s can be tightly coupled to a specific `MineplexGame`,\r\nor left generic to support a wide variety of games.\n\n#### Interface\n\nThe `Kit` interface defines a few methods that must be implemented by any specific `Kit`. These include methods like\r\ngetting the name of the `Kit`, setup and teardown methods for the `Kit` instance, and a `giveKit(LivingEntity)` method\r\ncalled whenever your game wishes to give the kit to a specific `LivingEntity` that has the kit (such as on game start,\r\nor respawns). The interface also has a `removeKit(LivingEntity)` method called when the kit is removed from\r\na `LivingEntity`. All registered `Kit`s function as `Listener`s, and do not have to be explicitly\r\nregistered/unregistered with Bukkit by you.\n\n#### Factory\n\nA `KitFactory` provides for the dynamic construction of instances of a specific `Kit`. To function, the factory needs to\r\nbe registered in the `KitMechanic` using\r\nthe `registerKitFactory(Class<K extends Kit<G extends MineplexGame>>, KitFactory<G, K>)` method. Once the factory has\r\nbeen registered, you can use the `KitMechanic` to construct instances of the `Kit` using\r\nthe `constructKit(Class<K extends Kit<G extends MineplexGame>>, G)` method. All built-in `Kit`s that we provide have\r\ntheir factories pre-registered in the `KitMechanic`, so all you have to do is construct an instance when you want to use\r\nthem. You do not need to create a `KitFactory` for your own custom `Kit`s, but you can if you'd like to. You will need\r\nto implement your own `KitFactory` if you plan to sell source-unavailable `Kit`s to other developers on our asset\r\nmarketplace.\n\n## Examples\n\n## Player Kit\n\nLet's give each player some leather armor and a stone sword when they start, as well as our two abilities.\n\n```java\n// Since this kit doesn't need to do anything specific to Hunger Games,\r\n// we can make it generic, so we can reuse it!\r\npublic class PlayerKit implements Kit<MineplexGame> {\r\n    // We want to give our two abilities to anyone with this kit\r\n    private final WeightlessAbility weightlessAbility;\r\n    private final SneakyAbility sneakyAbility;\r\n    private final AbilityMechanic abilityMechanic;\r\n    private final KitMechanic kitMechanic;\r\n    private final MineplexGame game;\r\n\r\n    public PlayerKit(final KitMechanic kitMechanic,\r\n                     final AbilityMechanic abilityMechanic,\r\n                     final MineplexGame game) {\r\n        weightlessAbility = new WeightlessAbility(abilityMechanic, game);\r\n        sneakyAbility = new SneakyAbility(abilityMechanic, game);\r\n        this.abilityMechanic = abilityMechanic;\r\n        this.kitMechanic = kitMechanic;\r\n        this.game = game;\r\n    }\r\n\r\n    @Override\r\n    public KitMechanic getKitMechanic() {\r\n        return kitMechanic;\r\n    }\r\n\r\n    @Override\r\n    public MineplexGame getGame() {\r\n        return game;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"Player\";\r\n    }\r\n\r\n    @Override\r\n    public void setup(final MineplexGame game) {\r\n        abilityMechanic.registerAbility(WeightlessAbility.class, weightlessAbility);\r\n        abilityMechanic.registerAbility(SneakyAbility.class, sneakyAbility);\r\n    }\r\n\r\n    @Override\r\n    public void teardown() {\r\n        abilityMechanic.destroyAbility(WeightlessAbility.class);\r\n        abilityMechanic.destroyAbility(SneakyAbility.class);\r\n    }\r\n\r\n    @Override\r\n    public void giveKit(final LivingEntity livingEntity) {\r\n        if (!abilityMechanic.hasAbility(livingEntity, WeightlessAbility.class)) {\r\n            abilityMechanic.grantAbility(livingEntity, WeightlessAbility.class);\r\n        }\r\n\r\n        if (!abilityMechanic.hasAbility(livingEntity, SneakyAbility.class)) {\r\n            abilityMechanic.grantAbility(livingEntity, SneakyAbility.class);\r\n        }\r\n\r\n        final EntityEquipment equipment = livingEntity.getEquipment();\r\n        equipment.setHelmet(new ItemStack(Material.LEATHER_HELMET));\r\n        equipment.setChestplate(new ItemStack(Material.LEATHER_CHESTPLATE));\r\n        equipment.setLeggings(new ItemStack(Material.LEATHER_LEGGINGS));\r\n        equipment.setBoots(new ItemStack(Material.LEATHER_BOOTS));\r\n        equipment.setItemInMainHand(new ItemStack(Material.STONE_SWORD));\r\n    }\r\n\r\n    @Override\r\n    public void removeKit(final LivingEntity livingEntity) {\r\n        if (abilityMechanic.hasAbility(livingEntity, WeightlessAbility.class)) {\r\n            abilityMechanic.removeAbility(livingEntity, WeightlessAbility.class);\r\n        }\r\n\r\n        if (abilityMechanic.hasAbility(livingEntity, SneakyAbility.class)) {\r\n            abilityMechanic.removeAbility(livingEntity, SneakyAbility.class);\r\n        }\r\n    }\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/game/mechanics/team",
    "title": "Team Game Mechanic",
    "description": "",
    "content": "### Team Mechanic\n\nThe `TeamMechanic` is one of the built-in `GameMechanic`s bundled with the Studio SDK. This mechanic allows you to\r\ncreate `GameTeam`s, assign them names, and have `LivingEntity`s join the created teams. Additionally, `TeamAssigner`s\r\nallow for the assignment of groups to available teams based on predefined behavior using\r\nthe `assignTeams(Collection<LivingEntity>, TeamAssigner)` method.\n\n#### Team Assigner Factory\n\nA `TeamAssignerFactory` provides for the dynamic construction of instances of a specific `TeamAssigner`. To function,\r\nthe factory needs to be registered in the `TeamMechanic` using\r\nthe `registerTeamAssignerFactory(Class<T extends TeamAssigner>, TeamAssignerFactory<T>)` method. Once the factory has\r\nbeen registered, you can use the `TeamMechanic` to construct instances of the `TeamAssigner` using\r\nthe `constructTeamAssigner(Class<T extends TeamAssigner>)` method. All built-in `TeamAssigner`s that we provide have\r\ntheir factories pre-registered in the `TeamMechanic`, so all you have to do is construct an instance when you want to\r\nuse them. You do not need to create a `TeamAssignerFactory` for your own custom `TeamAssigner`s, but you can if you'd\r\nlike to. You will need to implement your own `TeamAssignerFactory` if you plan to sell source-unavailable `TeamAssigner`\r\ns to other developers on our asset marketplace. We currently provide two built-in `TeamAssigner`s:\n\n* `SingleTeamAssigner` - groups all `LivingEntity`s into the single team in the `TeamMechanic`\n* `EvenTeamsAssigner` - assigns all `LivingEntity`s to teams in the most even way possible. Can be configured\r\n  with `setShouldGroupParties(boolean)` to attempt to put parties on the same team if they fit\n"
  },
  {
    "slug": "/sdk/features",
    "title": "Built-In Modules",
    "description": "How to use the built-in Mineplex Studio Modules.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.MineplexModule\" />\n\nThe Studio SDK comes with extensive built-in Modules that provide foundational functionality for all Studio projects. These built-in Modules are automatically registered and enabled on startup, and can be accessed via the `MineplexModuleManager` method `getRegisteredModule(Class<T extends MineplexModule>)`. You should **never** manually destroy or disable these Modules.\n\n## Pricing (usually free!)\n\nBuilt-in modules are provided free-of-charge, with some restrictions, for developers that use a profit-sharing payout model (this probably applies to you!).\n\nWe also offer a metered pricing tier to select game publishers, with minimum revenue and support model requirements. Built-in Modules are generally significantly cheaper than hosting other services or using equivalent functionalities provided outside the Studio.\n\n## Example\n\nLet's say we want to create a new `MineplexWorld` in our project. As a very first step, we need to get the `MineplexWorldModule`.\n\n```java\npublic void createWorlds() {\r\n    final MineplexWorldModule worldModule = MineplexModuleManager.getRegisteredModule(MineplexWorldModule.class);\r\n\r\n    // Now create worlds...\r\n}\n```\n\nNow that we have the module, we can proceed with world creation.\n"
  },
  {
    "slug": "/sdk/features/leaderboard",
    "title": "Leaderboard Module",
    "description": "How to use the Mineplex Studio Leaderboard Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.leaderboard.LeaderboardModule\" />\n\nThe Leaderboard Module is one of the built-in Studio Modules that allows you to create dynamic leaderboards based on whatever metric you want. Leaderboards can rank players, teams, or any other entity of your choosing, and are updated in real time. As soon as a leaderboard is changed, it is retrievable with the freshest data.\n\n## Leaderboard Retrieval\n\nYou can choose to retrieve a leaderboard by the top N players using the `getLeaderboard(String, int)` method, or query for the exact leaderboard position of a specific player/team/entity/etc using the `getLeaderboardEntry(String, String)` method.\n\n## Leaderboard Updates\n\nYou can also wipe a specific entry off a leaderboard using the `clearLeaderboardScore(String, String)` method, or clear the whole board at once with the `clearLeaderboard(String)` method. Leaderboards can be updated by either directly setting an entry score with the `updateLeaderboardScore(String, String, double)` method, or by incrementing by a specified amount using the `incrementLeaderboardScore(String, String, double)` method.\n\n## Alternative Methods\n\nAll leaderboard methods can be run synchronously or asynchronously to ensure you avoid blocking the main thread. Additionally, all the leaderboard update and entry query methods will directly accept a Player instead of an entry ID.\n\n## Examples\n\n## Getting the Top 10 Kills Leaderboard\n\nLet's say our game tracks player kills on a leaderboard. We can retrieve the top 10 players on this leaderboard at any time.\n\n```java\npublic CompletableFuture<List<LeaderboardEntry>> getTopKills() {\r\n    return leaderboardModule.getLeaderboardAsync(\"Kills\", 10);\r\n}\n```\n\n## Incrementing the Kills Leaderboard\n\nEvery time a player gets a kill, we want to update the leaderboard with their new score.\n\n```java\npublic void onKill(final Player killer, final Player victim) {\r\n    leaderboardModule.incrementLeaderboardScore(\"Kills\", killer, 1);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/levels",
    "title": "Level Module",
    "description": "How to use the Mineplex Studio Level Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.level.MineplexLevelModule\" />\n\nThe `MineplexLevelModule` is a module for managing player leveling and experience in the Mineplex system. It provides methods for retrieving, updating, and managing player experience data. This module supports both online and offline players, allowing asynchronous access to player data and rewarding players with experience.\n\n## Key Features\n\n* Retrieve Player Experience: Fetch experience data for individual or multiple players.\n* Cache Support: Access experience data for online players directly from the cache.\n* Asynchronous Operations: All retrieval and update operations are non-blocking, using CompletableFuture for concurrency.\n* Experience Rewarding: Grant experience to players via predefined sessions.\n\n## Rewarding players\n\nWe have designed our system to allow partners to add weights to each action. Rather than directly awarding xp, you report a game session and the players' total action values. This allows us to calculate how much xp to award them based on their own player profile, and network conditions.\n\nTo award, we use the Module's rewardGame method:\n\n```java\n@NonNull CompletableFuture<@NonNull Map<@NonNull UUID, @NonNull ExperienceAwardResult>>\r\nrewardGame(@NonNull MineplexExperienceSession levelSession)\n```\n\n### In-built Example\n\nWe have an in-built `MineplexExperienceSessionImpl` which implements the `MineplexExperienceSession` to provide session functionality.\n\n<Step>\n  <StepItem title=\"Construct the session\">\n    ```java\n    final MineplexExperienceSessionImpl experienceSession = MineplexExperienceSessionImpl.start();\n    ```\n\n    This example will use this class, but you are welcome to create your own implementing class. This is the session we'll be using to award player's with points, which will be converted into experience by our backend system.\n  </StepItem>\n\n  <StepItem title=\"Award your points\">\n    So, the player did something cool, like getting a kill, or claiming a beacon, reward them!\n\n    ```java\n    final Player player = event.getPlayer();\r\n    final int points = 5;\r\n    experienceSession.addPoints(player, points);\n    ```\n  </StepItem>\n\n  <StepItem title=\"Apply the session\">\n    Once your game comes to an end (and only when this happens!), apply the session's results to the players.\n\n    ```java\n    final MineplexLevelModule levelModule = MineplexModuleManager.getRegisteredModule(MineplexLevelModule.class);\r\n    // I'm using get here on the future, make sure you're handling the thread safety properly\r\n    final CompletableFuture<Map<UUID, ExperienceAwardResult>> awardFuture = levelModule.rewardGame(experienceSession);\n    ```\n  </StepItem>\n\n  <StepItem title=\"Inform the players\">\n    Once you've told our backend about your session, now we'll tell you how much each player earned!\n\n    ```java\n    // Handle the Future asynchronously to avoid blocking the main thread\r\n    awardFuture.thenAcceptAsync(result -> {\r\n        // Inform the players inside the callback\r\n        result.forEach((uuid, awarded) -> {\r\n            // Use Bukkit or your game player store API to get the player\r\n            final Player player = Bukkit.getPlayer(uuid);\r\n            // remember to null check awarded, this will happen if nothing is given.\r\n            if (player != null && awarded != null) {\r\n                player.sendMessage(Component.text(\"You have earned \" + awarded.getAwardedExperience() + \" Mineplex Network exp!\"));\r\n                // Send level-up message\r\n                if (awarded.hasLevelIncreased()) {\r\n                    player.sendMessage(Component.text(\"You have increased in Mineplex Network Level!\")); // Add your styling, perhaps include the level!\r\n                }\r\n            }\r\n        });\r\n    }).exceptionally(ex -> {\r\n        // Handle any errors during the reward process\r\n        ex.printStackTrace();\r\n        return null; // Return null to satisfy the exceptionally handler\r\n    });\n    ```\n  </StepItem>\n</Step>\n\n## Other Methods\n\n### Retrieve Player Experience by `OfflinePlayer`\n\n```java\n@NonNull CompletableFuture<@NonNull MineplexPlayerExperience> getPlayerExperience(@NonNull OfflinePlayer player)\n```\n\n#### Example Usage:\n\n```java\nOfflinePlayer player = Bukkit.getOfflinePlayer(\"playerName\");\r\nmineplexLevelModule.getPlayerExperience(player).thenAccept(experience -> {\r\n    System.out.println(\"Player Level: \" + experience.getLevel());\r\n});\n```\n\n### Retrieve Player Experience by `UUID`\n\n```java\n@NonNull CompletableFuture<@NonNull MineplexPlayerExperience> getPlayerExperience(@NonNull UUID playerId)\n```\n\n#### Example Usage:\n\n```java\nUUID playerId = UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\");\r\nmineplexLevelModule.getPlayerExperience(playerId).thenAccept(experience -> {\r\n    System.out.println(\"Player XP: \" + experience.getExperience());\r\n});\n```\n"
  },
  {
    "slug": "/sdk/features/messaging",
    "title": "Messaging Module",
    "description": "How to use the Mineplex Studio Messaging Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.messaging.MessagingdModule\" />\n\nThe Messaging Module enables communication between containers in the same namespace by sending and receiving messages. Messages can be targeted to specific containers based on various criteria.\n\n## Key Concepts\n\n* **Namespace-Specific Messaging**: Messages can only be sent to and received from containers within the same namespace.\n* **Event-Driven Architecture**: Messages trigger events, enabling responsive and asynchronous communication.\n* **Targeted Delivery:** Messages can be directed to specific containers, projects, or namespaces.\n\n## Use Cases\n\n* **Inter-Container Communication:** Facilitate communication between different containers within the same namespace for coordinated actions.\n* **Event Handling:** Use event-driven architecture to respond to specific messages with appropriate handlers.\n* **Targeted Messaging:** Send messages to specific containers based on predefined criteria for targeted communication.\n\n## Primary Functionalities\n\n### Registering a Listener\n\nYou can register a listener to receive messages associated with a specific key. When a message with the registered key is received, an AsyncMineplexMessageReceivedEvent is triggered.\n\n```java\nvoid registerKey(@NonNull String key);\n```\n\n#### Parameters:\n\n* key: The key for the messages you want to listen for.\n\n### Sending a Message to a Single Target\n\nSend a message to a specific target with a designated key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessage(\r\n    @NonNull String key, \r\n    @NonNull Object message, \r\n    @NonNull MineplexMessageTarget target\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* message: The message content.\n* target: The target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n### Sending a Message to Multiple Targets\n\nSend a message to multiple specified targets with a designated key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessage(\r\n    @NonNull String key, \r\n    @NonNull Object message, \r\n    @NonNull Collection<@NonNull MineplexMessageTarget> targets\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* message: The message content.\n* targets: Collection of target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n### Sending Multiple Messages to a Single Target\n\nSend multiple messages to a single target with the same key.\n\n```java\n@NonNull CompletableFuture<Void> sendMessages(\r\n    @NonNull String key, \r\n    @NonNull Collection<@NonNull Object> messages, \r\n    @NonNull MineplexMessageTarget target\r\n);\n```\n\n#### Parameters:\n\n* key: Identifier for the message type.\n* messages: Collection of messages to be sent.\n* target: The target container details.\n\n#### Returns:\n\nA `CompletableFuture<Void>` indicating the success or failure of the send operation.\n\n## MineplexMessageTarget\n\n### Matching Namespace\n\nCreate a message target by targeting any container in a given namespace.\n\n```java\npublic static MineplexMessageTarget matchingNamespace(@NonNull final String namespaceIdentifier);\n```\n\n### Matching Project\n\nCreate a message target by targeting any container in a given project.\n\n```java\npublic static MineplexMessageTarget matchingProject(@NonNull final String projectIdentifier);\n```\n\n### Matching Pod\n\nCreate a message target by targeting a specific container.\n\n```java\npublic static MineplexMessageTarget matchingPod(@NonNull final String podIdentifier);\n```\n\n## Example\n\nTo assist in using this module, here is an example which sends and receives message objects.\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport lombok.Builder;\r\nimport lombok.Getter;\r\nimport lombok.extern.jackson.Jacksonized;\r\n\r\n@Jacksonized\r\n@Data\r\n@Builder\r\npublic class GameMessage {\r\n    String message;\r\n}\n```\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport com.mineplex.studio.sdk.modules.messaging.MessagingModule;\r\nimport com.mineplex.studio.sdk.modules.MineplexModuleManager;\r\nimport com.mineplex.studio.sdk.modules.messaging.target.MineplexMessageTarget;\r\nimport org.bukkit.plugin.java.JavaPlugin;\r\n\r\npublic class MyGame extends JavaPlugin {\r\n\r\n    private MessagingModule messagingModule;\r\n\r\n    @Override\r\n    public void onEnable() {\r\n        // Initialize the messaging module\r\n        this.messagingModule = MineplexModuleManager.getRegisteredModule(MessagingModule.class);\r\n\r\n        // Register a listener for incoming messages\r\n        // This is only required if you'd like to also listen to the incoming message on this key\r\n        messagingModule.registerKey(\"exampleKey\");\r\n\r\n        // Send a test message\r\n        sendMessage();\r\n    }\r\n\r\n    private void sendMessage() {\r\n        final String key = \"exampleKey\";\r\n        final GameMessage message = GameMessage.builder().message(\"Hello from MessagingPlugin!\").build();\r\n\r\n        // namespace ID can be found in your configuration file\r\n        final MineplexMessageTarget target = MineplexMessageTarget.matchingNamespace(\"exampleNamespace\");\r\n\r\n        messagingModule\r\n          .sendMessage(key, message, target)\r\n          .thenAccept(voidResult -> {\r\n                getLogger().info(\"Message sent successfully.\");\r\n            }).exceptionally(ex -> {\r\n                getLogger().severe(\"Failed to send message: \" + ex.getMessage());\r\n                return null;\r\n            }\r\n        );\r\n    }\r\n}\n```\n\nAnd then to listen to the messaging that will come in:\n\n```java\npackage com.mineplex.studio.example;\r\n\r\nimport com.mineplex.studio.sdk.modules.messaging.event.AsyncMineplexMessageReceivedEvent;\r\nimport org.bukkit.event.EventHandler;\r\nimport org.bukkit.event.Listener;\r\nimport org.bukkit.plugin.java.JavaPlugin;\r\n\r\nimport java.util.Optional;\r\n\r\npublic class MessageListener implements Listener {\r\n\r\n    private final JavaPlugin plugin;\r\n\r\n    public MessageListener(final JavaPlugin plugin) {\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    @EventHandler\r\n    public void onMessageReceived(final AsyncMineplexMessageReceivedEvent event) {\r\n        final Optional<GameMessage> data = event.getMessageIf(\"exampleKey\");\r\n        if (data.isPresent()) {\r\n            final String message = data.getMessage();\r\n            plugin.getLogger().info(\"Received message: \" + message);\r\n        }\r\n    }\r\n}\n```\n\nAnd don't forget to register the listener in your main class!\n\n```java\ngetServer().getPluginManager().registerEvents(new MessageListener(this), this);\n```\n"
  },
  {
    "slug": "/sdk/features/moderation/command",
    "title": "Default Punishment Command",
    "description": "How to use the default punishment command",
    "content": "<Note title=\"This can be disabled\" type=\"note\">\n  If you'd like to create your own command, use the Moderation Module's `disableDefaultPunishmentCommand()` method.\n</Note>\n\n## Permissions\n\n### General Permissions\n\n* **`mineplex.moderation.*`**\\\n  Grants access to all moderation features.\n\n### Command Permissions\n\n* **`mineplex.moderation.command.punish`**\\\n  Grants access to the punishment command.\n\n#### View Punishments\n\n* **`mineplex.moderation.command.punish.view`**\\\n  Allows viewing all punishments.\n* **`mineplex.moderation.command.punish.view.history`**\\\n  Allows viewing punishment histories.\n\n#### View Details\n\n* **`mineplex.moderation.command.punish.view.details.*`**\\\n  Grants access to all punishment details.\n* **`mineplex.moderation.command.punish.view.details.notes`**\\\n  Allows viewing punishment notes.\n* **`mineplex.moderation.command.punish.view.details.issuer`**\\\n  Allows viewing the issuer of punishments.\n  * **`mineplex.moderation.command.punish.view.details.issuer.self`**\\\n    Allows viewing punishments issued by the user.\n  * **`mineplex.moderation.command.punish.view.details.issuer.other`**\\\n    Allows viewing punishments issued by others.\n* **`mineplex.moderation.command.punish.view.details.remover.*`**\\\n  Grants access to see who removed punishments.\n  * **`mineplex.moderation.command.punish.view.details.remover.self`**\\\n    Allows viewing punishments removed by the user.\n  * **`mineplex.moderation.command.punish.view.details.remover.other`**\\\n    Allows viewing punishments removed by others.\n\n#### Remove Punishments\n\n* **`mineplex.moderation.command.punish.remove.*`**\\\n  Grants permission to remove all punishments.\n* **`mineplex.moderation.command.punish.remove.self`**\\\n  Allows removing punishments issued by the user.\n* **`mineplex.moderation.command.punish.remove.other`**\\\n  Allows removing punishments issued by others.\n\n#### Create Punishments\n\n* **`mineplex.moderation.command.create`**\\\n  Grants access to create punishments.\n* **`mineplex.moderation.command.create.reason.*`**\\\n  Allows creating punishments for all reasons.\n* **`mineplex.moderation.command.create.reason.[reason_identifier]`**\\\n  Allows creating punishments for specific reasons (`[reason_identifier]`).\n"
  },
  {
    "slug": "/sdk/features/moderation",
    "title": "Moderation Module",
    "description": "How to use the Mineplex Studio Moderation Module to enforce rules on your projects.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.moderation.ModerationModule\" />\n\nThe Moderation Module is one of the built-in Studio Modules that allows you to manage and enforce player behavior within your projects. With this module, you can punish specific players through various means such as bans, mutes, or other restrictions. These punishments can be managed by your project's moderation team and tailored to fit the needs of your community.\n\n<Note title=\"Important Note\" type=\"danger\">\n  If you'd like to make your own punishment system, all punishments must go through this Module, this helps us track punishments, handle appeals and ensure accountability. Please do not create your own Punishment table / Punishment database, this will result in your project being rejected. You can create your own user interface / systems.\n</Note>\n\n## How everything connects\n\nThe Moderation Module integrates seamlessly with your project, ensuring a consistent approach to managing player behavior. By utilizing the provided methods, you can automate and customize moderation tasks to create a fair and enjoyable experience for all users.\n\nThe `Punishment` Object:\r\nThe Punishment object is central to the Moderation Module and contains the following fields:\n\n* **Identifier:** Unique ID for the punishment.\n* **Player Identifier:** UUID of the punished player.\n* **Moderator Identifier:** UUID of the moderator who applied the punishment.\n* **Start Timestamp:** When the punishment started.\n* **Applicable Projects:** Set of projects where the punishment applies.\n* **[Reason](#reasons):** Pre-defined reason for the punishment.\n* **Notes:** Additional information about the punishment.\n* **Removal Information:** Details about the removal of the punishment, if applicable.\n\nFor a full breakdown of the punishment object, see [the punishment object documentation](/docs/sdk/features/moderation/model)\n\n### Reasons\n\nInstead of allowing arbitrary text, the module uses a pre-defined list of reasons for consistency and clarity.\n\nThe `PunishmentReason` object includes:\n\n* **Punishment type:** Specifies the type of punishment (e.g., mute, ban).\n* **Display reason:** User-friendly explanation of the reason.\n* **Priority:** Importance level of the reason (important if they have multiple at once).\n* **Identifier:** Unique ID for the reason.\n* **Duration:** Length of time the punishment lasts.\n\nFor a full breakdown of the reasons and some defaults we've added for you, check out [the punishment reason documentation](/docs/sdk/features/moderation/reasons)\n\n## Method overview\n\nBelow is an overview of the key methods available in the Moderation Module:\n\n### listActivePunishments\n\n```java\n@NonNull CompletableFuture<@NonNull List<@NonNull Punishment>> listActivePunishments(\r\n            @NonNull UUID playerUUID, boolean includeGlobal);\n```\n\nRetrieves a list of active punishments for a specific player. You can include global punishments by setting includeGlobal to true.\n\n#### Example Usage:\n\n```java\nfinal UUID playerUUID = UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\");\r\nmoderationModule.listActivePunishments(playerUUID, true).thenAccept(punishments -> {\r\n    punishments.forEach(punishment -> {\r\n        System.out.println(\"Active Punishment: \" + punishment);\r\n    });\r\n});\n```\n\n### listAllPunishments\n\n```java\n@NonNull CompletableFuture<@NonNull List<@NonNull Punishment>> listAllPunishments(@NonNull UUID playerUUID, boolean includeGlobal);\n```\n\nRetrieves a complete list of punishments for a player, both active and inactive. Use includeGlobal to fetch global punishments.\n\n### applyPunishment\n\n```java\n@NonNull CompletableFuture<Punishment> applyPunishment(@NonNull Punishment punishment);\n```\n\nApplies a new punishment to a player. Returns the created punishment object.\n\n#### Example Usage:\n\n```java\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(BuiltInReason.HACKING_ESCALATION)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\r\n\r\nmoderationModule.applyPunishment(punishment).thenAccept(appliedPunishment -> {\r\n    System.out.println(\"Punishment applied: \" + appliedPunishment);\r\n});\n```\n\n### updatePunishment\n\n```java\n@NonNull CompletableFuture<Punishment> updatePunishment(@NonNull Punishment punishment);\n```\n\nUpdates an existing punishment with new information, such as adding notes or updating the removal information.\n\n### isMuted\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> isMuted(@NonNull UUID playerUUID);\n```\n\nChecks if a player is currently muted.\n\n#### Example Usage:\n\n```java\nmoderationModule.isMuted(playerUUID).thenAccept(isMuted -> {\r\n    if (isMuted) {\r\n        System.out.println(\"Player is muted.\");\r\n    } else {\r\n        System.out.println(\"Player is not muted.\");\r\n    }\r\n});\n```\n\n### isBanned\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> isBanned(@NonNull UUID playerUUID);\n```\n\nChecks if a player is currently banned.\n\n### hasActivePunishment\n\n```java\n@NonNull CompletableFuture<@NonNull Boolean> hasActivePunishment(@NonNull UUID playerUUID);\n```\n\nDetermines whether a player has any active punishment.\n\n### disableDefaultPunishmentCommand\n\n```java\nvoid disableDefaultPunishmentCommand();\n```\n\nDisables the default punishment command, allowing you to implement custom commands tailored to your project. See more information in the [punishment command guide](/docs/sdk/features/moderation/command)\n\n## Examples\n\n### Applying a Temporary Ban\n\n```java\nfinal PunishmentReasonImpl banReason = PunishmentReasonImpl.builder()\r\n    .type(PunishmentType.TEMP_BAN)\r\n    .displayReason(\"Excessive Toxicity\")\r\n    .priority(1)\r\n    .reasonIdentifier(\"toxicity\")\r\n    .duration(Duration.ofSeconds(3600 * 24));\r\n\r\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(banReason)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\r\n\r\nmoderationModule.applyPunishment(punishment).thenAccept(appliedPunishment -> {\r\n    System.out.println(\"Ban applied: \" + appliedPunishment);\r\n});\n```\n\n### Checking and Removing a Punishment\n\n```java\nfinal ModerationModule moderationModule = MineplexModuleManager.getRegisteredModule(ModerationModule.class);\r\nmoderationModule.listActivePunishments(playerUUID, false).thenAccept(punishments -> {\r\n    if (!punishments.isEmpty()) {\r\n        Punishment punishment = punishments.get(0);\r\n\r\n        final PunishmentRemovalImpl removalInformation = PunishmentRemovalImpl.builder()\r\n            .removeFromHistory(false)\r\n            .removalReason(\"Forgiven\")\r\n            .removalTimestamp(Instant.now())\r\n            .removalModerator(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n\r\n        punishment.setRemovalInformation(removalInformation);\r\n        moderationModule.updatePunishment(punishment).thenAccept(updated -> {\r\n            System.out.println(\"Punishment updated: \" + updated);\r\n        });\r\n    } else {\r\n        System.out.println(\"No active punishments found.\");\r\n    }\r\n});\n```\n"
  },
  {
    "slug": "/sdk/features/moderation/model",
    "title": "Punishment Object",
    "description": "Punishment object and how to use it",
    "content": "<JavadocLink artifactId=\"bom-public\" groupId=\"com.mineplex.studio\" classpath=\"com.mineplex.studio.dataplane.common.punishment.model.Punishment\" />\n\nThe Punishment interface defines the structure and behavior of a punishment entity. It includes methods to access punishment details, check conditions, and compute properties such as its remaining duration or global applicability.\n\n## Default Implementation: PunishmentImpl\n\nThe `PunishmentImpl` class provides a concrete implementation of the Punishment interface. It represents a punishment applied to an offline player and includes details about the player, moderator, reason, and scope of the punishment.\n\n### Key Features\n\n* Builder Pattern: Uses Lombok's @Builder annotation for convenient instantiation.\n* Immutable Data: Defined with Lombok's @Value for immutabilsity.\n* Default Values: Provides default values for fields like startTimestamp, removalInformation, and notes.\n\n### Fields\n\n* playerId (UUID): The UUID of the punished player.\n* moderatorId (UUID): The UUID of the moderator who issued the punishment.\n* startTimestamp (Instant): The timestamp when the punishment was applied (default: current time).\n* applicableProjects (`Set<String>`): The set of projects the punishment applies to.\n* punishmentReason (PunishmentReason): The reason for the punishment.\n* removalInformation (PunishmentRemoval): Information about the removal of the punishment (default: null).\n* identifier (UUID): The unique identifier of the punishment (default: null).\n* notes (String): Additional notes or comments about the punishment (default: null).\n\n### Usage Example:\n\n```java\nfinal PunishmentImpl punishment = PunishmentImpl.builder()\r\n    .playerId(UUID.fromString(\"123e4567-e89b-12d3-a456-426614174000\"))\r\n    .moderatorId(UUID.fromString(\"223e4567-e89b-12d3-a456-426614174000\"))\r\n    .startTimestamp(Instant.now())\r\n    .applicableProjects(Set.of(Objects.requireNonNull(System.getenv(\"MINEPLEX_PROJECT_ID\"))))\r\n    .punishmentReason(BuiltInReason.HACKING_ESCALATION)\r\n    .notes(\"https://evidence.com\")\r\n    .build();\n```\n\n## Method Overview\n\n### Identification Methods\n\n#### `hasIdentifier()`\n\n* Checks if the punishment has a unique identifier.\n* Returns: `true` if the identifier exists, otherwise `false`.\n\n#### `getIdentifier()`\n\n* Retrieves the unique identifier for the punishment.\n* Returns: `Optional<UUID>` containing the identifier if available.\n\n### Player and Moderator Information\n\n#### `getPlayerId()`\n\n* Retrieves the UUID of the punished player.\n* Returns: UUID of the player.\n\n#### `hasModeratorId()`\n\n* Checks if the punishment has a moderator ID.\n* Returns: true if a moderator ID exists, otherwise false.\n\n#### `getModeratorId()`\n\n* Retrieves the UUID of the moderator who issued the punishment.\n* Returns: `Optional<UUID>` containing the moderator ID if available.\n\n### Timing Information\n\n#### `getStartTimestamp()`\n\n* Retrieves the timestamp when the punishment was issued or should begin.\n* Returns: Instant representing the start time.\n\n#### `getRemainingDuration()`\n\n* Computes the remaining duration of the punishment.\n* Returns: Duration of the remaining time.\n\n<Note title=\"Important Note\" type=\"danger\">\n  If a punishment is permanent, you will receive `Duration.ZERO` in return from this method\n</Note>\n\n### Applicability and Scope\n\n#### `getApplicableProjects()`\n\n* Retrieves the set of project IDs where the punishment applies.\n* Returns: `Set<String>` containing applicable project IDs.\n\n#### `appliesTo(String projectIdentifier)`\n\nChecks if the punishment applies to a specific project.\n\n**Parameters:**\n\n* projectIdentifier: The project ID to check.\n\n* Returns: true if applicable, otherwise false.\n\n#### `isGlobal()`\n\n* Determines if the punishment is global (applicable to all projects).\n* Returns: true if global, otherwise false.\n\n### Punishment Reason\n\n#### `getPunishmentReason()`\n\n* Retrieves the reason for the punishment.\n* Returns: PunishmentReason containing the reason details.\n\n### Notes and Additional Information\n\n#### `hasNotes()`\n\n* Checks if the punishment has associated notes.\n* Returns: true if notes exist, otherwise false.\n\n#### `getNotes()`\n\n* Retrieves notes or comments about the punishment.\n* Returns: `Optional<String>` containing the notes if available.\n\n### Removal Information\n\n#### `hasRemovalInformation()`\n\n* Checks if the punishment has been removed.\n* Returns: true if removal information exists, otherwise false.\n\n#### `getRemovalInformation()`\n\n* Retrieves removal details if the punishment has been removed.\n* Returns: `Optional<PunishmentRemoval>` containing the removal information.\n\n#### `isRemoved()`\n\n* Checks if the punishment has been removed.\n* Returns: true if removed, otherwise false.\n"
  },
  {
    "slug": "/sdk/features/moderation/reasons",
    "title": "Punishment Reasons",
    "description": "Details about how the punishment reason system works",
    "content": "<JavadocLink artifactId=\"bom-public\" groupId=\"com.mineplex.studio\" classpath=\"com.mineplex.studio.dataplane.common.punishment.model.PunishmentReason\" />\n\nThe Punishment Reasons System is designed to provide a comprehensive framework for moderating projects efficiently. It includes built-in reasons to address common violations and enables consistent handling of infractions without requiring additional development work.\n\n## Built-In Reasons\n\nThe following reasons are pre-configured as part of the system. Each reason is associated with a specific type of punishment, a description, severity level, unique identifier, and duration.\n\nThe built-in reasons are located in the following class: `com.mineplex.studio.sdk.modules.moderation.BuiltInReason`\n\n### List of Built-In Reasons\n\n#### 1. Teaming\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Teaming with other users\n* Severity Level: 1\n* Identifier: teaming\n* Duration: 24 hours\n\n#### 2. Exploiting\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Exploiting game mechanics\n* Severity Level: 2\n* Identifier: exploiting\n* Duration: 48 hours\n\n#### 3. Griefing\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Griefing or destroying others' builds\n* Severity Level: 2\n* Identifier: griefing\n* Duration: 7 days\n\n#### 4. Unauthorized Use\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Using unauthorized tools or scripts\n* Severity Level: 2\n* Identifier: unauthorized\\_use\n* Duration: 48 hours\n\n#### 5. Team Killing\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Killing teammates or sabotaging team efforts\n* Severity Level: 2\n* Identifier: team\\_killing\n* Duration: 24 hours\n\n#### 6. Exploitation\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Exploiting bugs or glitches\n* Severity Level: 2\n* Identifier: exploitation\n* Duration: 48 hours\n\n#### 7. AFK Grinding\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Using automated systems for AFK grinding\n* Severity Level: 2\n* Identifier: afk\\_grinding\n* Duration: 7 days\n\n#### 8. Chat Escalation\n\n* Punishment Type: Temporary Mute (TEMP\\_MUTE)\n* Description: Escalation to Mineplex staff\n* Severity Level: 1\n* Identifier: chat\\_escalation\n* Duration: 7 days\n\n#### 9. Hacking Escalation\n\n* Punishment Type: Temporary Ban (TEMP\\_BAN)\n* Description: Escalation to Mineplex staff\n* Severity Level: 1\n* Identifier: hacking\\_escalation\n* Duration: 7 days\n\n## Creating Custom Reasons\n\nThis guide provides two approaches to creating custom reasons for punishments: using the `PunishmentReasonImpl` builder or creating an enum that extends `PunishmentReason`.\n\n### Which Option to Choose?\n\n* Option 1: Use if you need to dynamically create reasons at runtime.\n* Option 2: Use if you have a fixed set of reasons and want to avoid duplication.\n\n### Option 1: Creating instance of PunishmentReasonImpl\n\nTo create a custom punishment reason with `PunishmentReasonImpl`, use its builder pattern. This allows you to define specific details such as type, display reason, priority, identifier, and duration.\n\n```java\nfinal PunishmentReasonImpl banReason = PunishmentReasonImpl.builder()\r\n    .type(PunishmentType.TEMP_BAN)\r\n    .displayReason(\"Excessive Toxicity\")\r\n    .priority(1)\r\n    .reasonIdentifier(\"toxicity\")\r\n    .duration(Duration.ofSeconds(3600 * 24));\n```\n\n### Option 2: Enum that extends PunishmentReason\n\nFor a more structured approach, define an enum that implements the PunishmentReason interface. This is useful when you need a predefined, reusable set of custom reasons.\n\n```java\n@RequiredArgsConstructor\r\n@Getter\r\npublic enum CustomReason implements PunishmentReason {\r\n    MY_REASON(PunishmentType.TEMP_BAN, \"My custom reason\", 1, \"custom_reason\", Duration.ofHours(24));\r\n\r\n    /**\r\n     * The {@link PunishmentType} associated with this reason.\r\n     */\r\n    private final @NonNull PunishmentType type;\r\n\r\n    /**\r\n     * A user-friendly display string for this reason.\r\n     */\r\n    private final @NonNull String displayReason;\r\n\r\n    /**\r\n     * The priority level of this reason, which may be used to determine the severity or importance.\r\n     */\r\n    private final int priority;\r\n\r\n    /**\r\n     * A unique identifier for this reason (unique within your namespace).\r\n     */\r\n    private final @NonNull String reasonIdentifier;\r\n\r\n    /**\r\n     * The duration for which the punishment should last.\r\n     * A duration of {@link Duration#ZERO} indicates a permanent punishment.\r\n     */\r\n    private final @NonNull Duration duration;\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/moderation/types",
    "title": "Punishment Types",
    "description": "Information about the types of punishments",
    "content": "<JavadocLink artifactId=\"bom-public\" groupId=\"com.mineplex.studio\" classpath=\"com.mineplex.studio.dataplane.common.punishment.model.PunishmentType\" />\n\n## Punishment Types\n\nWe currently support a handful of punishment types, these represent the type of punishment associated with a specific punishment reason.\n\n### TEMP\\_MUTE\n\nA temporary mute punishment. Users will be temporarily muted, and this punishment will expire after a set duration.\n\n### TEMP\\_BAN\n\nA temporary ban punishment. Users will be temporarily banned, and this punishment will expire after a set duration.\n\n### MUTE\n\nA mute punishment. Users will be muted indefinitely until the punishment is lifted. This type is permanent.\n\n### BAN\n\nA ban punishment. Users will be banned indefinitely until the punishment is lifted. This type is permanent.\n\n### WARNING\n\nA warning punishment. Used to inform a user that what they are doing is wrong.\n"
  },
  {
    "slug": "/sdk/features/party",
    "title": "Party Module",
    "description": "How to use the Mineplex Studio Party Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.party.PartyModule\" />\n\nThe Party Module is one of the built-in Studio Modules that allows you to query whether players in your game are in a party, and determine who is in the party with them. These methods are solely for you to integrate our parties into your games. All party functionality is handled internally by the SDK and requires no further implementation on your end.\n\n## Retrieving a Party\n\nDepending on the circumstances, a player's party data may have not been loaded yet. You can use either `isLoaded(OfflinePlayer)` or `isLoaded(UUID)` to check if their party data has been loaded.\n\nFetching a party can be done using its ID via `getPartyById(String)` or by a given player using `getPartyOfPlayer(Player)`.\n\n```java\nfinal PartyModule partyModule = MineplexModuleManager.getRegisteredModule(PartyModule.class);\r\nif (partyModule.isLoaded(player)) {\r\n    // Safe to check if they have a party.\r\n    final Optional<Party> party = partyModule.getPartyOfPlayer(player);\r\n}\n```\n\n## Retrieving Party Details\n\nOnce you've retrieved a party, you can access its ID, its leader, and all players in the party.\n\n### Party ID\n\nAll parties have a unique ID assigned that can be retrieved via `getId()`.\n\n```java\nfinal String partyId = party.getId();\n```\n\n### Party Members\n\n<Note type=\"warning\">\n  There is no guarantee that players in the party will be online in the running instance.\n</Note>\n\n#### Retrieving Party Leader\n\nGiven a party, you can call `getOwner()` to return a `OfflinePlayer` of the owner of the party.\n\n```java\nfinal OfflinePlayer partyLeader = party.getOwner();\r\nif (partyLeader.isOnline()) {\r\n    Bukkit.broadcast(Component.text(\"Party leader is in-game!\"));\r\n} else {\r\n    Bukkit.broadcast(Component.text(\"Party leader is not in this game!\"));\r\n}\n```\n\n#### Retrieving Party Members\n\nParty members can be retrieved from a party by calling `listMembers(boolean)` with the argument being whether to include the party owner in the returned collection of `OfflinePlayer` objects.\n\n```java\nfinal OfflinePlayer partyOwner = party.getOwner();\r\n\r\n// We specified false, meaning that this will NOT include the party leader.\r\nfor (final OfflinePlayer offlinePlayer : party.listMembers(false)) {\r\n    if (offlinePlayer.isOnline()) {\r\n        final Player player = (Player) offlinePlayer;\r\n        player.sendMessage(Component.text(\"You are a party member of \" + partyOwner.getName() + \"!\"));\r\n    }\r\n}\n```\n\n#### Checking Party Members\n\nYou can also verify that a player is a member of a party via `hasMember(OfflinePlayer)` or `hasMember(UUID)`, where the UUID is the UUID of the player you are checking.\n\n```java\nfinal boolean isPartyMember = party.hasMember(player);\r\nif (isPartyMember) {\r\n    player.sendMessage(Component.text(\"You are a member of this party!\"));\r\n}\n```\n\n## Example\n\nLet's say we are making an open-world game where players can use the party system to team up. We don't want to allow players in the same party to hurt one another, so we integrate with the party module.\n\n```java\npublic boolean canDamage(final Player damager, final Player victim) {\r\n    final Optional<Party> damagerParty = partyModule.getPartyOfPlayer(damager);\r\n\r\n    // If the attacker's party has the victim, we cannot attack them.\r\n    final boolean damagerPartyContainsVictim = damagerParty.map(party -> party.hasMember(victim)).orElse(false);\r\n    return !damagerPartyContainsVictim;\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/player-ignore",
    "title": "Player Ignore Module",
    "description": "How to use the Mineplex Studio Player Ignore Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.ignore.PlayerIgnoreModule\" />\n\nThe Player Ignore Module is one of the built-in Studio Modules that allows you to check which players are ignoring each other.\r\nThis can be useful for creating custom chat filters, or for creating custom moderation tools.\n\n## Module Retrieval\n\nYou can retrieve the module by using the `MineplexModuleManager` via\n\n```java\nimport com.mineplex.studio.sdk.modules.MineplexModuleManager;\r\nPlayerIgnoreModule ignoreModule = MineplexModuleManager.getRegisteredModule(PlayerIgnoreModule.class);\n```\n\n## Checking if a Player is Ignoring Another\n\nYou can check if a player is ignoring another player by using the `isIgnoring(OfflinePlayer, OfflinePlayer)` or `isIgnoring(UUID, UUID)` method.\r\nIn this example we are checking if `player` is ignoring `toCheck`. This will also return `true` if the data for `player` is not loaded.\r\nYou can use `isLoaded(OfflinePlayer)` and `isLoaded(UUUID)` to check if the data is loaded.\n\n```java\npublic boolean isIgnoring(Player player, Player toCheck) {\r\n    return ignoreModule.isIgnoring(player, target);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/purchase",
    "title": "Purchase Module",
    "description": "How to use the Mineplex Studio Purchase Module",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.purchase.PurchaseModule\" />\n\nThe purchases module allows game developers on the Mineplex Studio to monetize their work by creating digital products available for single and repeatable sale formats as well as digital subscriptions that support reccurring payments.\n\n## High Level Purchase Flow\n\nPurchases within the Mineplex Studio are based on our in-game digital currency, called Crowns. Players use their local currency (such as US Dollars or Euros) to purchase Crowns from our website or in-game flows, and can then redeem these crowns for products and subscriptions listed by developers like you. At the end of the month, we pay out a profit-share based on the crowns spent within a given game mode to the developers.\n\n## Purchase Acknowledgements and Technical Flow\n\nThe purchase flow works as follows:\n\n<Step>\n  <StepItem title=\"Player Prompts Purchase\">\n    A player takes an in-game action that triggers the `promptPurchase` method in the Mineplex Purchases SDK module\n  </StepItem>\n\n  <StepItem title=\"Crowns Debited\">\n    The Mineplex payments service attempts to debit the player Crown balance\n  </StepItem>\n\n  <StepItem title=\"Event Received\">\n    An event is sent back to your game code based on the `callbackDelivery` mode defined in the purchaseable defintion file (see below). Events will only be delivered to one server at a time (your code generally does not need to handle event delivery atomically or in a concurrency-safe mode)\n  </StepItem>\n\n  <StepItem title=\"You Reward Player\">\n    If the purchase was successful, your code must grant the player the entitlement (such as an item or XP boost) and acknowledge the flow completion with the Mineplex payments service. You should acknowledge purchase events immediately after granting entitlements to avoid duplicate delivery\n  </StepItem>\n</Step>\n\n<Note type=\"note\">\n  * Events that are not acknowledged will be retried several times after a brief delay (currently up to three times with five-second delays, subject to change)\n  * Events that are not acknowledged within a sufficient time period or after the maximum retry count will be cancelled, and the crown transaction will be automatically refunded\n</Note>\n\n## Creating and Maintaining Products\n\nTo initiate the payment creation process, you can construct YAML files containing your product parameters, each including the following mandatory details. All parameters must be completed and must not be left empty or assigned a null value. Place these YAML files into the `config/purchases/` repository directory, with any file name. We uniquely identify your purchases within the project namespace based on the `productId` that you provide (so you should avoid changing this value).\n\n**productId** *String* - An unique product identifier assigned by the creator. This identifier is utilized for retrieving and deleting your product object after its creation.\n\n**productName** *String* - The name of the product being offered for sale. This is the primary name that users will see when looking to purchase a product.\n\n**productDescription** *String* - A description of the product being offered. This description is available to customers when reviewing the product offering prior to purchasing.\n\n**price** *Long* - The price of the digital asset for sale. This value is represented by Mineplex's digital currency: Crowns.\n\n**callbackDelivery** *enum* - Defines the parameters for the delivery of the product to the purchasers' player account. The available inputs are: `ONLY_WHEN_PLAYER_ONLINE` and `ALLOW_OFFLINE_DELIVERY`.\n\n**Product File Definition Structure**\n\n```yaml\nproductId: \"power-up-1\"\r\nproductName: \"Power Up\"\r\nproductDescription: \"This power up allows you to be more powerful!\"\r\nprice: 100\r\ncallbackDelivery: \"ONLY_WHEN_PLAYER_ONLINE\"\r\nrepeatablePurchase: false\n```\n\n## Creating and Maintaining Subscriptions\n\nThe subscription creation process is very similar to that of single sale digital products. You can construct YAML files containing your product parameters, each including the following mandatory details. All parameters must be completed and must not be left empty or assigned a null value. Place these YAML files into the `config/subscriptions/` repository directory, with any file name. We uniquely identify your subscriptions within the project namespace based on the `subscriptionId` that you provide (so you should avoid changing this value).\n\n**subscriptionId** *String* - An unique subscription identifier assigned by the creator. This identifier is utilized for retrieving and deleting your subscription object after its creation.\n\n**subscriptionName** *String* - The name of the subscription being offered for sale. This is the primary name that users will see when looking to subscribe to a subscription.\n\n**subscriptionDescription** *String* - A layout of the offerings of the subscription. This description is available to customers when reviewing the subscription offering prior to purchasing.\n\n**price** *Long* - The reoccurring price of the subscription. This value is represented by Mineplex's digital currency: Crowns.\n\n**subscriptionBasis** *enum* - This defines the reoccurring billing cycle of the subscription. The available inputs are: 'MONTHLY' | 'QUARTERLY' | 'SEMI\\_YEARLY' | YEARLY'\n\n**callbackDelivery** *enum* - Defines the parameters for the delivery of the product to the purchasers' player account. The available inputs are: `ONLY_WHEN_PLAYER_ONLINE` and `ALLOW_OFFLINE_DELIVERY`.\n\n**Subscription File Definition Structure**\n\n```yaml\nsubscriptionId: \"power-up-subscription-1\"\r\nsubscriptionName: \"Monthly Power-Up\"\r\nsubscriptionDescription: \"Get a bonus power-up every month by purchasing this subscription!\"\r\nprice: 100\r\nsubscriptionBasis: \"MONTHLY\"\r\ncallbackDelivery: \"ONLY_WHEN_PLAYER_ONLINE\"\n```\n\n## Discounts and Promotions\n\nDeveloper-defined discounts and promotions are not yet supported, but are coming soon! If you have a special requirement to offer limited-time pricing, please contact us.\n\n## Restrictions for Updating and Deleting Purchaseables\n\nTo avoid accidental deletion, the Mineplex GitHub Action that publishes your project will never delete old subscriptions or products, even if you remove their respective definition files. If you wish to delete a product or subscription, you must do so manually from the Studio Web Console.\n\nTo ensure a player-friendly experience, we also enforce certain restrictions.\n\nFor product listing updates, you cannot currently change:\n\n* The repeatable purchase status\n\nFor subscription listing updates, you cannot currently change:\n\n* A subscription's basis, or duration\n* The price of a subscription\n\n## Listening for Purchases\n\nDevelopers must listen to bukkit events emitted by the internal purchase module.\r\nThere are four types of purchase events that you can listen for inside your plugin.\n\n`AsyncProductPurchaseSuccessEvent** *<Product PendingTransaction<Product>>`\n\n* Fires when a product purchase is successful. Developers must grant the product and acknowledge the pending transaction.\n\n`AsyncProductPurchaseFailureEvent** *<Product FailedTransaction<Product>>`\n\n* Fires when a product purchase fails.\n\n`AsyncSubscriptionRenewalSuccessEvent** *<Subscription, PendingTransaction<Subscription>>`\n\n* Fires when a subscription purchase is successful. Developers must grant the subscription and acknowledge the pending transaction.\n\n`AsyncSubscriptionRenewalFailureEvent** *<Subscription, FailedTransaction<Subscription>>`\n\n* Fires when a subscription fails to renew. When a subscription fails to renew, developers must be sure to revoke the perks previously granted by this subscription.\n\nAlthough, developers have the choice of acknowledging incoming purchases.\r\nIt is recommended to acknowledge and grant any purchases as soon as possible.\r\nIf a purchase is not acknowledged, there will be a few delayed attempts before refunding the purchase.\n\nLet's use the example product above and create a listener that can give a player the power-up in game.\n\n### Example\n\n<Step>\n  <StepItem title=\"Purchase Event Listener\">\n    ```java\n    public class PurchaseEventListener implements Listener {\r\n\r\n        private static final I18nText GRANT_POWERUP = new I18nText(\"MyPlugin\", \"PURCHASE_GRANT_POWERUP\", \"<gold>You received a power up!</gold>\");\r\n        private static final I18nText PURCHASE_FAIL = new I18nText(\"MyPlugin\", \"PURCHASE_FAIL\", \"<red>Purchase of <product> failed! <reason></red>\");\r\n\r\n        @EventHandler\r\n        public void onProductPurchaseSuccess(final AsyncProductPurchaseSuccessEvent event) {\r\n            // Get the transaction and product.\r\n            final PendingTransaction<Product> transaction = event.getTransaction();\r\n            final Product product = event.getPurchasable();\r\n\r\n            final OfflinePlayer offlinePlayer = event.getPlayer();\r\n            final Player onlinePlayer = offlinePlayer.getPlayer();\r\n\r\n            // Verify this is the correct product by productId\r\n            if (product.getId().equals(\"power-up-1\")) {\r\n\r\n                // Verify that the player is online.\r\n                if (onlinePlayer == null) {\r\n                    return;\r\n                }\r\n\r\n                // Effect we want to grant to the player.\r\n                final PotionEffect potionEffect = new PotionEffect(PotionEffectType.ABSORPTION, (int) MinecraftTimeUnit.MINUTES.toTicks(2), 4);\r\n\r\n                // Grant the purchase. Make sure grant is thread-safe.\r\n                TaskUtil.onMainThread(() -> onlinePlayer.addPotionEffect(potionEffect)).run();\r\n\r\n                // Get message in the correct language and message the player.\r\n                final Component translatedMessage = MiniMessage.miniMessage().deserialize(GRANT_POWERUP.getText(onlinePlayer.locale()));\r\n                onlinePlayer.sendMessage(translatedMessage);\r\n\r\n                // Acknowledge the purchase after it has been granted and handle reversal in the event the acknowledgment fails.\r\n                transaction.acknowledge().exceptionally(ex -> {\r\n                    // Make sure reversal is thread-safe.\r\n                    TaskUtil.onMainThread(() -> onlinePlayer.removePotionEffect(potionEffect.getType())).run();\r\n                    return null;\r\n                });\r\n            }\r\n        }\r\n\r\n        @EventHandler\r\n        public void onProductPurchaseFail(final AsyncProductPurchaseFailureEvent event) {\r\n            // Get the transaction and product.\r\n            final FailedTransaction<Product> transaction = event.getTransaction();\r\n            final Product product = transaction.getPurchasable();\r\n\r\n            final OfflinePlayer offlinePlayer = event.getPlayer();\r\n            final Player onlinePlayer = offlinePlayer.getPlayer();\r\n\r\n            // Verify that the player is online.\r\n            if (onlinePlayer == null) {\r\n                return;\r\n            }\r\n\r\n            // Get message in the correct language, fill in the placeholders, and message the player.\r\n            final Component translatedMessage = MiniMessage.miniMessage().deserialize(\r\n                    PURCHASE_FAIL.getText(onlinePlayer.locale()),\r\n                    Placeholder.unparsed(\"product\", product.getName()),\r\n                    Placeholder.unparsed(\"reason\", transaction.getFailureReason().orElse(\"\"))\r\n            );\r\n\r\n            onlinePlayer.sendMessage(translatedMessage);\r\n        }\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Register the Listener\">\n    ```java\n    Bukkit.getPluginManager().registerEvents(new PurchaseEventListener(), plugin);\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/sdk/features/quest",
    "title": "Quest Module",
    "description": "How to setup and add progress to quests",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.quest.QuestModule\" />\n\n## Configuring Quests\n\n<Note title=\"Required Implementation\">\n  We expect you to setup quests on your game(s) within 90 days of publishing.\n</Note>\n\nThe first step to setting up quests is to define them within your project.\n\nAdd your quest definitions into your configuration folder, under the quests subfolder, as shown:\n\n<FileTree>\n  <Folder name=\"config\" label=\"config\">\n    <Folder name=\"quests\" label=\"quests\">\n      <File name=\"first-adventure.yaml\" label=\"first-adventure.yaml\" />\n    </Folder>\n  </Folder>\n</FileTree>\n\nQuest definitions should be formatted as follows:\n\n```yaml\n# A name displayed to players when picking up the quest\r\ndisplayName: \"First Adventure\"\r\n\r\n# The objective required to be completed, with a sufficient description\r\nobjectiveDescription:\r\n- \"Head into the Great Mines and\"\r\n- \"Defeat 10 Blaze Monsters\"\r\n\r\n# Any (optional) rewards you'd like to give as extra incentives\r\nstudioRewards:\r\n- \"100 Bonus Coins\"\r\n\r\n# How difficult your quest is (EASY/MEDIUM/HARD)\r\ndifficulty: \"EASY\"\r\n\r\n# How much time people have to complete your quest (DAILY/WEEKLY)\r\nfrequency: \"DAILY\"\n```\n\n## Awarding progress\n\nOnce players pick up a quest, they'll want to pop in your game to complete it. This part shows how you can progress a player's quest.\r\nWe call an instance of a picked-up quest a \"Quest Ticket\", as they're trying to complete a picked up ticket (like a bingo ticket).\n\n<Step>\n  <StepItem title=\"Player completes an action\">\n    Let's say your quest is to kill blazes (like our example configured quest \"First Adventure\")\n\n    Well, we'll need to listen for the EntityDeathEvent to be informed when this happens!\n\n    ```java\n    @EventHandler\r\n    public void playerKillBlaze(final EntityDeathEvent event) {\r\n        // if killed naturally - ignore\r\n        if(event.getDamageSource().getCausingEntity() == null) return; \r\n        // if the killed entity is not a blaze - ignore\r\n        if(!(event.getEntity() instanceof Blaze)) return;\r\n        // check kill is a player & store the player as a variable\r\n        if(!(event.getDamageSource().getCausingEntity() instanceof Player player)) return;\r\n\r\n        // todo - next step!\r\n    }\n    ```\n  </StepItem>\n\n  <StepItem title=\"Add progress to the quest\">\n    Next, we'll always award progress to the player when completing an action in any given quest - as the `addProgressIfAssigned` method checks they're assigned before trying to award. This saves us checking the player is assigned before hitting the method.\n\n    ```java\n    // get the quest module from the module manager\r\n    final QuestModule questModule = MineplexModuleManager.getRegisteredModule(QuestModule.class);\r\n\r\n    // award the quest using the quest's file name (removing the file type suffix) as a quest key.\r\n    // you can use addProgressIfAssigned(player, \"first-adventure\", 2) to award more than 1.\r\n    questModule.addProgressIfAssigned(player, \"first-adventure\");\n    ```\n  </StepItem>\n\n  <StepItem title=\"Dish out your defined rewards\">\n    Well, would you look at that, the player has killed our 10 blazes! Once a player completes a quest, `MineplexQuestCompleteEvent` is thrown using the Paper event channel! We should handle this event by giving rewards to the player.\n\n    This is only needed if you've added `studioRewards` to your quest's configuration!\n\n    ```java\n    @EventHandler\r\n    public void blazeQuestCompleted(final MineplexQuestCompleteEvent event) {\r\n        // check the event has the key we're expecting\r\n        if(!event.getQuestKey().equals(\"first-adventure\")) return;\r\n\r\n        // get the player completing the quest\r\n        final Player player = event.getPlayer();\r\n\r\n        // give them rewards using your systems\r\n        addCoins(player, 100);\r\n    }\n    ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/sdk/features/queueing",
    "title": "Queue Module",
    "description": "How to use the Mineplex Studio Queue Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.queuing.QueuingModule\" />\n\nThe Queue Module is a key Mineplex Studio component that allows you to manage queues for players to join games. This module supports both dynamic and static game allocations and provides various methods to control queueing behavior. With it, you can build a centralized hub, facilitating player flow across different games in your setup. However, queuing a player does not guarantee immediate transfer, as this depends on the matchmaking status of the target game.\n\n## Queuing Methods\n\nThe following methods can be used to manage player queues in your games:\n\n### 1. `enqueuePlayer(Player player, String gameId)`\n\nQueues a player for a dynamically allocated game. This method is useful for games that are created on-demand.\n\n* **Parameters**:\n  * `player`: The player to queue.\n  * `gameId`: The identifier of the game or game tag.\n* **Returns**: A `CompletableFuture<Void>` that completes when the player is enqueued.\n\n#### Example\n\n```java\npublic void queueForGame(Player player, String gameId) {\r\n    queuingModule.enqueuePlayer(player, gameId).thenAccept(unused -> {\r\n        player.sendMessage(\"You have been queued for \" + gameId);\r\n    }).exceptionally(error -> {\r\n        player.sendMessage(\"Queue failed: \" + error.getMessage());\r\n        return null;\r\n    });\r\n}\n```\n\n### 2. `enqueuePlayer(Player player, String gameId, String commonName)`\n\nQueues a player for a statically allocated game, based on a common name. This is useful for games that are permanently available.\n\n* **Parameters**:\n  * `player`: The player to queue.\n  * `gameId`: The identifier of the game.\n  * `commonName`: The common name associated with the server to move to.\n* **Returns**: A `CompletableFuture<Void>` that completes when the player is enqueued.\n\n#### Example\n\n```java\npublic void queueForStaticGame(Player player, String gameId, String commonName) {\r\n    queuingModule.enqueuePlayer(player, gameId, commonName).thenAccept(unused -> {\r\n        player.sendMessage(\"You have been queued for \" + commonName);\r\n    }).exceptionally(error -> {\r\n        player.sendMessage(\"Queue failed: \" + error.getMessage());\r\n        return null;\r\n    });\r\n}\n```\n\n### 3. `dequeuePlayer(Player player)`\n\nRemoves a player from the queue they are currently in.\n\n* **Parameters**:\n  * `player`: The player to remove from the current queue.\n* **Returns**: A `CompletableFuture<Void>` that completes when the player is dequeued.\n\n#### Example\n\n```java\npublic void leaveQueue(Player player) {\r\n    queuingModule.dequeuePlayer(player).thenAccept(unused -> {\r\n        player.sendMessage(\"You have been removed from the queue.\");\r\n    });\r\n}\n```\n\n### 4. `getPlayerQueueStatus(Player player)`\n\nRetrieves the queue status for a player.\n\n* **Parameters**:\n  * `player`: The player to check.\n* **Returns**: A `CompletableFuture<GetQueueStatusResponse>` containing the player's queue status.\n\n```java\npublic void checkQueueStatus(Player player) {\r\n    queuingModule.getPlayerQueueStatus(player).thenAccept(status -> {\r\n        player.sendMessage(\"Queue status: \" + status.getStatus());\r\n    });\r\n}\n```\n\n### 5. `returnLobby(Player player)`\n\nReturns a player to the main lobby, removing them from any queues or active games.\n\n* **Parameters**:\n  * `player`: The player to return to the lobby.\n\n```java\npublic void returnToLobby(Player player) {\r\n    queuingModule.returnLobby(player);\r\n    player.sendMessage(\"You have been returned to the lobby.\");\r\n}\n```\n\n### 6. `retainPlayer(Player player)`\n\nKeeps a player in their current queue, avoiding entry into specific game tags. This is useful when a player wants to continue playing your mode rather than playing the tag rotation.\n\n<Note type=\"warning\">\n  This will clear the player's joined tag (if any exists) and cause `joinedThroughTag` to return `false`.\n</Note>\n\n* **Parameters**:\n  * `player`: The player to retain.\n* **Returns**: A `CompletableFuture<Void>` that completes once the player is retained\n\n```java\npublic void keepPlayerInQueue(Player player) {\r\n    queuingModule.retainPlayer(player).thenAccept(unused -> {\r\n        player.sendMessage(\"You will stay in Micro Battles.\");\r\n    });\r\n}\n```\n\n### 7. `requeuePlayer(Player player)`\n\nRe-queues a player based on their previous queue choice, making it easy for them to play again without manual selection.\n\n* **Parameters**:\n  * `player`: The player to requeue.\n* **Returns**: A `CompletableFuture<Void>` that completes once the player is requeued.\n\n#### Example\n\n```java\npublic void requeuePlayer(Player player) {\r\n    queuingModule.requeuePlayer(player).thenAccept(unused -> {\r\n    player.sendMessage(\"You have been requeued.\");\r\n});\r\n}\n```\n\n### 8. `joinedThroughTag(Player player)`\n\nChecks if a player joined the current game mode via a tag. Useful for prompting people to re-queue for a tag instead of your own mode.\n\n* **Parameters**:\n  * `player`: The player to check.\n* **Returns**: `true` if the player joined through any tag, otherwise `false`.\n\n#### Example\n\n```java\npublic boolean didJoinThroughTag(Player player) {\r\n    return queuingModule.joinedThroughTag(player);\r\n}\n```\n\n### 9. `joinedThroughTag(Player player, String tag)`\n\nChecks if a player joined the current game mode using a specific tag, allowing you to trigger different behaviour (e.g. rewards to incentivise people to stick with your game).\n\n* **Parameters**:\n  * `player`: The player to check.\n  * `tag`: The tag to verify as the player's entry method.\n* **Returns**: `true` if the player joined through the specified tag, otherwise `false`.\n\n#### Example\n\n```java\npublic boolean didJoinThroughSpecificTag(Player player, String tag) {\r\n    return queuingModule.joinedThroughTag(player, tag);\r\n}\n```\n\n***\n\n## Queue Responses\n\nQueue operations may result in the following responses:\n\n* `SUCCESS` - Player successfully queued for the target game.\n* `FAIL_ALREADY_QUEUED` - Player is already queued for a game.\n* `FAIL_IN_PARTY` - Player cannot queue because they are in a party but not the leader.\n* `FAIL_OTHER` - Queue request failed for another reason.\n\n#### Example: Interactive Queue with NPC\n\nIn a custom hub, players can interact with NPCs to join a game queue.\n\n```java\npublic void interactWithNPC(Player player, GameNPC npc) {\r\n    if (queuingModule.getPlayerQueueStatus(player).isQueued()) {\r\n        queuingModule.dequeuePlayer(player);\r\n    } else {\r\n        queuingModule.enqueuePlayer(player, npc.getGameId());\r\n    }\r\n}\n```\n\n## Tag Queue\n\nThe following tags (or category) are currently supported for tag queueing: `Arcade`\n\n**Guidelines for all games in supported tag queues:**\n\n* Partners should prompt people to re-queue for the tag on death/elimination.\n* Not block the queue flow in any way (e.g. re-queueing for your game without affirimitive action from player)\n* Use the `requeue` method for re-queueing people rather than `enqueue`\n* Must support an option in hotbar to return to the lobby before game start, or when a spectator (clock or bed item).\n\n**If your game is tagged or has the `Arcade` category, it must also meet certain conditions:**\n\n* Must not kick to hub after game end (requeue instead), avoid closing server until players are empty (or server is killed), save stats/data on game end (before re-queue) to avoid race conditions.\n* Must have a hotbar item to re-queue for Arcade if joining via Arcade tag\n\nFailing to abide by a tag's guidelines will result in the tag being removed and the game being blocked from using the tag until approval is given.\n"
  },
  {
    "slug": "/sdk/features/resourcepack",
    "title": "Resource Pack SDK",
    "description": "How to use the Mineplex Studio Resource Pack SDK",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.resourcepack.ResourcePackModule\" />\n\nThe resource pack module allows game developers on the Mineplex Studio to retrieve uploaded resource pack and display those to players.\r\nAll resource packs must be stored in the `config/resource-packs` directory and are identified by their file name.\n\n## Uploading Resource Packs\n\nStore all your resource packs in the `config/resource-packs` directory, and they will be uploaded to the Mineplex Studio\r\nautomatically during the github build action or during the start of your development server.\n\n## Updating Resource Packs\n\nTo update a resource pack, simply replace the old version with the new version and re-run the github action or re-start the development server.\n\n## Retrieving Resource Packs\n\n```java\npublic ResourcePack getResourcePack(final String packName) {\r\n   resourcePackModule.get(packName);\r\n}\r\n\r\npublic ImmutableMap<String, ResourcePack> getResourcePacks() {\r\n   return resourcePackModule.getAll();\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/stats",
    "title": "Stats Module",
    "description": "How to use the Mineplex Studio Stats Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.stats.StatsModule\" />\n\nThe Stats Module is one of the built-in Studio Modules that allows you to quickly and easily store, update, and retrieve dynamic player stats in categories that are configurable on-the-fly at runtime. Let players celebrate their wins and hours spent in your game, without having to do any of the heavy lifting and data storage yourself.\n\n## CRUD\n\nThe CRUD methods provided in the Stats Module are as follows:\n\n* `getPlayerStats(player)` - Retrieves a `Map<String, Long>` of all stats the player has earned in this project namespace\n* `awardPlayerStats(player, Map<String, Long>)` - Increments the specific stats for the player by specified amounts, returning the resulting stat values after the increment\n* `setPlayerStats(player, Map<String, Long>` - Updates the specific stats for the player to the specified amounts\n* `deletePlayerStats(player, List<String>` - Deletes the specified stats from the player's record\n\nEach CRUD method can be called using either the player ID or the Player object itself. Additionally, each CRUD method has an asynchronous version for use when calling from the main thread.\n\n## Examples\n\n## Retrieving Player Stats\n\nLet's say we've devised a cool way to show players their stats in our game. Before we can start displaying them, we have to retrieve them!\n\n```java\npublic void displayStats(final Player player) {\r\n    statsModule.getPlayerStatsAsync(player).thenAccept(stats -> {\r\n        Bukkit.getScheduler().runTask(myProjectPlugin, () -> {\r\n            // Display stats!\r\n        });\r\n    });\r\n}\n```\n\n## Recording Stats\n\nIf we're going to display stats, we have to make sure we record them first!\n\n```java\npublic void recordWin(final Player player) {\r\n    // Increments player's \"Wins\" and \"WinStreak\" stats by 1\r\n    statsModule.awardPlayerStatsAsync(player, Map.of(\"Wins\", 1L, \"WinStreak\", 1L));\r\n}\r\n\r\npublic void recordLoss(final Player player) {\r\n    // Increments player's \"Losses\" stat by 1\r\n    statsModule.awardPlayerStatsAsync(player, Map.of(\"Losses\", 1L));\r\n    // Sets player's WinStreak to 0 (since they lost)\r\n    statsModule.setPlayerStatsAsync(player, Map.of(\"WinStreak\", 0L));\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/world/datapoints",
    "title": "World Datapoints",
    "description": "Information about our map datapoint system.",
    "content": "### What are datapoints?\n\nData Points are designed to be stored and loaded from template maps. They allow your level designers to dynamically place down keyed data points while building your maps, which can then be queried at runtime to locate points of interest. This allows you to constantly deploy new maps without needing to update your code, and saves you having to hardcode points of interest for each map.\n\n### MineplexWorld Datapoints\n\nData Points can be queried from a `MineplexWorld` using the `getDataPoints(String)` method, which returns a `List` of `Location`s stored under a given key, or using the `getDataPoints()` method, which returns a `Map` of each key to the `List` of `Location`s stored under them.\n\n### Default Implementation\n\nOur implementation of the MineplexWorldModule allows you to load up a Zip file. This zip file is able to be encoded with datapoints without the need for runtime rendering or calculation of the datapoints.\n\nIn order to load them, within a world's zip file, include `dataPoints.json` or `dataPoints.yml`:\n\n#### Example file structure:\n\n<FileTree>\n  <Folder name=\"CAKE-WARS_COOKIE.zip\" label=\"Example World\">\n    <Folder name=\"data\" label=\"data\" />\n\n    <Folder name=\"entities\" label=\"entities\" />\n\n    <Folder name=\"region\" label=\"region\" />\n\n    <File name=\"dataPoints.json\" label=\"dataPoints.json\" />\n\n    <File name=\"level.dat\" label=\"level.dat\" />\n  </Folder>\n</FileTree>\n\nThis Zip file would then be placed in your repository's `/assets/world-templates` folder and loaded using the world loading methods described in the [World Module](.) documentation.\n\n#### Example JSON file:\n\n```json\n{\r\n  \"SPAWNPOINT_1\": [\r\n    {\r\n      \"x\": 0.5,\r\n      \"y\": 67.0,\r\n      \"z\": 11.5,\r\n      \"yaw\": -180.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"STORE_NPC\": [\r\n    {\r\n      \"x\": -11.476646845190304,\r\n      \"y\": 72.0,\r\n      \"z\": 25.511839252200495,\r\n      \"yaw\": 269.12354,\r\n      \"pitch\": 33.138355\r\n    },\r\n    {\r\n      \"x\": 12.5,\r\n      \"y\": 72.0,\r\n      \"z\": 25.5,\r\n      \"yaw\": 90.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"SPAWNPOINT_2\": [\r\n    {\r\n      \"x\": 41.5,\r\n      \"y\": 67.0,\r\n      \"z\": -18.5,\r\n      \"yaw\": 90.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"SPAWNPOINT_3\": [\r\n    {\r\n      \"x\": 18.5,\r\n      \"y\": 122.0,\r\n      \"z\": 180.5,\r\n      \"yaw\": -180.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n  \"SPAWNPOINT_4\": [\r\n    {\r\n      \"x\": 18.5,\r\n      \"y\": 121.0,\r\n      \"z\": 238.5,\r\n      \"yaw\": -180.0,\r\n      \"pitch\": 0.0\r\n    }\r\n  ],\r\n}\n```\n"
  },
  {
    "slug": "/sdk/features/world",
    "title": "World Module",
    "description": "How to use the Mineplex Studio World Module.",
    "content": "<JavadocLink classpath=\"com.mineplex.studio.sdk.modules.world.MineplexWorldModule\" />\n\nThe World Module is one of the built-in Studio Modules that allows you to create, load, save, and generate worlds dynamically in your project. With the World Module, you can do anything from per-player stored plot worlds, to massive persistent generated adventure worlds, to ephemeral worlds created from map templates. `MineplexWorld`s are totally configurable, from their persistence, to their generation, to whether they exist only in memory. They also contain keyed Data Points that can be used to dynamically load points of interest from varied map templates - the days of hard coding specific locations in your game are long gone.\n\n## Creating a `MineplexWorld`\n\nIn order to create a new `MineplexWorld`, the World Module method `createMineplexWorld(MineplexWorldConfig)` must be executed with a completed and valid `MineplexWorldConfig`.\n\n### `MineplexWorldConfig`\n\nA `MineplexWorldConfig` is comprised of a few key options.\n\nFirst, you have the option to specify a `PersistentWorldConfig`. By default, this is `null`, indicating that the `MineplexWorld` will not be persistent. Setting this value to a valid `PersistentWorldConfig` will cause the created `MineplexWorld` to be persistent.\n\n#### `PersistentWorldConfig`\n\nThe only configuration needed in a `PersistentWorldConfig` is a `String` value for the `worldBucket` option. This value will determine the name of the data collection this persistent world will be stored within.\n\nNext comes the significant portion of the configuration process for a new `MineplexWorld`. The `WorldCreationConfig` comprises almost all of the options that control the makeup of the new world. This config cannot be `null`, and must be filled out by you so as to be valid.\n\n#### `WorldCreationConfig`\n\nWithin the `WorldCreationConfig` there are several configuration options, some of which conflict with each other. The first option is a `String` value for the `worldTemplate`, which defaults to `null`. If this is set to a value, any further options in the `WorldCreationConfig` will be ignored and the `MineplexWorld` will be initialized from the project map template named the same as the `String` value, if the template exists. If there is no such named template, then the world creation will fail. The next option is `voidWorld`, which can be `true` or `false`. This option defaults to `true`, in which case the created world will generate no terrain, and therefore all subsequent options in the `WorldCreationConfig` will be ignored. If this option is set to `false`, then the world will generate via the default generator, or a custom one if specified. A custom world generator can be defined for the new world via the following options:\n\n* `customChunkGenerator` will accept a `ChunkGenerator` implementation from the Bukkit API. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n* `customBlockPopulators` will accept a `Collection<BlockPopulator>`, based on `BlockPopulator` implementations from the Bukkit API. This can be directly specified, or included in the above `customChunkGenerator` if one is set. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n* `customBiomeProvider` will accept a `BiomeProvider` implementation from the Bukkit API. This can be directly specified, or included in the above `customChunkGenerator` if one is set. You should conduct further research on how this API section works before attempting it in your project. Defaults to `null`.\n\nFinally, the seed for the world generation can be specified by setting the `customSeed` option to a given `Long` value. Defaults to `null`, in which case a random seed is used.\n\nAfter the `WorldCreationConfig` is complete, you need to make a determination as to what region format your new `MineplexWorld` should use, by setting the `worldRegionType` option to one of the `WorldRegionFormatType`s. Defaults to `WorldRegionFormatType.ANVIL`.\n\n#### `WorldRegionFormatType`\n\n* `ANVIL`: The Minecraft Java Edition standard region format developed by Mojang. Regions are stored as `.mca` files.\n\nFinally, you must specify whether your `MineplexWorld` should exist exclusively in memory via the `inMemoryOnly` option, or if it should instead utilize the storage of the container to load/unload chunks. By default this is set to `true`, in memory only, and this should work for most use cases. However, **if your map template is significantly large, or if players are able to cause the world to generate without a sufficiently tight boundary, the world may grow to a size that cannot be retained in memory. If this is the case, electing to keep the `inMemoryOnly` option set to `true` may result in undefined behavior or container crashes.**\n\n## Loading a `MineplexWorld` from Storage\n\nThere are two ways to load a persistent `MineplexWorld` from long-term storage. Your first option is the World Module method `loadMineplexWorld(String, String, WorldCreationConfig)`, which attempts to asynchronously download and load in the `MineplexWorld` with the specified ID from the specified `worldBucket`. If no `MineplexWorld` matches the ID in that `worldBucket`, then no `MineplexWorld` is loaded. Alternatively, you can use the World Module method `loadOrCreateMineplexWorld(String, String, MineplexWorldConfig)`, which also attempts to asynchronously download and load in the `MineplexWorld` with the specified ID from the specified `worldBucket`. However, in the case where this method does not find a matching `MineplexWorld`, it will create a new one using the provided `MineplexWorldConfig`.\n\n## Unloading a `MineplexWorld`\n\nYou are not able to force a `MineplexWorld` to unload, however you should not need to. Instead, you can use the World Module method `releaseWorld(MineplexWorld)` to indicate to the World Module that the world is no longer needed. At that point, the World Module will conduct save procedures for the `MineplexWorld` (if any are defined), then unload the world and free up any space.\n\n## Deleting a `MineplexWorld`\n\nThis functionality is specifically for unloaded persistent `MineplexWorld`s. **This should not be called for a loaded or ephemeral world.** To delete a stored persistent `MineplexWorld`, call the World Module method `deleteWorld(String, String)` with the `MineplexWorld` `worldBucket` and ID as the argument.\n\n## Getting a loaded `MineplexWorld`\n\nIn order to get a `MineplexWorld` that has already been loaded by the World Module, use the method `getLoadedMineplexWorld(String)`. **Note that this will require you to know the `MineplexWorld` ID.**\n\n## Data Points\n\nView full information on datapoints [here](docs/sdk/features/world/datapoints)\n\n## Examples\n\n## Creating a `MineplexWorld` from a Map Template\n\nLet's say we have some map templates in our project. We can dynamically create new `MineplexWorld`s based on those templates at runtime.\n\n```java\npublic MineplexWorld createFromTemplate(final String template) {\r\n    // Creates a new in-memory, ephemeral world from the given template using the ANVIL region format\r\n    return worldModule.createMineplexWorld(MineplexWorldConfig.builder()\r\n            .worldRegionType(MineplexWorldConfig.WorldRegionFormatType.ANVIL)\r\n            .worldCreationConfig(WorldCreationConfig.builder()\r\n                    .worldTemplate(template)\r\n                    .build())\r\n            .build());\r\n}\n```\n\n## Randomly Generating a `MineplexWorld`\n\nLet's say we don't want to use a template. We can create a new `MineplexWorld` using the random world generation built into the game. We can also make it persistent.\n\n```java\npublic MineplexWorld generateNewPersistentWorld(final Long seed) {\r\n    // Creates and generates a new persistent world cached on the filesystem\r\n    // using the anvil region format and a seed\r\n    return worldModule.createMineplexWorld(MineplexWorldConfig.builder()\r\n            .persistentWorldConfig(PersistentWorldConfig.builder()\r\n                    .worldBucket(\"Examples\")\r\n                    .build())\r\n            .worldCreationConfig(WorldCreationConfig.builder()\r\n                    .voidWorld(false)\r\n                    .customSeed(seed)\r\n                    .build())\r\n            .build());\r\n}\n```\n"
  },
  {
    "slug": "/sdk/gui",
    "title": "GUI Menus",
    "description": "How to use the GUI Menus in the Studio.",
    "content": "By releasing your game on the Mineplex Studio, you are gaining access to players of both the Java Edition and Bedrock Edition of Minecraft simultaneously. While the two editions are similar, there are some key differences. One of the largest distinctions between the two is interaction with GUI Menus. Those familiar with Java Edition should be well-acquainted with the classic inventory-based menu, while those who primarily play Bedrock Edition are instead used to the modal-based Forms used in that version. Since your game is served to both types of player, it is important to reconcile this difference in functionality so everyone can play your game to the fullest.\n\n## MineplexGUI\n\nAny GUI Menu used in a Studio project should implement the `MineplexGUI` interface. To do so properly, you are required to implement both a Bedrock Form menu using [Cumulus](https://wiki.geysermc.org/geyser/forms/) that is created when the `createBedrockForm(Player)` method is called, and a Java inventory menu using [InUI](https://github.com/NichtStudioCode/InvUI) that is created when the `createJavaInventoryMenu(Player)` method is called. The `MineplexGUI` interface additionally provides a default `createAndOpen(Player)` method implementation that checks if the player is on a Bedrock client, and if so opens the Bedrock Form, and otherwise opens the Java inventory menu.\n\n# Example\n\nLet's create a very basic GUI Menu with one button a player can press.\n\n```java\npublic class MyGUI implements MineplexGUI {\r\n   private void pickNo(final Player player) {\r\n       player.sendMessage(Component.text(\"Picked No!\"));\r\n   }\r\n\r\n   private void pickYes(final Player player) {\r\n       player.sendMessage(Component.text(\"Picked Yes!\"));\r\n   }\r\n\r\n   private void pickNone(final Player player) {\r\n       player.sendMessage(Component.text(\"Picked None!\"));\r\n   }\r\n\r\n   @Override\r\n   public Form createBedrockForm(final @NotNull Player player) {\r\n       return ModalForm.builder()\r\n               .title(\"Y/N\")\r\n               .content(\"Pick Yes or No\")\r\n               .button1(\"Yes\")\r\n               .button2(\"No\")\r\n               .closedOrInvalidResultHandler(() -> this.pickNone(player))\r\n               .validResultHandler((modalForm, modalFormResponse) -> {\r\n                   if (\"Yes\".equals(modalFormResponse.clickedButtonText())) {\r\n                       this.pickYes(player);\r\n                   } else {\r\n                       this.pickNo(player);\r\n                   }\r\n               })\r\n               .build();\r\n   }\r\n\r\n   @Override\r\n   public Window createJavaInventoryMenu(final @NotNull Player player) {\r\n       final ItemStack yesItem = new ItemStack(Material.LIME_WOOL);\r\n       yesItem.editMeta(meta -> meta.displayName(MiniMessage.miniMessage().deserialize(\"<green>Yes</green>\")));\r\n\r\n       final ItemStack noItem = new ItemStack(Material.RED_WOOL);\r\n       noItem.editMeta(meta -> meta.displayName(MiniMessage.miniMessage().deserialize(\"<red>No</red>\")));\r\n\r\n       final Gui gui = Gui.normal()\r\n               .setStructure(\"# # # Y # N # # #\")\r\n               .addIngredient('Y', new SimpleItem(yesItem, click -> this.pickYes(click.getPlayer())))\r\n               .addIngredient('N', new SimpleItem(noItem, click -> this.pickNo(click.getPlayer())))\r\n               .build();\r\n\r\n       return Window.single()\r\n               .setViewer(player)\r\n               .setTitle(\"Pick Yes or No\")\r\n               .setGui(gui)\r\n               .addCloseHandler(() -> this.pickNone(player))\r\n               .build();\r\n   }\r\n}\n```\n\nFor details on creating more detailed menus, please visit the documentation for both types of GUIs.\n\nNow that we've created our GUI Menu, we can show it to a player.\n\n```java\nprivate final MyGUI myGUI = new MyGUI();\r\n\r\npublic void askPlayer(final Player player) {\r\n    myGUI.createAndOpen(player);\r\n}\n```\n"
  },
  {
    "slug": "/sdk",
    "title": "Building Your Game",
    "description": "How to get started building a game with the Mineplex Studio SDK.",
    "content": "Once you've created a new project, you can get started building your game on top of the Studio SDK.\n\n## Prerequisites\n\nBefore you can get started with the SDK, you'll need to install the [Dependency](/docs/sdk/installation). If you created your project using the Studio CLI, this will be installed by default already. You also need to make sure you have JDK21 installed on your computer.\n\n## Modules\n\nThe Studio SDK is comprised of multiple different types of functionality, referred to as \"Modules\". The SDK comes pre-packaged with several built-in modules we made for you. You can also make your own custom modules to implement your unique gameplay! Soon, we also plan to allow you to make modules to sell to other game developers via our asset marketplace.\n\n## Java Project Setup\n\nWhen building a game using the Studio SDK, it's important to make sure you're targeting the right version of Minecraft and Java. The Studio currently supports the latest version of Minecraft (1.21.1) and Java 21. Your Studio project will be packaged in the form of a Paper plugin. If you're not familiar with what that is, we encourage you to do some research before getting started.\n"
  },
  {
    "slug": "/sdk/installation",
    "title": "Dependency Installation",
    "description": "How to install the Mineplex Studio SDK.",
    "content": "## Components and Updating the SDK\n\nThe Studio SDK dependency is vended in two pieces:\n\n* The Core SDK, which contains a set of interfaces, data classes, and API contracts to interact with various Mineplex Modules. This is automatically added to your project and has the artifact coordinates of `com.mineplex.sdk.plugin`. You can update the version manually by changing the version of this artifact.\n* The Engine, which implements interfaces provided in the Core SDK. This is installed as a plugin JAR into your project when you test your code in Development Containers or when you publish your game to the Studio. The latest version of the Engine plugin is automatically vended to your game containers as they are launched, and there is not yet any way to specify other versions.\n"
  },
  {
    "slug": "/sdk/internationalization",
    "title": "Internationalization",
    "description": "How to internationalize text strings in the Studio.",
    "content": "By releasing your game on the Mineplex Studio, you are gaining access to a global audience of players, all excited to\r\ntry out what you've built. In order to make sure that all our players have the best possible experience, no matter where\r\nthey're from, we've prioritized our internationalization system from the outset. While you are not required to make use\r\nof this system, you are highly encouraged to take advantage of it if you can. Your game's reach and playerbase will grow\r\nfrom making all players feel welcome!\n\n## Language Selection\n\nOur internationalization system integrates directly with the game client to perform language selection, meaning your\r\nplayers will automagically experience your game in the language they're already familiar with playing Minecraft in -\r\nassuming you've provided the necessary translations.\n\n## Language Mappings\n\nLanguage data files should stored as UTF-8 encoded `.properties` files in the `resource` directory of your project\r\nand loaded on application startup through the `I18NModule`.\n\n## API\n\nAfter loading the translations, you can use the `Component.translatable` method to create a translatable component.\n\n## Examples\n\n## Mappings\n\nLet's say we're internationalizing our application. In our `resource` directory, we need to create a mapping\r\nfile, such as `MyMessages_en.properties` for English or `MyMessages_de.properties` for German.\n\nOur english translations inside `MyMessages_en.properties`\n\n```properties\nmy_game.join.greeting=Hello there!\n```\n\nOur german translations inside `MyMessages_de.properties`\n\n```properties\nmy_game.join.greeting=Hallo!\n```\n\nLets load our new translations!\n\n```java\npublic void loadTranslations() {\r\n    final I18NModule i18NModule = MineplexModuleManager.getRegisteredModule(I18NModule.class);\r\n    for (final Locale locale : i18NModule.getAvailableLocales()) {\r\n        final ResourceBundle bundle = ResourceBundle.getBundle(\"MyMessages\", locale, UTF8ResourceBundleControl.get());\r\n        i18NModule.addTranslation(locale, bundle, true);\r\n    }   \r\n}\n```\n\n## API\n\nNow that we have our mapping, we can use it in our game code.\n\n```java\nprivate final Component greetingText = Component.translatable(\"my_game.join.greeting\");\r\n\r\n@EventHandler\r\npublic void onJoin(final PlayerJoinEvent event) {\r\n   player.sendMessage(greetingText);\r\n}\n```\n"
  },
  {
    "slug": "/sdk/thirdparty",
    "title": "Third Party Resources",
    "description": "Third Party Developer Resources in the Studio.",
    "content": "The Mineplex Studio comes packaged with several third party developer resources that make it easier than ever before to make a fantastic game in Minecraft. We are constantly evaluating the developer landscape and adding new resources to this list, so don't forget to check back here often!\n\n## Paper\n\n[Paper](https://papermc.io/software/paper) is a Minecraft game server based on Spigot, designed to greatly improve performance and offer more advanced features and API. This includes the [Adventure User Interface API](https://docs.advntr.dev/index.html), and the [md\\_5 BungeeCord chat API](https://www.spigotmc.org/wiki/the-chat-component-api/).\n\n## FloodGate\n\n[FloodGate](https://wiki.geysermc.org/floodgate/) is a Geyser addition allowing you to distinguish between Java Edition and Bedrock Edition players and to send Bedrock Edition players [Cumulus Forms](https://wiki.geysermc.org/geyser/forms/).\n\n## InvUI\n\n[InvUI](https://github.com/NichtStudioCode/InvUI) is a powerful library allowing you to efficiently and easily create and manage complex and detailed inventory-based GUIs for players to interact with in your projects.\n\n## HolographicDisplays\n\n[HolographicDisplays](https://github.com/filoghost/HolographicDisplays) is a library allowing you to display text and items to players using futuristic in-game Holograms. This API can be accessed using the `HologramUtil` in the Studio SDK.\n\n## ProtocolLib\n\n[ProtocolLib](https://www.spigotmc.org/resources/protocollib.1997/) is a library that allows read and write access to the [Minecraft protocol](https://wiki.vg/Protocol). It handles most of the overhead required with reflection and channel injection and provides wrappers to simplify packet modification.\n\n## LibsDisguises\n\n[Lib's Disguises](https://www.spigotmc.org/resources/libs-disguises-free.81/) is a library that lets you disguise any entity, as any entity. You can fully customize all these disguises, and even apply special effects to disguises. Examples include creating a player disguise called \"Notch\", but he's always sneaking, or disguising every creeper as a friendly villager. Part of the Lib's Disguises functionality is the ability to let players see their own disguises.\n\n## MythicMobs\n\n[MythicMobs](https://www.spigotmc.org/resources/⚔-mythicmobs-free-version-►the-1-custom-mob-creator◄.5702/) allows you to fully modify all attributes of monsters in your project, and even create your own mobs, bosses, and other many other fun mob-related things.\n\n## ModelEngine\n\n[Model Engine](https://mythiccraft.io/index.php?resources/model-engine—ultimate-entity-model-manager-1-16-5-1-20.389/) allows you to effortlessly create seemingly modded models for mobs in your project, without touching any configs.\n\n## Ignite\n\n[Ignite](https://github.com/vectrix-space/ignite) expands the limits of what you can do with just Paper, granting you access to Mixins and Access Wideners within the Paper ecosystem so that you have the option to directly modify the server to make the game of your dreams.\n"
  }
]